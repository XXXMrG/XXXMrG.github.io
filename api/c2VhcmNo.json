[{"title":"Redux 哲学","date":"2019-07-16T14:05:53.000Z","updated":"2019-07-16T14:09:19.604Z","content":"Redux is a predictable state container for JavaScript apps.\nIt helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as live code editing combined with a time traveling debugger.\nReducerWe’ll start by specifying the initial state. Redux will call our reducer with anundefinedstate for the first time. This is our chance to return the initial state of our app关于 state 的默认值，首次 call reducer 的时候 state 的默认值是 undefined 我们可以通过 es6 的默认参数来指定默认初始值，或者保证每一个 reducer 中都有对于 undefined 的判断，这很重要，需要保证 reducer 在默认操作的时候返回原对象来避免不必要的重复渲染。\n关于 combineReducersNote that each of these reducers is managing its own part of the global state. The state parameter is different for every reducer, and corresponds to the part of the state it manages.核心实现点在于 combine 的每一个 reducer 所对应的 key 都应该在 state 中能够找到相对应的 key 。实际上 comboine  的 reducer 在每一次 dispatch 的时候都会被调用，同时分别进行比较，而匹配到的 action.type 则必然会触发其所对应的部分 state 的改变，因此会返回新的对象，而如果没有匹配项或者是 state 不变，那么就仍然会返回原对象，避免不必要的重复渲染。\n我们要知道 redux 中的对象 diff 判断是简单的浅对比，即  ===  因此只要是返回一个新的对象就一定会引起重复 render\n核心源码\n12345678910111213141516171819202122232425262728293031323334export default function combineReducers(reducers) &#123;  const reducerKeys = Object.keys(reducers)  const finalReducers = &#123;&#125;  // copy the reducers to a new object 并通过闭包保存  for (let i = 0; i &lt; reducerKeys.length; i++) &#123;    const key = reducerKeys[i]    if (typeof reducers[key] === 'function') &#123;      finalReducers[key] = reducers[key]    &#125;  &#125;  const finalReducerKeys = Object.keys(finalReducers)  // 对外返回的格式就是一个普通的 reducer  return function combination(state = &#123;&#125;, action) &#123;    if (shapeAssertionError) &#123;      throw shapeAssertionError    &#125;    let hasChanged = false    const nextState = &#123;&#125;    for (let i = 0; i &lt; finalReducerKeys.length; i++) &#123;      const key = finalReducerKeys[i]      const reducer = finalReducers[key]      const previousStateForKey = state[key]      const nextStateForKey = reducer(previousStateForKey, action)      if (typeof nextStateForKey === 'undefined') &#123;        const errorMessage = getUndefinedStateErrorMessage(key, action)        throw new Error(errorMessage)      &#125;      nextState[key] = nextStateForKey      hasChanged = hasChanged || nextStateForKey !== previousStateForKey    &#125;    return hasChanged ? nextState : state  &#125;&#125;\nconnect 到底是干特么啥的更优雅且更常用的 store.subscribe() 用于在 store 更新的时候将数据通过 props 传递到使用了更新部分数据的组件，并触发该组件重新 render \nstore 是怎么和 compontents 关联到一起的Connect: Extracting Data with mapStateToProps · React Redux\n现在来创建一些容器组件把这些展示组件和 Redux 关联起来。技术上讲，容器组件就是使用 store.subscribe() 从 Redux state 树中读取部分数据，并通过 props 来把这些数据提供给要渲染的组件。你可以手工来开发容器组件，但建议使用 React Redux 库的 connect() 方法来生成，这个方法做了性能优化来避免很多不必要的重复渲染。（这样你就不必为了性能而手动实现 React 性能优化建议 中的shouldComponentUpdate方法。）\nAs the first argument passed in toconnect,mapStateToPropsis used for selecting the part of the data from the store that the connected component needs. It’s frequently referred to as justmapStatefor short.\nconnect 的第一个参数，通过 mapState 来过滤 store 中的与相连组件有关的数据，数据会通过 props 传递到组件内部。\nstateThe first argument to a mapStateToPropsfunction is the entire Redux store state (the same value returned by a call tostore.getState()). Because of this, the first argument is traditionally just calledstate. (While you can give the argument any name you want, calling itstorewould be incorrect - it’s the “state value”, not the “store instance”.)ThemapStateToPropsfunction should always be written with at leaststatepassed in.\nownProps**(optional)**You may define the function with a second argument,ownProps, if your component needs the data from its own props to retrieve data from the store. This argument will contain all of the props given to the wrapper component that was generated byconnect.通过 ownProps 得到组件使用的时候传入的 props 通常用于映射到另外一个 state 并连接到视图组件中。\n在 connect 中发起 dispatchConnect: Dispatching Actions with mapDispatchToProps · React Redux\ndispatch 的发起方式有两种，一种是简单的从 this.props.dispatch 中直接调用，另外一种就是通过 connect 传递一个 具名化的 dispatch 给连接的组件供组件使用。\nProviding a mapDispatchToProps allows you to specify which actions your component might need to dispatch. It lets you provide action dispatching functions as props. Therefore, instead of calling props.dispatch(() =&gt; increment()),  you may call props.increment() directly. There are a few reasons why you might want to do that.\nMore DeclarativeFirst, encapsulating the dispatch logic into function makes the implementation more declarative. Dispatching an action and letting the Redux store handle the data flow ishow toimplement the behavior, rather thanwhatit does.A good example would be dispatching an action when a button is clicked. Connecting the button directly probably doesn’t make sense conceptually, and neither does having the button referencedispatch.更直观，屏蔽组件对 dispatch 的存在，更关注与怎么做的层面。\n12345// button needs to be aware of \"dispatch\"&lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"SOMETHING\" &#125;)&#125; /&gt;// button unaware of \"dispatch\",&lt;button onClick=&#123;doSomething&#125; /&gt;\nOnce you’ve wrapped all our action creators with functions that dispatch the actions, the component is free of the need ofdispatch. Therefore,if you define your own mapDispatchToProps, the connected component will no longer receive dispatch.\nPass Down Action Dispatching Logic to ( Unconnected ) Child Components\nIn addition, you also gain the ability to pass down the action dispatching functions to child ( likely unconnected ) components. This allows more components to dispatch actions, while keeping them “unaware” of Redux.通过传递 dispatch 可以让子组件也发起 dispatch 。即使这个子组件可能并没有直接与 store 相连。\n123456789// pass down toggleTodo to child component// making Todo able to dispatch the toggleTodo actionconst TodoList = (&#123; todos, toggleTodo &#125;) =&gt; (  &lt;div&gt;    &#123;todos.map(todo =&gt; (      &lt;Todo todo=&#123;todo&#125; onClick=&#123;toggleTodo&#125; /&gt;    ))&#125;  &lt;/div&gt;)\n\nThis is what React Redux’s connect does — it encapsulates the logic of talking to the Redux store and lets you not worry about it. And this is what you should totally make full use of in your implementation.\n\nmiddleware 又是干特么啥的Referencejavascript - 为什么action会触发所有reducers - SegmentFault 思否\n","thumbnail":"https://i.loli.net/2019/07/16/5d2dda4196d9b25564.png","color":"#111","plink":"https://xkeith.space/post/arc-28/"},{"title":"搞定 node","date":"2019-06-26T12:43:14.000Z","updated":"2019-06-26T13:03:52.722Z","content":"\n一切能用 JavaScript 实现的软件都必有其 JavaScript 版本。\n\n我们要知道 node 并非一种语言，他仅仅是一种 JavaScript 执行环境，得益于 Google 的 v8 引擎的高性能，node 环境下的服务端在处理 IO 密集型任务的时候的效率相当的高，node 同样支持微服务架构。\nnode 事件循环Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。Node.js 几乎每一个 API 都是支持回调函数的。Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.\n事件驱动程序Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\n\n","thumbnail":"https://i.loli.net/2019/06/26/5d1368c49367d72234.png","color":"#111","plink":"https://xkeith.space/post/arc-27/"},{"title":"Airbnb JavaScript Style Guide","date":"2019-06-14T10:35:18.000Z","updated":"2019-06-23T14:09:45.288Z","content":"\n自律即自由\n\n1.Reference1.1 Use const for all of your references; avoid using var为所有对象使用 const 同时不要使用 var 来声明任何变量。使用具有块级作用域的 let 而不要继续使用 var，它具有令人疑惑的函数作用域。\n2.Objects2.1 Use the literal syntax for object creation直接使用字面量来创建对象。12345// badconst item = new Object();// goodconst item = &#123;&#125;;\n2.2 Use computed property names when creating objects with dynamic property names.使用计算属性当创建对象时需要动态属性名的情况，这可以使你的对象属性都在同一个位置定义。1234567891011121314151617function getKey(k) &#123;  return `a key named $&#123;k&#125;`;&#125;// badconst obj = &#123;  id: 5,  name: 'San Francisco',&#125;;obj[getKey('enabled')] = true;// goodconst obj = &#123;  id: 5,  name: 'San Francisco',  [getKey('enabled')]: true,&#125;;\n2.3 Use object method shorthand.使用 ES6 新增的对象方法简写形式。1234567891011121314151617// badconst atom = &#123;  value: 1,  addValue: function (value) &#123;    return atom.value + value;  &#125;,&#125;;// goodconst atom = &#123;  value: 1,  addValue(value) &#123;    return atom.value + value;  &#125;,&#125;;\n2.4 Use property value shorthand使用 ES6 新增的对象属性简写形式。1234567891011const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123;  lukeSkywalker: lukeSkywalker,&#125;;// goodconst obj = &#123;  lukeSkywalker,&#125;;\n2.5 Group your shorthand properities at the beginning of your object declaration把使用简写模式的属性放到其他属性的前面，这样可以让简写属性一目了然。12345678910111213141516171819202122const anakinSkywalker = 'Anakin Skywalker';const lukeSkywalker = 'Luke Skywalker';// badconst obj = &#123;  episodeOne: 1,  twoJediWalkIntoACantina: 2,  lukeSkywalker,  episodeThree: 3,  mayTheFourth: 4,  anakinSkywalker,&#125;;// goodconst obj = &#123;  lukeSkywalker,  anakinSkywalker,  episodeOne: 1,  twoJediWalkIntoACantina: 2,  episodeThree: 3,  mayTheFourth: 4,&#125;;\n2.6 Only quote properties that are invalid identifiers只有当属性名非法的时候才使用引号。这样会增强可读性，改善编辑器的高亮效果，也可以更容易的被 JavaScript 引擎优化。12345678910111213// badconst bad = &#123;  'foo': 3,  'bar': 4,  'data-blah': 5,&#125;;// goodconst good = &#123;  foo: 3,  bar: 4,  'data-blah': 5,&#125;;\nReferenceGitHub - airbnb/javascript: JavaScript Style Guide\n","plink":"https://xkeith.space/post/arc-26/"},{"title":"踏破 CSS","date":"2019-06-08T15:30:28.000Z","updated":"2019-06-23T14:10:05.163Z","content":"\n天才第一步，CSS 要轻车熟路\n\n","plink":"https://xkeith.space/post/arc-25/"},{"title":"每天（不知道有几）道前端面试题（六月）","date":"2019-06-03T14:46:59.000Z","updated":"2019-06-26T13:48:55.210Z","content":"\n本月在这里整理一些 React 和 Node 的面试题。当然还有算法的一些练习。\n\n2019/06/26解释一下偏函数和函子\n2019/06/0330s-of-code\n\ndeepCloneCreates a deep clone of an object.Use recursion. UseObject.assign()and an empty object ({}) to create a shallow clone of the original. UseObject.keys()andArray.prototype.forEach()to determine which key-value pairs need to be deep cloned.\n\n1234567891011121314151617const deepClone = obj =&gt; &#123;  let clone = Object.assign(&#123;&#125;, obj)  Object.keys(clone).forEach(    key =&gt;      (clone[key] =        typeof obj[key] === \"object\" ? deepClone(obj[key]) : obj[key])  )  return Array.isArray(obj) &amp;&amp; obj.length    ? (clone.length = obj.length) &amp;&amp; Array.from(clone)    : Array.isArray(obj)    ? Array.from(obj)    : clone&#125;const a = &#123; foo: 'bar', obj: &#123; a: 1, b: 2 &#125; &#125;;const b = deepClone(a); // a !== b, a.obj !== b.objconsole.log(a === b)","plink":"https://xkeith.space/post/arc-24/"},{"title":"React 技术栈","date":"2019-06-02T08:20:32.000Z","updated":"2019-06-23T14:27:36.784Z","content":"React 技术栈\nReact\nState\n不要直接修改 State\n\nState 的更新可能是异步的\n\nState 的更新会被合并\n\n数据流是向下流动的\n\n\n事件处理\n注意绑定的回调函数的 this 可以采用显示 bind 或者使用 class fields 语法\n\n向事件处理程序传递参数，通过箭头函数或者 bind 注意 React 的事件对象 e 会被作为第二个参数传递，如果使用箭头函数事件对象必须显式的进行传递。\n\n\n列表 key\n注意要保证列表有 key 且最好不要是 index\n\n一个好的经验法则是：在map()方法中的元素需要设置 key 属性。\n\nkey 会传递信息给 React 但不会传递任何信息给你的组件\n\nJSX 中可以直接内联 map 但是必要的时候你要注意组件提取\n\n\n表单在 React 里，HTML 表单元素的工作方式和其他的 DOM 元素有些不同，这是因为表单元素通常会保持一些内部的 state。\n在 HTML 中，表单元素（如&lt;input&gt;、&lt;textarea&gt;和&lt;select&gt;）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState() 来更新。\n我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。\n组合 vs 继承\nprops.children  用来传递并渲染子组件\n\n同样可以直接传递组件作为 props\n\n\nReact 哲学\n将 UI 稿划分为组件层级，保证单一功能原则，如果一个组件负责的功能超过一个，请考虑将其拆分为更小的组件。\n先用 props 构建一个静态版本，不包含功能交互的静态版本，注意此时不应该用到 state 因为 state 是可变的，应该在功能交互的时候使用。\n确定 UI state 的最小（完整）表示。设计那些数据需要使用 state ，避免将可以计算或不变的数据设置为 state\n确定 state 放置的位置，适当的提升状态来实现组件间的单向数据流\n通过传递回调函数来实现反向数据流，实现用子组件更新父组件\n\nRedux\nRedux 是 JavaScript 状态容器，提供可预测化的状态管理\n\nReact 存在的痛点单一数据流严重限制了组件间数据的通信，即使存在状态提升或者是通过传递回调函数的方式来实现数据流传递，当一个单页应用的规模变大后数据管理将是很困难的。\n三大原则\n单一数据源\nState 是只读的\nreducer 应该是纯纯的函数\n\n应用中所有的 state 都以一个对象树的形式储存在一个单一的store中。 惟一改变 state 的办法是触发action，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写reducers。\n1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; createStore &#125; from 'redux';/** * 这是一个 reducer，形式为 (state, action) =&gt; state 的纯函数。 * 描述了 action 如何把 state 转变成下一个 state。 * * state 的形式取决于你，可以是基本类型、数组、对象、 * 甚至是 Immutable.js 生成的数据结构。惟一的要点是 * 当 state 变化时需要返回全新的对象，而不是修改传入的参数。 * * 下面例子使用 `switch` 语句和字符串来做判断，但你可以写帮助类(helper) * 根据不同的约定（如方法映射）来判断，只要适用你的项目即可。 */function counter(state = 0, action) &#123;  switch (action.type) &#123;  case 'INCREMENT':    return state + 1;  case 'DECREMENT':    return state - 1;  default:    return state;  &#125;&#125;// 创建 Redux store 来存放应用的状态。// API 是 &#123; subscribe, dispatch, getState &#125;。let store = createStore(counter);// 可以手动订阅更新，也可以事件绑定到视图层。store.subscribe(() =&gt;  console.log(store.getState()));// 改变内部 state 惟一方法是 dispatch 一个 action。// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行store.dispatch(&#123; type: 'INCREMENT' &#125;);// 1store.dispatch(&#123; type: 'INCREMENT' &#125;);// 2store.dispatch(&#123; type: 'DECREMENT' &#125;);// 1\nStore整个应用的  被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。\nReducer虽然出于性能方面的考虑， 写不纯的 reducer 来变动数据在技术上是可行的，但我们并不鼓励这么做。不纯的 reducer 会使一些开发特性，如时间旅行、记录/回放或热加载不可实现。此外，在大部分实际应用中，这种数据不可变动的特性并不会带来性能问题，就像 Om 所表现的，即使对象分配失败，仍可以防止昂贵的重渲染和重计算。而得益于 reducer 的纯度，应用内的变化更是一目了然。\nActionAction 是用来描述且进行更新 state 的唯一手段，可以理解为是一个描述数据转化的对象，有了 Action 我们可以对每一步数据操作都有清晰的掌控，Action 可以调用 reducer 来操作数据。\nImmutableRedux-Saga实际上这就是一个完成异步 reducer 的库，因为在 redux 中我们要求所有的 reducer 都必须是纯函数，而业务中肯定难免遇到异步操作，Redux-Saga 是一个更为优雅的解决方案\nDva万能的支付宝给出的目前最完美的 React 解决方案。相当于 React + Redux + Redux-Saga + React-Router\nantd别说了，用就完事了。\n","thumbnail":"https://i.loli.net/2019/06/23/5d0f8c4b925ad42384.png","color":"#111","plink":"https://xkeith.space/post/arc-23/"},{"title":"每天（不知道有几）道前端面试题（五月）","date":"2019-05-20T04:00:00.000Z","updated":"2019-05-20T08:48:42.992Z","content":"\n题库主要来自于木易阳的 Github 整理和个人平时面试经验。题库收集原则上仅供笔者个人学习整理所用，一切版权都归 Reference 及相应公司所有。从五月起每天一段 JavaScript 代码段，主要来源于 30s-of-code 让写代码像呼吸一样自然。\n\n2019/05/20字节跳动 2019 年春招前端开发实习生一面\n\n详细解释一下同源策略\n字符串类型转换的问题\nJavaScript 值类型数据和引用类型数据的两种存储方式\n对象和数组的底层数据结构\n事件冒泡的问题\n\nHTTP访问控制（CORS） - HTTP | MDNjs六种数据类型是怎么样存储的？ - kangzai2012的博客 - CSDN博客\n6种基本类型\n\nstring\nnumber\nboolean\nundefined\nnull\nsymbol\n\n基本数据类型都是一些简单的数据段，它们是存储在栈内存中\n引用数据类型\n引用数据类型是保存在堆内存中的，然后再栈内存中保存一个对堆内存中实际对象的引用。所以，JavaScript中对引用数据类型的操作都是操作对象的引用而不是实际的对象。可以理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的。\n\n为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？\n\n堆比栈大，栈比对速度快。\n基础数据类型比较稳定，而且相对来说占用的内存小。\n引用数据类型大小是动态的，而且是无限的。\n堆内存是无序存储，可以根据引用直接获取。\n\n代码题\n\n括号匹配\n一个版本号排序的问题，考察函数式编程\n读程序说结果\n\n12345678const p = new Promise(resolve =&gt; &#123;\tresolve(1);  Promise.resolve(2).then(console.log);&#125;);p.then(console.log);// =&gt; 2 1// 思考为什么？\n12345678&lt;div id = \"parent\"&gt; &lt;div id = \"child\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;script&gt;    parent.addEventListener(\"click\", () =&gt; alert(1));    parent.addEnentListener(\"click\", () =&gt; alert(2), true);    child.addEventListener(\"click\", () =&gt; alert(3));    child.addEventListener(\"click\", () =&gt; alert(4), true);&lt;/script&gt;// =&gt; 2 3 4 1\n2019/05/17\n输出以下代码运行结果\n\n12345678910111213141516171819// example 1var a=&#123;&#125;, b=&apos;123&apos;, c=123;  a[b]=&apos;b&apos;;a[c]=&apos;c&apos;;  console.log(a[b]);---------------------// example 2var a=&#123;&#125;, b=Symbol(&apos;123&apos;), c=Symbol(&apos;123&apos;);  a[b]=&apos;b&apos;;a[c]=&apos;c&apos;;  console.log(a[b]);---------------------// example 3var a=&#123;&#125;, b=&#123;key:&apos;123&apos;&#125;, c=&#123;key:&apos;456&apos;&#125;;  a[b]=&apos;b&apos;;a[c]=&apos;c&apos;;  console.log(a[b]);\n考察知识点：\n\n对象的 key 必须是字符串或者是 Symbol 类型\n其他类型的键名会被转换成字符串类型\n对象转字符串默认也会调用 toString 方法\n\n所以第一个例子中的两个键名是相同的，都是 “123”。因此后一个值会覆盖前一个值。而第二个例子中的两个键名都是 Symbol 类型，因此不会重复，也不会发生覆盖现象。第三个例子中的键名是对象类型，被调用 toString 之后的结果都是 [object object] ，因此后一个值同样会覆盖前一个值。\n2019/05/16\n详细解释一下 HTML 5 中的 hash 和 history ，他们常用的 API，以及浏览器实现两种不同的路由方式的原理。\n\nhash 和 history的区别 - A13330069275的博客 - CSDN博客\nhistory\npushState()replaceState()\nhistory 的实现基于浏览器的历史记录栈，通过对历史记录的修改来跳转页面，因此 history 虽然改变了路由，并不会向服务器发送请求。这样带来的问题是一般的单页面应用是不会覆盖全所有页面的路由的，这样一来用户如果直接输入 URL 或者刷新页面去强制请求服务器的话就会 404，因此需要我们在服务端配置好。\nhash\nhashChange()\nhash 模式下，只有 hash 符号前的 URL 才会被请求到服务端，因此即使后端没有做到对路由的全覆盖也不会出现 404。\n2019/05/15\n使用 JavaScript Proxy 实现简单的数据绑定\n\n30s-of-code\nFlip takes a function as an argument, then makes the first argument the last.\nReturn a closure that takes variadic inputs, and splices the last argumentto make it the first argument before applying the rest.\n12345678910const flip = fn =&gt; (first, ...rest) =&gt; fn(...rest, first);let a = &#123; name : \"John Smith\" &#125;;let b = &#123;&#125;;const mergeFrom = flip(Object.assign);// 这里是利用了 bind 构造了柯里化函数，默认第一个参数是 alet mergePerson = mergeFrom.bind(null, a);// 实际上就是 mergeFrom(b, a) 我们的函数会把第一个参数移动到最后console.log(mergePerson(b));b = &#123;&#125;;console.log(Object.assign(b, a));\n2019/05/14\n解释一下 vue 中的 $nextTick\n\n你真的理解$nextTick么 - 掘金\n\n在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。可能你还没有注意到，Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。\n\n实际上 $nextTick 是一个微任务，因此在 JavaScript 引擎结束工作后会立即调用微任务队列中的回调函数，因为一个 Evevt Loop 的执行流程是 宏任务 -&gt; 微任务 -&gt; GUI 引擎 -&gt; 下一个宏任务。因此使用 $nextTick 的好处在于可以最早的拿到修改后的 DOM 对象，不需要非要等待 GUI 渲染结束。\n30s-of-code\nCounts the occurrences of a value in an array.\nUse Array.prototype.reduce()to increment a counter each time you encounter the specific value inside the array.\n123456789/*** @param &#123;[]&#125; arr* @param &#123;*&#125; val*/const countOccurrences = (arr, val) =&gt;    arr.reduce((a, v) =&gt; (v === val ? a + 1 : a), 0);console.log(countOccurrences([1, 1, 2, 1, 2, 3], 2));\n2019/05/13\n为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因\n\n\nfor 循环没有任何额外的函数调用栈和上下文；\n\nforEach函数签名实际上是\n\n\narray.forEach(function(currentValue, index, arr), thisValue)它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；\n\n2019/05/1130s-of-code\n\nchainAsync\nChains asynchronous functions.\nLoop through an array of functions containing asynchronous events, calling next when each asynchronous event has completed.\n\n12345678910111213141516171819202122232425262728/**** @param &#123;[function]&#125; fns*/const chainAsync = fns =&gt; &#123;    let curr = 0;    const last = fns[fns.length - 1];    const next = () =&gt; &#123;        // 这里递归传入下一个数组中的函数        const fn = fns[curr++];        fn === last ?  fn() : fn(next);    &#125;;    next();&#125;;chainAsync([    next =&gt; &#123;        console.log(\"0 seconds\");        setTimeout(next, 1000);    &#125;,    next =&gt; &#123;        console.log(\"1 second\");        setTimeout(next, 1000);    &#125;,    () =&gt; &#123;        console.log(\"2 second\");    &#125;]);\n2019/05/1030s-of-code\n\nReplaces all but the last num of characters with the specified mask character.\nUse String.prototype.slice() to grab the portion of the characters thatwill remain unmasked and use String.padStart()to fill the beginning of the string with the mask character up to the original length.Omit the second argument, num, to keep a default of 4 characters unmasked. If num is negative,the unmasked characters will be at the start of the string.Omit the third argument, mask, to use a default character of ‘*’ for the mask.\n\n12345678910const mask = (cc, num = 4, mask = \"*\") =&gt; &#123;    // 最右侧 num 个字符不变，在其左侧填充 mask 直到长度等于原字符串长度    return `$&#123;cc&#125;`.slice(-num).padStart(`$&#123;cc&#125;`.length, mask);&#125;let res = mask(\"13123\", 3, \"$\")console.log(res)res = mask(\"123123123fuck\")console.log(res);\n2019/05/09\n介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的\n\n\n30s-of-code\nGroups the elements of an array based on the given function.\nUse Array.prototype.map() to map the values of an array to a function or property name.Use Array.prototype.reduce() to create an object, where the keys are produced from the mapped results.\n12345678910111213141516171819202122/**** @param &#123;[]&#125; arr* @param &#123;&#125; fn* @returns &#123;&#125;* fn 可以是一个函数，也可以是一个对象所拥有的属性*/const groupBy = (arr, fn) =&gt; &#123;    // 先用 map 来提取 fn 结果作为键    return arr        .map(typeof fn === \"function\" ? fn : val =&gt; val[fn])        .reduce((acc, val, i) =&gt; &#123;            // 拓展返回的对象            acc[val] = (acc[val] || []).concat(arr[i]);            return acc;        &#125;, &#123;&#125;);&#125;;let res = groupBy([6.1, 4.2, 6.3], Math.floor); // &#123;4: [4.2], 6: [6.1, 6.3]&#125;console.log(res);res = groupBy(['one', 'two', 'three'], 'length'); // &#123;3: ['one', 'two'], 5: ['three']&#125;console.log(res);\n2019/05/08\n如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC’ 变成 ‘aBc’\n\njavascript-snippets/processingString.js at master · XXXMrG/javascript-snippets · GitHub\n30s-of-code\nbifurcateSplits values into two groups. If an element infilteris truthy, the corresponding element in the collection belongs to the first group; otherwise, it belongs to the second group.UseArray.prototype.reduce()andArray.prototype.push()to add elements to groups, based onfilter.\nExample\n1bifurcate(['beep', 'boop', 'foo', 'bar'], [true, true, false, true]); // [ ['beep', 'boop', 'bar'], ['foo'] ]\nSolution\n12345678910111213141516171819/*Splits values into two groups. If an element infilteris truthy, the corresponding element in the collection belongs to the first group;otherwise, it belongs to the second group.UseArray.prototype.reduce() and Array.prototype.push()to add elements to groups, based onfilter.*//***** @param &#123;[]&#125; data* @param &#123;[]&#125; filters*/const bifurcate = (data, filters) =&gt; &#123;    // 逗号运算符返回最后一个结果哦    return data.reduce((acc, val, i) =&gt; (acc[filters[i] ? 0 : 1].push(val), acc), [[], []])&#125;let res = bifurcate(['beep', 'boop', 'foo', 'bar'], [true, true, false, true]); // [ ['beep', 'boop', 'bar'], ['foo'] ]console.log(res);\n2019/05/07\n如何解决移动端 Retina 屏 1px 像素问题\n\n2019/05/06\n随机生成一个长度为 10 的整数类型的数组，例如[2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如[[2, 3, 4, 5], [10, 11], [20]]。\n\njavascript-snippets/day-05-06.js at master · XXXMrG/javascript-snippets · GitHub\n\n模拟实现一个 Promise.finally\n\n2019/05/05\n解释一下事件委托？\n\n2019/05/04\n解释 HTML5 中 history 和 hash 模式的区别\n\nhash和history两种模式的区别 - 简书\n2019/05/03\n如何在 JavaScript 中实现私有变量？\n\n闭包或者 Symbol\n\n用 JavaScript 实现一个单例模式。\n\nJavascript单例模式概念与实例 - 掘金JS单例模式《JavaScript设计模式与开发实践》阅读笔记 - 掘金\n2019/05/02\n那么我们今天就手写个 axios 吧！\n\n2019/05/01\n那么我们就手写个 Promise 吧！\n\n","plink":"https://xkeith.space/post/arc-21/"},{"title":"手撕 Symbol","date":"2019-05-03T13:58:40.000Z","updated":"2019-05-03T13:59:16.203Z","content":"\n基础概述第六种原始简单数据类型，表示独一无二的值，只能通过 Symbol 函数生成。不能使用 new 关键字，也就是说不能通过构造函数来生成。因为是个原始类型的值，不是对象，也不存在什么原型链等等等。\n12let s = Symbol();typeof s // =&gt; \"symbol\"\n可以在初始的时候接受一个字符串作为参数，实际上没什么应用意义，因为每一个 Symbol 都是不同的，仅用做输出的时候的区分，以及转成字符串不一样。如果你想给 Symbol 传入一个对象作为参数，那么会先调用该对象的 toString() 方法，所以传进去的还是个字符串哦。正常情况下每一次使用 Symbol 生成的都是完全不同的两个变量，当然也有办法避免这种重复。Symbol 不能参与任何运算，仅可以转换成 String 和 Boolean。\n应用用做属性名由于每一个 Symbol 值都是不相等的，意味着 Symbol 可以用做标识符来保证对象里不会出现重名的属性。可以有效防止多个模块的对象构成的时候不小心覆盖或重写某个键。无论是在对象内部使用 Symbol 定义一个键还是在对象外使用这个键，Symbol 都只能通过方括号的方式使用，不能用点运算符，点运算符会把它重新变成一个普通的字符串。\n1234567var mySymbol = Symbol();var a = &#123;    [mySymbol] : \"fuck\"&#125;a[mySymbol] // =&gt; \"fuck\"a.mySymbol // =&gt; undefined\n定义一组不相等的常量Symbol 用做属性值，也就是 value 中的时候，由于其唯一性，可以用于定义一组不会变化的常量，Symbol 可以保证不可能会在其他地方出现相同的值了。\n123456789const COLOR_RED = Symbol();const COLOR_GREEN = Symbol();function getComplement (color) &#123;    switch (color) &#123;        case COLOR_RED : return COLOR_GREEN;        case COLOR_GREEN : return COLOR_RED;    &#125;&#125;\n消除魔术字符串魔术字符串就是代码中重复出现却与代码形成强耦合的部分，不利于程序的修改的维护。我们可以利用 Symbol 的唯一性来代替那些仅用于分支或者判断的魔术字符串。\n123456789var shapeType = &#123;    triangle : Symbol()&#125;;function getArea (shape, options) &#123;    switch (shape) &#123;        case shapeType.triangle : doSomething();    &#125;&#125;\n定义私有变量Symbol 作为属性名，该属性不会出现在 for...in for...of 循环中，也不会被 Object.keys(); Object.getOwnPropertyNames() 返回，但是它也并非私有属性，可以用 Object.getOwnPropertySymbols() 返回一个数组，其中包含所有 Symbol 属性名。一个新的 API Reflect.ownKeys() 可以返回所有类型的键名，包括 Symbol 。\n我们可以利用 Symbol 的遍历隐蔽性，定义一些非私有但又希望只用于内部的方法。\n12345678910111213141516171819202122232425var size = Symbol(\"size\");class Collection &#123;    constructor() &#123;        this[size] = 0;    &#125;    add(item) &#123;        this[this[size]] = item;        this[size]++;    &#125;    static sizeOf(instance) &#123;        return instance[size];    &#125;&#125;var x = new Collection();Collection.sizeOf(x); // =&gt; 0x.add(\"foo\");Collection.sizeOf(x) // =&gt; 1Object.keys(); // =&gt; [\"0\"]Object.getOwnPropertySymbols(x) // =&gt; [Symbol(size)]Object.getOwnPropertyNames(x) // =&gt; [\"0\"]\n复用 Symbol我们并非一定要产生新的 Symbol 值，我们可以通过字符串参数查找并定位一个已经生成的 Symbol 值。Symbol.for() 接受一个字符串参数，搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，如果没有，就以这个参数为名称新建一个 Symbol 值。\n123var s1 = Symbol.for(\"foo\");var s2 = Symbol.for(\"foo\");s1 === s2 // =&gt; true\nSymbol.for() 会为该 Symbol 登记在全局环境中，并且在调用时搜索这个 Symbol 值，但是普通的 Symbol() 只是会每次都产生一个不同的 Symbol 值。Symbol.for 为 Symbol 登记的名字是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值\n内置的 Symbol 数值ES6 中定义了 11 个内置的 Symbol 值，用在语言内部作为属性名，在调用某些内置方法的时候，实际上调用的是内部的一个以 Symbol 为属性名的方法。因此我们也可以通过更改 Symbol 的指向来覆盖原生方法。\n1234567891011Symbol.hasInstance // 指向对象的 instanceof 运算符对应的方法Symbol.isConcatSpreadable // 一个布尔值，表示该对象使用 concat 方法的时候是否会展开Symbol.species // 指向当前对象的构造函数，以为着 new 的时候会被调用，同时定义的时候要使用 get 读取器Symbol.match // 指向 match 的函数Symbol.replace // 指向 replace 的方法Symbol.search // 指向 search 的方法Symbol.split // 指向 split 的方法Symbol.iterator // 指向默认遍历器方法Symbol.toPrimitive // 指向类型转换的时候调用的方法，接受三种字符串参数：“number” \"string\" \"default\"Symbol.toStringTag // 指向 toString()Symbol.unscopables // 指向一个对象，定义了使用 with 的时候那些属性会被 with 环境排除\n手写一个 Symbol当调用 Symbol 的时候，会采用以下步骤：\n\n如果使用 new ，就报错\n如果 description 是 undefined，让 descString 为 undefined\n否则 让 descString 为 ToString(description)\n如果报错，就返回\n返回一个新的唯一的 Symbol 值，它的内部属性 [[Description]] 值为 descString\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071(function() &#123;    var root = this;    var generateName = (function()&#123;        var postfix = 0;        return function(descString)&#123;            postfix++;            return '@@' + descString + '_' + postfix        &#125;    &#125;)()    var SymbolPolyfill = function Symbol(description) &#123;        if (this instanceof SymbolPolyfill) throw new TypeError('Symbol is not a constructor');        var descString = description === undefined ? undefined : String(description)        var symbol = Object.create(&#123;            toString: function() &#123;                return this.__Name__;            &#125;,            valueOf: function() &#123;                return this;            &#125;        &#125;)        Object.defineProperties(symbol, &#123;            '__Description__': &#123;                value: descString,                writable: false,                enumerable: false,                configurable: false            &#125;,            '__Name__': &#123;                value: generateName(descString),                writable: false,                enumerable: false,                configurable: false            &#125;        &#125;);        return symbol;    &#125;    var forMap = &#123;&#125;;    Object.defineProperties(SymbolPolyfill, &#123;        'for': &#123;            value: function(description) &#123;                var descString = description === undefined ? undefined : String(description)                return forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);            &#125;,            writable: true,            enumerable: false,            configurable: true        &#125;,        'keyFor': &#123;            value: function(symbol) &#123;                for (var key in forMap) &#123;                    if (forMap[key] === symbol) return key;                &#125;            &#125;,            writable: true,            enumerable: false,            configurable: true        &#125;    &#125;);    root.SymbolPolyfill = SymbolPolyfill;&#125;)()\nReferenceES6 系列之模拟实现 Symbol 类型 - 掘金\n","plink":"https://xkeith.space/post/arc-22/"},{"title":"详解前端模块化之路","date":"2019-04-30T08:20:37.000Z","updated":"2019-04-30T08:21:30.301Z","content":"\nIIFEImmediately Invoked Function Expression\n在 JavaScript 的块级作用域还没有正式收入规范的时候，JavaScript 只拥有函数作用域，也就意味着只有声明函数才能让变量与全局环境隔离，因此为了让 JavaScript 代码能够拥有“模块化”的特性，开发人员们会采用这种声明立即执行的匿名函数的方法来包裹模块。\n12345(function() &#123;  var main_message = '这是一条内容信息' //main.js  var main_error = '这是一条错误信息' //main.js  console.log('error:', main_error)&#125;)()\n因为是一个匿名的函数，执行完后很快就会被释放，这种机制不会污染全局对象。虽然看起来有些麻烦，但它确实解决了我们将变量分离开来的需求，不是吗？然而在今天，几乎没有人会用这样方式来实现模块化编程。后来又发生了什么呢？\nCommon.js\n“What I’m describing here is not a technical problem. It’s a matter of people getting together and making a decision to step forward and start building up something bigger and cooler together.”\n\n\nCommonJS is a project with the goal to establish conventions on module ecosystem for JavaScript outside of the web browser. The primary reason of its creation was a major lack of commonly accepted form of JavaScript scripts module units which could be reusable in environments different from that provided by a conventional web browser e.g. web server or native desktop applications which run JavaScript scripts.\n\n一句话解释：\nCommon.js 的 require 实际上是把引用的 module 拷贝了一份到当前 module 中。\n123456789101112131415161718function require(/* ... */) &#123;  const module = &#123; exports: &#123;&#125; &#125;;  ((module, exports) =&gt; &#123;    // Module code here. In this example, define a function.    // 模块代码在这里，在这个例子中，我们定义了一个函数    function someFunc() &#123;&#125;    exports = someFunc;    // At this point, exports is no longer a shortcut to module.exports, and    // this module will still export an empty default object.    // 当代码运行到这里时，exports 不再是 module.exports 的引用，并且当前的    // module 仍旧会导出一个空对象(就像上面声明的默认对象那样)    module.exports = someFunc;    // At this point, the module will now export someFunc, instead of the    // default object.    // 当代码运行到这时，当前 module 会导出 someFunc 而不是默认的对象  &#125;)(module, module.exports);  return module.exports;&#125;\n特点目前单独的 Common.js 是依赖于 node 的执行环境的，也就意味着不能直接在浏览器中使用，可以使用 Browserify 来让其在浏览器环境中执行，但是由于其本身对于依赖的复制是同步的，也就意味着在浏览器中可能会引起阻塞，因此我们需要一种可以异步引入依赖的模块化方案。\nAMDRequireJS &amp; AMD（Asynchronous Module Definition）\n 引入其他模块:   require()定义新的模块:    define()\n12345678910111213141516171819202122232425262728// 简单的对象定义define(&#123;    color: \"black\",    size: \"unisize\"&#125;);// 当你需要一些逻辑来做准备工作时可以这样定义：define(function () &#123;    //这里可以做一些准备工作    return &#123;        color: \"black\",        size: \"unisize\"    &#125;&#125;);// 依赖于某些模块来定义属于你自己的模块define([\"./cart\", \"./inventory\"], function(cart, inventory) &#123;        //通过返回一个对象来定义你自己的模块        return &#123;            color: \"blue\",            size: \"large\",            addToCart: function() &#123;                inventory.decrement(this);                cart.add(this);            &#125;        &#125;    &#125;);\n特点\n以函数的形式返回模块的值，尤其是构造函数，可以更好的实现API 设计，Node 中通过 module.exports 来支持这个，但使用 “return function (){}” 会更清晰。这意味着，我们不必通过处理 “module” 来实现 “module.exports”，它是一个更清晰的代码表达式。\n动态代码加载（在AMD系统中通过require（[]，function（）{}）来完成）是一项基本要求。CJS谈到了， 有一些建议，但没有完全囊括它。Node 不支持这种需求，而是依赖于require（’’）的同步行为，这对于 Web 环境来说是不方便的。\nLoader 插件非常有用，在基于回调的编程中，这有助于避免使用常见的嵌套大括号缩进。\n选择性地将一个模块映射到从另一个位置加载，很方便的地提供了用于测试的模拟对象。\n每个模块最多只能有一个 IO 操作，而且应该是简洁的。Web 浏览器不能容忍从多个 IO 中来查找模块。这与现在 Node 中的多路径查找相对，并且避免使用 package.json 的 “main” 属性。而只使用模块名称，基于项目位置来简单的映射到一个位置的模块名称，不需要详细配置的合理默认规则，但允许在必要时进行简单配置。\n最好的是，如果有一个 “opt-in” 可以用来调用，以便旧的 JS 代码可以加入到新系统。\n\n通过上面的语法说明，我们会发现一个很明显的问题，在使用 RequireJS 声明一个模块时，必须指定所有的依赖项 ，这些依赖项会被当做形参传到 factory 中，对于依赖的模块会提前执行（在 RequireJS 2.0 也可以选择延迟执行），这被称为：依赖前置。这会带来什么问题呢？加大了开发过程中的难度，无论是阅读之前的代码还是编写新的内容，也会出现这样的情况：引入的另一个模块中的内容是条件性执行的。\nCMD12345678910111213141516171819202122232425262728// AMD 的一个例子，当然这是一种极端的情况define([\"header\", \"main\", \"footer\"], function(header, main, footer) &#123;     if (xxx) &#123;      header.setHeader('new-title')    &#125;    if (xxx) &#123;      main.setMain('new-content')    &#125;    if (xxx) &#123;      footer.setFooter('new-footer')    &#125;&#125;); // 与之对应的 CMD 的写法define(function(require, exports, module) &#123;    if (xxx) &#123;      var header = require('./header')      header.setHeader('new-title')    &#125;    if (xxx) &#123;      var main = require('./main')      main.setMain('new-content')    &#125;    if (xxx) &#123;      var footer = require('./footer')      footer.setFooter('new-footer')    &#125;&#125;);\n我们可以很清楚的看到，CMD 规范中，只有当我们用到了某个外部模块的时候，它才会去引入，这回答了我们上一小节中遗留的问题，这也是它与 AMD 规范最大的不同点：CMD推崇依赖就近 + 延迟执行\n我们能够看到，按照 CMD 规范的依赖就近的规则定义一个模块，会导致模块的加载逻辑偏重，有时你并不知道当前模块具体依赖了哪些模块或者说这样的依赖关系并不直观。而且对于 AMD 和 CMD 来说，都只是适用于浏览器端的规范，而 Node.js module 仅仅适用于服务端，都有各自的局限性。\nES6 Module\n“The goal for ECMAScript 6 modules was to create a format that both users of CommonJS and of AMD are happy with”\n\nES Module 会对静态代码分析，即在代码编译时进行模块的加载，在运行时之前就已经确定了依赖关系（可解决循环引用的问题）；ES Module 关键字：import export 以及独有的 default 关键字，确定默认的导出值；ES Module 中导出的值是一个 只读的值的引用，无论基础类型和复杂类型，而在 CommonJS 中 require 的是值的拷贝，其中复杂类型是值的浅拷贝；\n12345678910111213// export/index.jsconst a = \"123\";const fn = () =&gt; window.location.href;export &#123; fn &#125;;// show/index.jsconst ex = require(\"./export/index\");import x from \"./export/index\";import &#123; fn &#125; from \"./export/index\";console.log(ex, \"export1\"); // &#123;fn: ƒ, __esModule: true&#125; \"export1\"console.log(x, \"export-x\"); // undefined \"export-x\"console.log(fn, \"export-fn\"); // function() &#123; return window.location.href; &#125; \"export-x\"\n1234567891011121314// export/index1.jsconst a = \"123\";const fn = () =&gt; window.location.href;export default fn;// show/index1.jsconst ex1 = require(\"./export/index1\");import x from \"./export/index1\";console.log(ex1, \"export1\"); // &#123;default: ƒ, __esModule: true&#125; \"export1\"console.log(x, \"export2\"); // ƒ fn() &#123;return window.location.href;&#125; \"export2\"\nReference深入了解“前端模块化”发展体系Javascript 模块化管理的来世今生 - 掘金Javascript 模块化指北 - 掘金\n","plink":"https://xkeith.space/post/arc-20/"},{"title":"每天（不知道有几）道前端面试题（四月篇）","date":"2019-04-30T01:44:56.000Z","updated":"2019-04-30T02:44:07.379Z","content":"\n题库主要来自于木易阳的 Github 整理和个人平时面试经验。题库收集原则上仅供笔者个人学习整理所用，一切版权都归 Reference 及相应公司所有。\n\n2019/04/30\n简述如何解决移动端网页的像素单位问题？\n\n2019/04/29\na.b.c.d 和 a[‘b’][‘c’][‘d’]，哪个性能更高？\n\n第 19 题：（开放题）a.b.c.d和a’b’’c’’d’，哪个性能更高 · Issue #19 · airuikun/Weekly-FE-Interview · GitHub\n\nMD5, MD5 + salt 加密原理和实现\n\n【密码学】轻松理解“加盐”的原理与java实现 - David的博客 - CSDN博客\n2019/04/28\nelement upload 组件跨域问题？\n\nvue el-upload上传控件一直报跨域问题 post请求变成get请求 - m0_37735354的博客 - CSDN博客\n\n解释一下 call apply bind 的区别，性能呢？\n\n「干货」细说 call、apply 以及 bind 的区别和用法 - 掘金\n2019/04/27\nvue router 的原理，前端路由和后端路由的区别？\n\nVue.js——vue-router 60分钟快速入门 - keepfool - 博客园以vue为例解释：前端路由与后端路由 - Daioo 随笔 - CSDN博客前端路由和后端路由的对比及优劣 - liangcha007的专栏 - CSDN博客\n\n求求你快把 BFC 看完吧！\n\n学习 BFC (Block Formatting Context) - 掘金notebook/README.md at master · zuopf769/notebook · GitHub\n2019/04/26\n设计实现无缝轮播组件\n\n第 63 题：如何设计实现无缝轮播 · Issue #108 · Advanced-Frontend/Daily-Interview-Question · GitHub\n\nbase64 加密解密的原理？\n\n廖雪峰\n【密码学】轻松理解“加盐”的原理与java实现 - David的博客 - CSDN博客\n2019/04/25\n发布订阅和观察者模式的区别？\n\n观察者模式和发布订阅模式的区别 - 简书\n2019/04/24新浪微博视频技术团队面试题\n\nHTTP 1.0 / HTTP 1.1 / HTTP 2.0 的主要几个区别？\n\nHTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：1. 缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n2. 带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n3. 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\n4. Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。\n5. 长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\nHTTP2.0和HTTP1.X相比的新特性\n\n新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\n\n多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。\n\nheader压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。\n\n服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。\n\n\n\n行内元素的padding和margin是否无效？\n\n\nWhile padding can be applied to all sides of an inline element, only left and right padding will have an effect on surrounding content. In the example below, 50px of padding has been applied to all sides of theelement. As you can see, it has an affect on the content on each side, but not on content above or below\n\n\n垂直居中一个元素，注意分行内元素和块级元素两种情况讨论。\nGit 操作查看并处理冲突的命令？\n如何判断一个数组是数组而不是对象？\n\n行内元素的padding和margin是否无效 - 简书HTTP1.0、HTTP1.1 和 HTTP2.0 的区别 - _浪潮之巅.☆ - 博客园HTTP1.0 HTTP 1.1 HTTP 2.0主要区别 - 简书\n2019/04/23阿里巴巴 2019 春季实习生招聘面试题\n\nvirtual DOM 与传统 DOM 操作相比的优点\nHTTPS 握手和加密过程\n回流是否会发生在 JavaScript 主线程执行过程中。(强制队列刷新）\n\n深度理解 Virtual DOM - 吴佰清 - 博客园【开发必看】你真的了解回流和重绘吗？ - 腾讯云+社区 - 博客园\n\nSSL 证书是自签发或者是不受信任的第三方签发的有什么后果？\n\n用于非对称加密的公钥无法验证其实际来源，可能被中间人替换为自己的密钥，这样一来客户端对密钥的加密就会被中间人用自己的私钥解开，从而获取到密钥。\n\nHTTPS 非对称加密过程？\n\n\n服务器把自己的公钥登录至数字证书认证机构\n数字证书认证机构用自己的私钥向服务器的公开密码署数字签名并颁发公钥证书\n客户端拿到服务器的公钥和证书，使用数字认证证书机构的公钥验证数字签名是否真实\n使用认证成功的公钥对报文加密后发送\n服务器用自己的私钥解密\n\n2019/04/22\n给定两个数组，写一个方法来计算它们的交集。例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]。\n\n1234567891011121314151617181920212223242526272829// hash 表，思路类似寻找数组中出现次数最多的元素function inter (nums1, nums2) &#123;    const map = &#123;&#125;;    const res = [];    for (let n of nums1) &#123;        map[n] ? map[n]++ : map[n] = 1;    &#125;    for (let n of nums2) &#123;        if (map[n] &gt; 0) &#123;            res.push(n);            map[n]--;        &#125;    &#125;    return res;&#125;console.log(inter([1,2,2,1], [1,2]));// 操作原数组方法，避免了相同元素的重复function union (nums1, nums2) &#123;    return nums1.filter(item =&gt; &#123;        let idx = nums2.indexOf(item);        if (idx !== -1) &#123;            nums2.splice(idx, 1);            return item;        &#125;    &#125;)&#125;console.log(union([1, 2, 2, 1], [2,2]));\n2019/04/21\ngit merge 和 git rebase 的区别？\n\ngit rebase vs git merge详解 - 世有因果知因求果 - 博客园\n廖雪峰\n2019/04/20\n进程，线程，协程的区别？\n\n\n对操作系统而言，线程是最小的执行单元，进程是最小的资源管理单元。\n\n协程不是被操作系统内核所管理，而是完全由程序控制，在用户态执行。避免了类似线程上下文切换的资源消耗\n2019/04/19\n箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？\n\n箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。4、不可以使用 new 命令，因为：\n\n没有自己的 this，无法调用 call，apply。【\n没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 proto\n\n12345678910111213141516function newFunc(father, ...rest) &#123; // 新建一个对象  var result = &#123;&#125;;// 原型绑定为构造函数的原型  result.__proto__ = father.prototype;// 绑定 this 和参数  var result2 = father.apply(result, rest);// 根据返回值返回结果  if (    (typeof result2 === 'object' || typeof result2 === 'function') &amp;&amp;    result2 !== null  ) &#123;    return result2;  &#125;  return result;&#125;\n2019/04/18常见六大 Web 安全攻防解析cherry-blog\n2019/04/17\n要求设计 LazyMan 类，实现以下功能。\n\n123456789101112131415161718192021LazyMan('Tony');// Hi I am TonyLazyMan('Tony').sleep(10).eat('lunch');// Hi I am Tony// 等待了10秒...// I am eating lunchLazyMan('Tony').eat('lunch').sleep(10).eat('dinner');// Hi I am Tony// I am eating lunch// 等待了10秒...// I am eating dinerLazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');// Hi I am Tony// 等待了5秒...// I am eating lunch// I am eating dinner// 等待了10秒...// I am eating junk food\nSolution:javascript-snippets/lazyMan.js at master · XXXMrG/javascript-snippets · GitHub\n\nvisibility: hidden 和 display: none 的区别\n\nvisibility: hidden\nDOM 树中会渲染，只是不显示，控件依然占据着空间，因此在重新显示的时候不会触发回流，只会触发重绘。\ndisplay: none\nDOM 树中都不会渲染，因此是完全从页面中消失，所以重新显示的时候会触发回流，反复触发会影响性能。\nopacity: 0\n设置元素的不透明度为 0 ，控件依旧占据空间，常于 CSS 3 的 transition 搭配使用。\nv-show\n肯定会编译，并且是通过控制 css 来控制显隐，适合多次操作的情况，性能会好一点。\nv-if\n初始值是 false 就不编译，是通过操作 DOM 来控制显隐，每次都会销毁/重建，性能较差。\n2019/04/16\n某公司 1 到 12 月份的销售额存在一个对象里面，如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。\n\n核心思路就是将对象转换为数组，然后在空的地方填充 null 。或者是新建一个长度为 12 的数组，根据原对象 index 填充 value 或者 null。\n1234567891011121314151617181920let obj = &#123;1:222, 2:123, 5:888&#125;obj.length = 12;// slice 可以将一个类数组转换为一个数组，还可以采用 bind() 实现let _obj = [].slice.call(obj);console.log(_obj);a = [1,2,3];console.time();let data = &#123; 1: 222, 2: 123, 5: 888 &#125;;let arr = Array.from(&#123; length: 12 &#125;).map((_, i) =&gt; data[i + 1] || null);console.log(arr);console.timeEnd();console.time();let obj = &#123; 1: 222, 2: 123, 5: 888 &#125;;let res = Array.from(&#123; length: 12 &#125;).fill(null);Object.keys(obj).forEach(it =&gt; (res[it - 1] = obj[it]));console.log(res);console.timeEnd();\nArray.prototype.slice() - JavaScript | MDN\n\nJavaScript 中的七个全局函数\n\n\n2019/04/15\n冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*** 冒泡排序及优化方案*/// 生成从 l 到 r 的数量为 n 的随机数组function randomArr(n, l ,r) &#123;    let arr = [];    for (let i = 0; i &lt; n; i++) &#123;        let _random = Math.round(l + Math.random() * (r - l));        arr.push(_random);    &#125;    return arr;&#125;function bubbleSort(arr) &#123;    let len = arr.length;    let sorted = true;    for (let i = len; i &gt;= 2; i--) &#123;        for (let j = 0; j &lt; i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];                sorted = false;            &#125;        &#125;        if (sorted) break;    &#125;    return arr;&#125;// 改进冒泡排序function bubbleSort1(arr) &#123;    let i = arr.length - 1;    // 使用 i 来标记已经有序的子数组，可以避免无意义的循环    while (i &gt; 0) &#123;        let pos = 0;        for (let j = 0; j &lt; i; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                pos = j;                const temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            &#125;        &#125;        i = pos;    &#125;    console.log(arr);&#125;function bubbleSort2(arr) &#123;    let low = 0;    let high = arr.length - 1;    let temp, j;    // 二分冒泡    while (low &lt; high) &#123;        // 正排找最大        for (j = low; j &lt; high; ++j) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;            &#125;        &#125;        --high;        // 反排找最小        for (j = high; j &gt; low; --j) &#123;            if (arr[j] &lt; arr[j - 1]) &#123;                temp = arr[j];                arr[j] = arr[j - 1];                arr[j - 1] = temp;            &#125;        &#125;        ++low;    &#125;    console.log(arr);&#125;bubbleSort2(randomArr(10, 0, 100));\n\n2019/04/14\n介绍一下 CSS 的盒模型吧\n\n\ninline 和 inline-block 有什么区别？\n\n\nrelative、fixed、absolute 和 static 四种定位有什么区别？\n\n2019/04/13\n什么是函数式编程\n\n函数式编程是一种编程范式，他使用纯函数来构建声明方式以避免状态的共享、数据的易变及一些副作用。函数式编程的核心是：同一个函数中只要输入相同，其返回值就必然相等，且不会产生任何副作用。 大多数程序员认为这是软件开发的最佳方法，因为这可以减少 bug 并增加易读性。\n\n与使用命令式或面向对象编程的代码相比，函数式编程的代码更加简洁、清晰、可预测及易于测试。\nString.prototype.toUpperCase、Array.prototype.map、Function.prototype.bind 都是 JavaScript 中纯函数的例子，其非纯函数的例子有：Date.now、Math.random 等\nJavaScript 是多范式编程语言（面向对象编程和函数式编程并存）\n函数式编程的应用\n高阶函数是一个函数以函数为参数，或以函数为返回值，或者既以函数为参数又以函数为返回值。\n偏函数是通过指定部分参数来产生一个新定制的函数，如：\n\n123456const isType = function (type) &#123;      return function (obj) &#123;        return toString.call(obj) == '[object' + type + ']';      &#125;;&#125;; const isString = isType('string');\n\n柯里化是将一个多参数函数转换成多个单参数函数，如：\n\n1234567891011121314151617181920212223242526272829303132// 柯里化 bind()const myBind = function(o /*, args */) &#123;    var self = this,        boundArgs = arguments;    return function() &#123;        let args = [],            i;        // 保存 bind 时的参数列表, 柯里化参数绑定        for (i = 1; i &lt; boundArgs.length; i++) &#123;            args.push(boundArgs[i]);        &#125;       // 保存返回值调用时的参数列表        for (i = 0; i &lt; arguments.length; i++) &#123;            args.push(arguments[i]);        &#125;        // 将 self 作为 o 的方法来调用，传入实参        return self.apply(o, args);    &#125;;&#125;;function f() &#123;    let res = 0;    for(let i = 0; i &lt; arguments.length; i++)&#123;        res += arguments[i];    &#125;    return res + this.x;&#125;var o = &#123; x: 1 &#125;;f.myBind = myBind;var g = f.myBind(o,1,2,3)(4,5,6);console.log(g);//=&gt; 1+1+2+3+4+5+6\n什么是函数式编程？ - 黑客派\n2019/04/12\n输出以下代码的执行结果并解释为什么\n\n123456var a = &#123;n: 1&#125;;var b = a;a.x = a = &#123;n: 2&#125;;console.log(a.x) \t// =&gt; undefinedconsole.log(b.x)        // =&gt; &#123;n:2&#125;\n\n优先级。.的优先级高于=，所以先执行a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的b.x也变化了，因为指向的是同一个对象。\n赋值操作是从右到左，所以先执行a = {n: 2}，a的引用就被改变了，然后这个返回值又赋值给了a.x，需要注意的是这时候a.x是第一步中的{n: 1, x: undefined}那个对象，其实就是b.x，相当于b.x = {n: 2}\n\n2019/04/11\n怎么让一个 div 水平垂直居中\n\n第 52 题：怎么让一个 div 水平垂直居中 · Issue #92 · Advanced-Frontend/Daily-Interview-Question · GitHub\n\n解释一下原型链和闭包\n\n原型和原型链\n【进阶5-1期】重新认识构造函数、原型和原型链 - 掘金\n闭包如何拿下前端面试（函数和上下文闭包） | 旧港\n2019/04/10\nVue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？  \n\nObject.defineProperty  无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应，为了解决这个问题，经过 vue 内部处理后可以使用以下几种方法来监听数组。\n1234567push()pop()shift()unshift()splice()sort()reverse()\n由于只针对了以上八种方法进行了hack处理,所以其他数组的属性也是检测不到的，还是具有一定的局限性。\nObject.defineProperty  只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历。vue 2.x 里，是通过递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历，显然如果能够劫持一个完整的对象才是更好的选择。\nProxy 有以下两个优点：\n\n可以劫持整个对象，并返回一个新对象。\n有 13 种劫持操作。\n\n面试官: 实现双向绑定Proxy比defineproperty优劣如何? - 掘金Vue3.0 尝鲜，Object.defineProperty VS Proxy - 奇舞周刊 | 十条vue3.0尝鲜 — 摒弃Object.defineProperty，基于 Proxy 的观… - 简书\n\n解释一下 BOM   \n\nBrowser Object Model浏览器对象模型，提供给开发人员独立于内容而与浏览器进行交互的对象。\n\n主要管理窗口和窗口之间的通讯，核心对象是 window\n在 HTML 5 出现之前，基本没有相关的标准，H5 将很多功能正式写入规范。\n从根本上讲，BOM 只处理浏览器窗口和框架，但人们也习惯上把所有针对浏览器的 JavaScript 拓展算作 BOM 的一部分。\n\n主要常见功能：\n\n弹出新浏览器窗口\n移动，缩放，关闭浏览器窗口\n提供浏览器详细信息的 navigator 对象\n提供浏览器所加载页面的详细信息的 location 对象\n提供用户显示器分辨率详细信息的 screen 对象\n对 cookie 的支持\nXHR 也算\n\njavascript中BOM部分基础知识总结 - cnjs - 博客园JavaScript 浏览器对象实例 | 菜鸟教程\n\ntypeof 和 instanceof 的区别？  \n\ntypeof操作符返回一个字符串，表示未经计算的操作数的类型。\ntypeof - JavaScript | MDN\ninstanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置\ninstanceof - JavaScript | MDN\n2019/04/09\n实现 (5).add(3).minus(2) 功能。例： 5 + 3 - 2，结果为 6\n\n\n2019/04/08为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？\n为什么前端监控要用GIF打点\n\n能够完成整个 HTTP 请求+响应（尽管不需要响应内容）\n触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据\n跨域友好\n执行过程无阻塞\n相比 XMLHttpRequest 对象发送 GET 请求，性能上更好\nGIF的最低合法体积最小（最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节）\n\n2019/04/0712345678console.log(([])?true:false);console.log(([]==false?true:false));console.log((&#123;&#125;==false)?true:false)输出结果 truetruefalse\n“==”运算符（两个操作数的类型不相同时）\n\n如果一个值是null，另一个值是undefined，则它们相等\n如果一个值是数字，另一个值是字符串，先将字符串转换为数字，然后使用转换后的值进行比较。\n如果其中一个值是true，则将其转换为1再进行比较。如果其中的一个值是false，则将其转换为0再进行比较。\n如果一个值是对象，另一个值是数字或字符串，则将对象转换为原始值，再进行比较。\n\n对象到数字的转换\n\n如果对象具有valueOf()方法，后者返回一个原始值，则JavaScript将这个原始值转换为数字（如果需要的话）并返回一个数字。\n否则，如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回。（对象的toString()方法返回一个字符串直接量（作者所说的原始值），JavaScript将这个字符串转换为数字类型，并返回这个数字）。\n否则，JavaScript抛出一个类型错误异常。\n\n空数组转换为数字0\n\n数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值，因此，数组到数学的转换则调用toString()方法。空数组转换为空字符串，空字符串转换为数字0.\n\n2019/04/06 dirname 和 filename 和 process.cwd() 三者的区别\n三者功能差不多，前两个是 node 里头的全局变量，最后一个方法用来返回当前 node.js 进程当前工作的目录。\n__dirname 和 process.cwd() 用于返回当前文件所在的目录名，区别在于 node 进程工作的目录并不一定是该文件的所在目录，比如在一个使用 webpack 打包了的完整的页面架构中，对应的 cwd 是该项目根目录的路径，并非当前模块文件的完整路径。\n__filename 用来获取当前模块文件的带有完整的绝对路径的文件名。\n2019/04/05\n题目来自腾讯 2019 实习前端笔试题  \n\n预防 CSRF 的几种方式？\n\n请求中带上 token\nheader 中带上 token\n验证 HTTP Referer 字段\n验证码\n重复验证密码\n\nCSRF攻击与防御（写得非常好） - stpeace的专栏 - CSDN博客\nCSP URL 跳转\nContent Security Policy 入门教程 - 阮一峰的网络日志\nwebpack4 配置文件中 filename 的配置\n入门 Webpack，看这篇就够了 - 前端学习笔记 - SegmentFault 思否\n2019/04/04call 和 apply 的区别是什么？哪个性能更好一些？\n两个函数的作用是一样的，都是调用函数执行的一种方式，区别在于传入参数的不同。\n\n第一个参数都是，指定函数体内 this  的指向。\n从第二个参数开始不同，apply 是传入带下标的集合，数组或者类数组，apply 把它传给函数作为参数，call 从第二个开始传入的参数是不固定的，都会传给函数作为参数。\ncall 要比 apply 的性能好，因为 call 传入的参数直接被函数使用，apply 还需要从数组中提取。\n\n前端两种主流跨域方案：JSONP 与 CORS。请问使用两种方案在 a.com 向 b.com 发起跨域请求时，b.com 的服务端能否解析到跨域请求携带的 cookie。\n移动端前端开发与PC端比有哪些不同？\n2019/04/03双向绑定和 Vuex 是否冲突？\n在严格模式下使用确实会出现问题。我们可以参考官方对于这个问题给出的解释和解决方案。表单处理 | Vuex\n2019/04/02输出以下的代码的执行结果并解释为什么？\n12345678910var obj = &#123;    '2': 3,    '3': 4,    'length': 2,    'splice': Array.prototype.splice,    'push': Array.prototype.push&#125;obj.push(1)obj.push(2)console.log(obj)\n输出结果：[,,1,2]    length = 4。\n本题主要考查的是 JavaScript 中类数组（伪数组）。在任何对象中添加 length 属性和 splice 方法后该对象都会被 JavaScript 视为一个数组，但实际上他并不完全具备数组的特性同时两次 push 操作之所以没有在数组的前两个位置插入数据的是因为 push 操作的逻辑是通过判断当前对象的 length 属性来插入的，他会在当前 length 的后一个位置插入数据，同时使得 length + 1。\nReferenceGitHub - Advanced-Frontend/Daily-Interview-Question: 工作日每天一道前端大厂面试题，祝大家天天进步，一年后会看到不一样的自己。\nGitHub - noneven/__: 想到什么写什么\n","plink":"https://xkeith.space/post/arc-13/"},{"title":"手撕 BFC","date":"2019-04-29T13:53:18.000Z","updated":"2019-04-29T13:56:47.858Z","content":"\n\nBFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n\n概念块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n创建下列方式会创建块格式化上下文：\n\n根元素或包含根元素的元素\n浮动元素（元素的 float 不是none）\n绝对定位元素（元素的 position 为absolute或fixed）\n行内块元素（元素的 display 为inline-block）\n表格单元格（元素的 display 为table-cell，HTML表格单元格默认为该值）\n表格标题（元素的 display 为table-caption，HTML表格标题默认为该值）\n匿名表格单元格元素（元素的 display 为table、table-row、table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或inline-table）\noverflow 值不为visible的块元素\ndisplay 值为 flow-root 的元素（⚠️ 这样的 BFC 是没有任何副作用的，但要考虑使用时候的兼容性和实际应用场景）\ncontain 值为layout、content或strict的元素\n弹性元素（ display 为flex或inline-flex元素的直接子元素）\n网格元素（ display 为grid或inline-grid元素的直接子元素）\n多列容器（元素的 column-count 或 column-width 不为auto，包括column-count为1）\ncolumn-span为all的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（ 标准变更 ， Chromebug ）。块格式化上下文包含创建它的元素内部的所有内容.块格式化上下文对浮动定位（参见 float ）与清除浮动（参见 clear ）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（ Margin collapsing ）也只会发生在属于同一BFC的块级元素之间。\n\n约束规则\n内部的Box会在垂直方向上一个接一个的放置\n垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）\n每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）\nBFC的区域不会与float的元素区域重叠\n计算BFC的高度时，浮动子元素也参与计算\nBFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然\n\n看到以上的几条约束，想想我们学习css时的几条规则\n\nBlock元素会扩展到与父元素同宽，所以block元素会垂直排列\n垂直方向上的两个相邻DIV的margin会重叠，而水平方向不会(此规则并不完全正确)\n浮动元素会尽量接近往左上方（或右上方）\n为父元素设置overflow：hidden或浮动父元素，则会包含浮动元素\n\n主要应用清除浮动根据 BFC 规则： 计算BFC的高度时，浮动元素也参与计算因此我们可以通过生成 BFC 来处理内部元素产生浮动后出现的原模型高度塌陷问题。\n12345678910111213141516171819&lt;style&gt;    .par &#123;        border: 5px solid #fcc;        width: 300px;    &#125;     .child &#123;        border: 5px solid #f66;        width:100px;        height: 100px;        float: left;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=\"par\"&gt;        &lt;div class=\"child\"&gt;&lt;/div&gt;        &lt;div class=\"child\"&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;\n\n为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。\n123.par &#123;    overflow: hidden;&#125;\n\n防止 margin 塌陷单个文档流的 margin 塌陷在普通的文档流盒模型中，两个相邻的块级元素的 margin 会产生塌陷，实际上的外边距的大小是等于两者的 margin 中的最大值的，两个盒之间会产生范围覆盖，也就是 margin 塌陷。\n1234567891011121314&lt;style&gt;    p &#123;        color: #f55;        background: #fcc;        width: 200px;        line-height: 100px;        text-align:center;        margin: 100px;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;p&gt;Haha&lt;/p&gt;    &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt;\n\n根据 BFC 规则：Box垂直方向的距离由margin决定。属于同一个BFC(上例中是body根元素的BFC)的两个相邻Box的margin会发生重叠我们可以通过生成 BFC 来解决 margin 塌陷。\n12345678910111213141516171819&lt;style&gt;    .wrap &#123;        overflow: hidden;// 新的BFC    &#125;    p &#123;        color: #f55;        background: #fcc;        width: 200px;        line-height: 100px;        text-align:center;        margin: 100px;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;p&gt;Haha&lt;/p&gt;    &lt;div class=\"wrap\"&gt;        &lt;p&gt;Hehe&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;\n\n嵌套元素的 margin 重叠12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;   &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;  &lt;!--The viewport meta tag is used to improve the presentation and behavior of the samples     on iOS devices--&gt;  &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1,user-scalable=no\"/&gt;  &lt;title&gt;&lt;/title&gt;  &lt;style&gt;     html, body &#123; height: 100%; width: 100%; margin: 0; padding: 0; &#125;    #map&#123;      padding:0;    &#125;    .first&#123;      margin:20px;      background:lightgreen;      width:100px;      height:100px;    &#125;    ul&#123;      /*display:inline-block;*/      margin:10px;      background:lightblue;    &#125;    li&#123;      margin:25px;    &#125;  &lt;/style&gt;     &lt;/head&gt; &lt;body class=\"claro\"&gt;   &lt;div class=\"first\"&gt;&lt;/div&gt;  &lt;ul&gt;    &lt;li&gt;1&lt;/li&gt;    &lt;li&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;  &lt;/ul&gt;&lt;/body&gt; &lt;/html&gt;\n此时div与ul之间的垂直距离，取div、ul、li三者之间的最大外边距。\n\n要阻止嵌套元素的margin重叠，只需让ul生成BFC即可（将上例中的注释去掉），这样div、ul、li之间便不会发生重叠现象。\n\n而li位于同一BFC内所以仍然存在重叠现象。\n\n给li设置line-block重新生成一个bfc就不存在重叠现象了。\n\n需要注意的是：如果为ul设置了border或padding，那元素的margin便会被包含在父元素的盒式模型内，不会与外部div重叠。\n\n自适应布局12345678910111213141516171819202122&lt;style&gt;    body &#123;        width: 300px;        position: relative;    &#125;     .aside &#123;        width: 100px;        height: 150px;        float: left;        background: #f66;    &#125;     .main &#123;        height: 200px;        background: #fcc;    &#125;&lt;/style&gt;&lt;body&gt;    &lt;div class=\"aside\"&gt;&lt;/div&gt;    &lt;div class=\"main\"&gt;&lt;/div&gt;&lt;/body&gt;\n\nBFC 的区域不会与浮动区域重叠\n我们利用 BFC 的元素不会与外界元素互相影响布局的特性，可以做出自适应的两栏布局。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;   &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;  &lt;!--The viewport meta tag is used to improve the presentation and behavior of the samples     on iOS devices--&gt;  &lt;meta name=\"viewport\" content=\"initial-scale=1, maximum-scale=1,user-scalable=no\"/&gt;  &lt;title&gt;&lt;/title&gt;  &lt;style&gt;     html, body &#123; height: 100%; width: 100%; margin: 0; padding: 0; &#125;    .left&#123;      background:pink;      float: left;      width:180px;    &#125;    .center&#123;      background:lightyellow;      overflow:hidden;          &#125;    .right&#123;      background: lightblue;      width:180px;      float:right;    &#125;  &lt;/style&gt;     &lt;/head&gt; &lt;body class=\"claro\"&gt;   &lt;div class=\"container\"&gt;    &lt;div class=\"left\"&gt;      &lt;pre&gt;  .left&#123;    background:pink;    float: left;    width:180px;  &#125;      &lt;/pre&gt;    &lt;/div&gt;    &lt;div class=\"right\"&gt;       &lt;pre&gt;  .right&#123;    background:lightblue;    width:180px;    float:right;  &#125;      &lt;/pre&gt;    &lt;/div&gt;    &lt;div class=\"center\"&gt;    &lt;pre&gt;  .center&#123;    background:lightyellow;    overflow:hidden;    height:116px;  &#125;      &lt;/pre&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/html&gt;\n\n副作用有很多创建 BFC 的方法都会产生一些副作用，因为我们只是利用了 BFC 的布局特性，而产生 BFC 的条件往往不仅仅如此，因此可能会让我们的代码令人迷惑，此时最好明显的给出注释或是采用没有副作用的 BFC 创建方式。\n使用overflow来创建一个新的BFC，是因为overflow属性告诉浏览器你想要怎样处理溢出的内容。当你使用这个属性只是为了创建BFC的时候，你可能会发现一些不想要的问题，比如滚动条或者一些剪切的阴影，需要注意。另外，对于后续的开发，可能不是很清楚当时为什么使用overflow。所以你最好添加一些注释来解释为什么这样做。\n一个新的display属性的值，它可以创建无副作用的BFC。在父级块中使用display: flow-root可以创建新的BFC。\nReference块格式化上下文 - Web 开发者指南 | MDN前端精选文摘：BFC 神奇背后的原理 - 梦想天空（山边小溪） - 博客园什么是BFC - 最骚的就是你 - 博客园学习 BFC (Block Formatting Context) - 掘金notebook/README.md at master · zuopf769/notebook · GitHub\n","plink":"https://xkeith.space/post/arc-19/"},{"title":"浅谈博弈论（Nim 游戏）","date":"2019-04-15T12:58:31.000Z","updated":"2019-04-15T13:00:13.219Z","content":"\n\n题目:硬币游戏1,Alice和Bob在玩这样一个游戏。给定k个数字a1,a2,···ak。 一开始，有x枚硬币，Alice和Bob轮流取硬币。每次所取硬币的枚数一定要在a1,a2···，ak当中。Alice先取，取走最后一枚硬币的一方获胜。当双方都采取最有策略时，谁会获胜？假定a1a2···ak中一定有1限制条件：1&lt;=x&lt;=10000 1&lt;=k&lt;=100 1&lt;=ai&lt;=k  \n\n12345678910111213141516171819202122232425/**博弈论和必胜策略 */// num 个硬币，a[i] 表示一种拿取硬币个数的方法，A 先拿// win 数组保存的是 A 是否能必胜function game1(num, a) &#123;    // 相当于 dp 数组    var win = [];    var k = a.length;    // 0 是必败态    win[0] = false;    for(let i = 1; i &lt;= num; i++) &#123;        win[i] = false;        for(let j = 0; j &lt; k; j++) &#123;            // 如果当前状态存在一种情况可以演化为必败态，那么当前状态必胜            if(a[j] &lt;= i &amp;&amp; !win[i-a[j]]) &#123;                win[i] = true;                break;            &#125;        &#125;    &#125;    return win;&#125;let res = game1(9, [1,4]);console.log(res[9]);\n有两个游戏者：A和B。有n颗石子。约定：两人轮流取走石子，每次可取1、2或3颗。A先取，取走最后一颗石子的人获胜。问题：A有没有必胜的策略？分析：这是小学必备奥数题之一，我们可以很容易的知道，当n为0,4,8,12……时，A必定会输，因为不论A取多少，B只要和A共同取走4即可；当n不为0,4,8,12……时，A只需要将n取成4的倍数，这样就变成了B先取，B一定会输，所以A一定会赢。\nReference找出游戏的必胜的策略(博弈论的学习) - 枯叶die - 博客园浅谈算法——博弈论 - Canopus - CSDN博客Nim游戏_百度百科nim游戏详解（易懂） - 转角的守望 - CSDN博客\n","plink":"https://xkeith.space/post/arc-18/"},{"title":"如何拿下前端面试（Promise 和异步编程详解）","date":"2019-04-13T13:37:59.000Z","updated":"2019-04-13T13:39:35.364Z","content":"\n\n在JavaScript中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行。  \n\n浏览器线程浏览器的内核是多线程的，他们在内核控制下相互配合以保持同步，一个浏览器通常由以下常驻线程组成：\n\nGUI 渲染线程\nJavaScript 引擎线程\n浏览器事件触发线程\n定时触发器线程\n异步 HTTP 请求线程\n\n几种常见的异步编程方案\n回调函数\n事件监听\n发布 / 订阅\nPromise\n\nGUI 渲染线程负责渲染浏览器界面 HTML 元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在 Javascript 引擎运行脚本期间, GUI 渲染线程都是处于挂起状态的,也就是说被”冻结”。即 GUI 渲染线程与 JS 引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。\nJavaScript 引擎线程也可以称为 JS 内核，主要负责处理 Javascript 脚本程序，例如 V8 引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。浏览器无论什么时候都只有一个 JS 线程在运行 JS 程序。\n浏览器事件触发线程当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于JS的单线程关系所有这些事件都得排队等待 JS 引擎处理。\n定时触发器线程浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 javaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。\n异步 HTTP 请求线程在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。\n线程工作例子1:异步请求是由线程 JavaScript 执行线程、HTTP 请求线程 和 事件触发线程 共同完成的。JavaScript 执行线程 执行异步请求代码，这时浏览器会开一条新的 HTTP 请求线程 来执行请求，JavaScript 执行线程则继续执行 执行队列 中剩下的其他任务。然后在未来的某一时刻 事件触发线程 监视到之前的发起的 HTTP 请求已完成，它就会把完成事件的回调代码插入到 JavaScript 执行队列尾部 等待 JavaScript 执行线程空闲时来处理。例子2:定时触发（setTimeout 和 setInterval）是由浏览器的 定时器线程 执行的定时计数，然后在定时时间结束时把定时处理函数的执行代码插入到 JavaScript 执行队列的尾端（所以用这两个函数的时候，实际的执行时间是大于或等于指定时间的，不保证能准确定时的）。\n\n\n主线程在执行完当前循环中的所有代码后，就会到任务（消息）队列取出一条消息，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，工作线程就没必要通知主线程，从而也没必要往消息队列放消息。\nsetTimeout(fn, 0) 的作用理解了浏览器异步任务的执行过程我们就会知道，将一个任务设置成零延迟并不意味着立即执行该任务，该任务仍然要被加入异步队列中，等待主线程结束，并且异步队列前面的任务也结束才执行。在某种程度上，我们可以利用setTimeout(fn,0)的特性，修正浏览器的任务顺序。\nPromise描述Promise对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象\n一个Promise有以下几种状态:\n\npending: 初始状态，既不是成功，也不是失败状态。\nfulfilled: 意味着操作成功完成。\nrejected: 意味着操作失败。pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的then方法绑定的处理方法（handlers）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。\n\n\n常见错误在编写 Promise 链时，需要注意以下示例中展示的几个错误：\n1234567// 错误示例，包含 3 个问题doSomething().then(function(result) &#123;  doSomethingElse(result) // 没有返回 Promise 以及没有必要的嵌套 Promise  .then(newResult =&gt; doThirdThing(newResult));&#125;).then(() =&gt; doFourthThing());// 最后是没有使用 catch 终止 Promise 调用链，可能导致没有捕获的异常\n第一个错误是没有正确地将事物相连接。当我们创建新 Promise 但忘记返回它时，会发生这种情况。因此，链条被打破，或者更确切地说，我们有两个独立的链条竞争（同时在执行两个异步而非一个一个的执行）。这意味着doFourthThing()不会等待doSomethingElse()或doThirdThing()完成，并且将与它们并行运行，可能是无意的。单独的链也有单独的错误处理，导致未捕获的错误。第二个错误是不必要地嵌套，实现第一个错误。嵌套还限制了内部错误处理程序的范围，如果是非预期的，可能会导致未捕获的错误。其中一个变体是 promise 构造函数反模式 ，它结合了 Promise 构造函数的多余使用和嵌套。第三个错误是忘记用catch终止链。这导致在大多数浏览器中不能终止的 Promise 链里的 rejection。一个好的经验法则是总是返回或终止 Promise 链，并且一旦你得到一个新的 Promise，返回它。下面是修改后的平面化的代码：\n1234567doSomething().then(function(result) &#123;  return doSomethingElse(result);&#125;).then(newResult =&gt; doThirdThing(newResult)).then(() =&gt; doFourthThing());.catch(error =&gt; console.log(error));\nasync / awaitReference【 js 基础 】 setTimeout(fn, 0) 的作用 - 掘金使用 Promises - JavaScript | MDN面试精选之Promise - 掘金Promise原理讲解 &amp;&amp; 实现一个Promise对象 (遵循Promise/A+规范) - 掘金\n","plink":"https://xkeith.space/post/arc-17/"},{"title":"小谈防抖和节流","date":"2019-04-13T13:33:39.000Z","updated":"2019-04-13T13:35:22.444Z","content":"\n在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会产生大量 DOM 重绘，使浏览器性能下降，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。\n函数防抖函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。\n\n防抖最常见的使用场景就是带有即时搜索功能的文本框了，如果每输入一个字符都要进行一次请求的话会大大拖慢性能，因此在结束输入的一段时间后再发起请求是比较常见的防止页面抖动的方式。\n123456789function debounce(fn, wait) &#123;    var timeout = null;    return function () &#123;        timeout &amp;&amp; clearTimeout(timeout);        timeout = setTimeout(() =&gt; &#123;            fn.call(this, arguments);        &#125;, wait);    &#125;&#125;\n函数节流函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。\n\n节流最常见的使用场景就是资源懒加载的时候要计算滚动条的位置，如果用户反复触发滚动条移动会使得多次触发计算，我们常常使用节流按一定的时间频率获取滚动条位置。或者在用户提交的时候，我们在已知接口大致返回时间的情况下，可以使用节流限制用户的请求频率。事件的重复触发并不会使得函数彻底停止触发，而是让其按照给定的时间触发。\n12345678910111213// 节流函数function throttle(fn, wait) &#123;    let canRun = true;    return function() &#123;        if (!canRun) return;        // 这句话是用来防止多次重复触发的关键        canRun = false;        setTimeout(() =&gt; &#123;            fn.call(this, arguments);            canRun = true;        &#125;, wait);    &#125;&#125;\nReferenceJS的防抖与节流2019 面试准备 - JS 防抖与节流 - 掘金\n","plink":"https://xkeith.space/post/arc-16/"},{"title":"如何拿下前端面试（函数和上下文闭包）","date":"2019-04-11T13:11:00.000Z","updated":"2019-04-11T13:12:31.545Z","content":"\n函数声明\n两种声明方式，不同方式会影响函数的实际声明时间，从而影响函数的可执行时间  \n\n只有通过函数表达式声明的函数才会被提到最前，而且比变量声明提前拥有更高的优先级，会提到最最最前面。\n通过表达式声明的函数，只会发生变量提前，函数定义原地不变。使用构造函数声明的函数也一样！\n会一道题就懂了\n123456789console.log(a)\t                //?a();\t\t\t\t//?var a =3;function a()&#123;   console.log(10);&#125;console.log(a);\t                //?a = 6;a();\t\t\t\t//?\n函数调用函数形式调用\n根据 ECMAScript 3 和非严格的 ECMAScript 5 对函数调用的规定，调用上下文(this) 的值是全局对象，然而，在严格模式下，this 的值是 undefined。  \n\n12// 定义并调用一个函数来确定当前脚本运行时是否为严格模式var strict = (function()&#123;return !this;&#125;)\n作为方法调用\n作为方法调用的函数与普通调用的函数有一个很重要的区别，调用上下文不同，调用方法的对象成为函数执行的上下文，我们可以通过 this 获得这个对象。  \n\n和变量不同，关键字 this 没有作用域的限制，嵌套的函数不会从调用他的函数中继承 this，如果嵌套函数作为方法调用，其this 的值指向调用他的对象。如果嵌套函数作为函数调用，其 this 值不是全局对象就是 undefined （严格模式）\n很多时候我们希望在嵌套函数中的 this 也能指向调用外层函数时候的上下文，所以我们常常把这个 this 值保存在另外一个变量中。\n123456789101112var o = &#123;    m: function() &#123;        var self = this;        console.log(this === o); *// =&gt; true*        f();        function f() &#123;            console.log(this === o); *// =&gt; false*            console.log(self === o); *// =&gt; true*        &#125;    &#125;&#125;\n作为构造函数调用如果函数或者方法调用之前有关键字 new ，他就构成函数调用。构造函数调用和普通的函数调用以及方法调用在实参处理，调用上下文和返回值都不同。\n构造函数调用创建一个新的空对象，这个对象继承自构造函数的 prototype 属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数可以使用 this 关键字来引用这个新创建的对象。\n注意，尽管构造函数看起来像一个方法调用，他依然会使用这个新对象作为调用上下文，也就是说，在表达式 new o.m() 中，调用上下文并不是 o。\n通过他们的 call() 和 apply() 方法调用call 传入的是参数列表，apply 传入的是参数数组。\n函数参数可选形参12345678910*// 可选参数**// 将对象 o 中可枚举的属性名追加到数组 a 中，并返回这个数组 a**// 如果省略 a ，则创建一个新数组并返回这个新数组*function getPropertyNames(o, /* optional */ a) &#123;    a = a || [];    for(var property in o) &#123;        a.push(property);    &#125;    return a;&#125;\n可变长参数123456789*// 可变长参数*function max (/* ... */) &#123;    var max = Number.NEGATIVE_INFINITY;    for (var i = 0; i &lt; arguments.length; i++) &#123;        if (arguments[i] &gt; max) max = arguments[i];    &#125;    return max;&#125;\n闭包作用域链JavaScript 是基于词法作用域的语言。在 JavaScript 的最顶层代码中（也就是不包含在任何函数定义内的代码），作用域链由一个全局对象组成，在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象当定义一个函数时，它实际上保存一个作用域链，当调用这个函数的时候，它创建一个新的对象来存储他的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的链。对于嵌套函数来说，每次调用外部函数时，内部函数又会重新定义一遍，因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别，在每次调用外部函数时，内部函数的代码都是不相同的，而且关联这段代码的作用域链也不相同。\n闭包\n函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中成为闭包。  \n\n从技术的角度讲，所有的 JavaScript 函数都是闭包。他们都是对象，他们都关联到作用域链。函数的执行依赖于变量作用域，这个作用域是函数被定义的时候决定的，而不是函数调用时决定的。当调用函数时闭包所指向的作用域链和定义函数时候的作用域链不是同一个作用域链的时候，事情就变得非常微妙。当一个函数嵌套了一个函数，外部函数将嵌套的函数对象作为返回值返回的时候，闭包的作用就显现出来了\n我们将作用域链描述为一个对象列表，不是绑定的栈。每次调用 JavaScript 函数的时候，都会为之创建一个新的对象用来保存局部变量，把这个对象添加至作用域链中。当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也没有其他引用指向这个绑定对象，他就会被当作垃圾回收掉。如果定义了嵌套的函数，每个嵌套的函数各自对应一个作用域链，并且这个作用域链指向一个变量绑定对象。如果这些嵌套的函数对象在外部函数中保存下来，那么他们也会和所指向的变量绑定对象一样当作垃圾回收。但是如果这个函数定义了嵌套的函数，并将它作为返回值返回或者存储在某处的内存中，这时就会有一个外部引用指向这个嵌套的函数。他就不会被当作垃圾回收，并且他指向的变量绑定对象也不会被当作垃圾回收。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 存取器方法改写function counter(n) &#123;    return &#123;        get count() &#123;            return n++;        &#125;,        set count(m) &#123;            if (m &gt;= n) n = m;            else throw Error(\"count can only be set to a larget value\");        &#125;    &#125;&#125;// 迭代function addPrivateProperty(o, name, predicate) &#123;    var value;    o[\"get\" + name] = function()&#123;return value;&#125;;    o[\"set\" + name] = function(v) &#123;        if(predicate &amp;&amp; !predicate(v)) &#123;            throw Error(`set + $&#123;name&#125; + 错啦 $&#123;v&#125;`);        &#125;        else &#123;            value = v;        &#125;    &#125;&#125;var o = &#123;&#125;;addPrivateProperty(o, \"Name\", (x) =&gt; &#123;return typeof x == \"string\"&#125;);o.setName(\"fuck\");console.log(o.getName());o.setName(o);// 防止闭包中的变量的不恰当共享function constfunc(v) &#123;return () =&gt; &#123;return v&#125;&#125;;var funcs = [];for (var i = 0; i &lt; 10; i++) &#123;    funcs[i] = constfunc(i);&#125;console.log(funcs[5]());// 尽量避免在循环中使用闭包，可能会产生闭包中变量的错误共享*// 下面这个例子中 10 个闭包共享同一个变量*function constfuncs() &#123;    var funcs = [];    for (var i = 0; i &lt; 10; i++)&#123;        // 最后一个闭包将变量 i 改为10，因此所有的闭包中的变量都会跟着改变.        funcs[i] = function() &#123;return i;&#125;;    &#125;    return funcs;&#125;var funcs = constfuncs();console.log(funcs[5]());\n函数属性，方法，构造函数length函数属性中的 length 代表着函数形参的数量，也就是函数希望得到的参数数量。\nbind() 方法123456789101112131415161718192021222324252627282930313233343536373839// bind()function f(y) &#123;    return this.x + y;&#125;var o = &#123; x: 1 &#125;;var g = f.bind(o);g(2); // =&gt; 3// 手写一个 bind()function bind(f, o) &#123;    if (f.bind) return f.bind(o);    else        return function() &#123;            return f.apply(o, arguments);        &#125;;&#125;// 柯里化 bind()const bind = function(o /*, args */) &#123;    var self = this,        boundArgs = arguments;    return function() &#123;        var args = [],            i;        // 保存 bind 时的参数列表, 柯里化参数绑定        for (i = 1; i &lt; boundArgs.length; i++) &#123;            args.push(boundArgs[i]);        &#125;        // 保存返回值调用时的参数列表        for (i = 0; i &lt; arguments.length; i++) &#123;            args.push(arguments[i]);        &#125;        // 将 self 作为 o 的方法来调用，传入实参        return self.apply(o, args);    &#125;;&#125;;\n函数式编程12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 5. 函数式编程var sum = (x, y) =&gt; &#123;return x + y;&#125;;var square = (x) =&gt; &#123;return x * x;&#125;;var data = [1,1,3,5,5];var mean = data.reduce(sum) / data.length;var deviations = data.map((x) =&gt; &#123;return x - mean&#125;);var stddev = Math.sqrt(deviations.map(square).reduce(sum) / data.length - 1);// 手写一个 mapvar data = [1, 1, 3, 5, 5];var myMap = Array.prototype.map ? (a, f) =&gt; &#123;return a.map(f);&#125; : (a, f) =&gt; &#123;    var results = [];    for (var i = 0, len = a.length; i &lt; len; i++) &#123;        if (i in a) results[i] = f.call(null, a[i], i, a);    &#125;    return results;&#125;// 手写一个 reducevar myReduce = (a, f, initial) =&gt; &#123;    var i = 0, len = a.length, accumulator;    if (arguments.length &gt; 2) accumulator = initial;    else &#123;        if (len == 0) throw TypeError();        while (i &lt; len) &#123;            if (i in a) &#123;                accumulator = a[i++];                break;            &#125;            else i++;        &#125;        // 数组中没有已经定义的元素        if (i == len) throw TypeError();    &#125;    while (i &lt; len) &#123;        if (i in a) &#123;            // 参与运算的两个参数是 accumulator 和 下一个 a[i]            accumulator = f.call(null, accumulator, a[i], i, a);        &#125;        i++;    &#125;    return accumulator;&#125;\nReference【JS点滴】声明提前，变量声明提前，函数声明提前，声明提前的先后顺序 - 听风是风 - 博客园\n","plink":"https://xkeith.space/post/arc-15/"},{"title":"从 URL 到显示网页到底发生了什么（前端满分回答考虑缓存存在无敌终极版本）","date":"2019-04-09T03:14:54.000Z","updated":"2019-04-09T03:17:47.520Z","content":"\n主要流程\n输入 URL 并通过 DNS 解析得到 IP 地址\n通过 ARP 用 IP 地址找到 MAC 地址\n通过 MAC 和 TCP 三次握手与服务器建立连接\n如果使用 HTTPS 发送数据前需要进行 SSL 握手，同时对数据进行 SSL 加密\n使用 HTTP / HTTPS 发送请求报文\n服务器收到请求，并对请求作出相应，返回响应报文（可能会发生重定向哦）\n浏览器收到响应，开始渲染网页\nhtml解析 -&gt; 外部样式、脚本加载 -&gt; 外部样式执行 -&gt; 外部脚本执行 -&gt; html继续解析 -&gt; dom树构建完成 -&gt; 加载图片 -&gt; 页面加载完成\n异步脚本可能还会继续发起请求\n\n地址栏网址缓存输入网址的前几个字母浏览器可能会触发自动补全，此时网页的静态资源也是保存在浏览器缓存中的，此时我们的部分请求并不会发送到服务器，而是直接从缓存中取得，状态码是：\n200 OK (from disk cache)\n检查 HSTS 预加载列表\nHSTS（ HTTP Strict Transport Security ）国际互联网工程组织 IETE 正在推行一种新的 Web 安全协议，作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建连接。  \n\n307 Internal Redirect这个特殊的重定向往往出现在这个时候。一句话来说就是存在于 HSTS 预加载列表的网址要求浏览器只使用 HTTPS 建立连接，他会把你输入的 HTTP URL 重定向到 HTTPS 协议的 URL 。而不支持 HSTS 的网站则不会发生重定向。\nDNS 缓存输入 URL 并回车后，域名解析就开始了，此时最少涉及三个地方的缓存。\n\n浏览器的 DNS 缓存\n操作系统中的 DNS 缓存\nhosts 文件中的缓存，可以手动写入的缓存\n\n域名解析过程\n\n浏览器搜索自己的 DNS 缓存（浏览器维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步；\n搜索操作系统中的 DNS 缓存；如果没有命中，进入下一步；\n搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步；\n操作系统将域名发送至 LDNS （本地区域名服务器），LDNS 查询自己的 DNS 缓存（一般命中率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：\nLDNS向 Root Name Server（根域名服务器，如com、net、im 等的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 im 域的顶级域名服务器的地址；\nLDNS 向 im 域的顶级域名服务器发起请求，返回 juejin.im 域名服务器地址；\nLDNS 向 juejin.im 域名服务器发起请求，得到 juejin.im 的 IP 地址；\nLDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来。\n\nDNS PrefetchDNS 预获取，是前端优化的一部分，一般来说我们优化 DNS 主要是以下两点：\n\n减少 DNS 请求次数\n进行 DNS 预获取\n\n典型的一次 DNS 解析需要耗费 20-120 毫秒，减少DNS解析时间和次数是个很好的优化方式。DNS Prefetching 是让具有此属性的域名不需要用户点击链接就在后台解析，而域名解析和内容载入是串行的网络操作，所以这个方式能减少用户的等待时间，提升用户体验。\n问：浏览器 DNS 缓存的时间一般不会太长，一分钟左右。为什么缓存不设置较长时间呢？答：虽然 DNS 缓存可以提高获取 DNS 的速度，但缓存时间过长也会影响 DNS 在 IP 变更时不能及时解析到最新的 IP。\nARP 缓存\nARP 是一种用以解释地址的协议，根据通信方的 IP 地址就可以反查出对应方的 MAC 地址。  \n\nARP 缓存是个用来储存 IP 地址和 MAC 地址的缓冲区，其本质就是一个 IP 地址与 MAC 地址的对应表，表中每一个条目分别记录了其他主机的 IP 地址和对应的 MAC 地址。当地址解析协议被询问一个已知 IP 地址节点的 MAC 地址时，先在 AR 缓存中查看，若存在，就直接返回与之对应的MAC地址；若不存在，才发送 ARP 请求查询。\nTCP 发送/接收缓冲区建立 TCP 连接这一步也涉及到缓存 —— 用来临时存放双方通信的数据，保证通信数据不会丢包。每个 TCP 连接在内核中都有一个发送缓冲区和接收缓冲区，TCP 的全双工的工作模式以及 TCP 的流量(拥塞)控制便是依赖于这两个独立的 buffer 以及 buffer 的填充状态。\n发送缓冲区内核基本上是按照 MSS（Maximum Segment Size，最大报文段长度） 从缓冲区中取数据发送出去，当缓冲区中数据小于 MSS，则将剩余数据全部发送出去。TCP 的发送缓冲区必须为已发送的数据保留一个副本，直到它被对端确认为止，才能从缓冲区中删掉已确认的数据。\n接收缓冲区接收缓冲区把数据缓存入内核，等待recv()方法读取，recv()方法所做的工作，就是把内核缓冲区中的数据拷贝到应用层用户的buffer里面，拷贝后就删掉已确认的数据。\nHTTP 请求缓存首先说结论，缓存的请求顺序和状态\n\n强缓存和协商缓存同时存在时，如果强缓存还在有效期内，则直接使用缓存（200 OK from dist cache），如果强缓存过期，使用协商缓存（304 Not Modified）。\n强缓存的 expires 和 cache-control 同时存在时，cache-control 会覆盖 expires，无论有没有过期，都无效。\n协商缓存的 Etag 和 Last-Modified 同时存在时，优先比对  Etag，随后才比较  Last-Modified\n\n￼\n强缓存（Cache-Control 和 Expires）\n如果采用强缓存，在缓存有效期内服务器资源发生改变页面数据并不会发生改变，缓存只会在下次过期时更新\n协商缓存（Last-Modified 和 Etag）\nLast-Modified 和 If-Modified-Since\n当客户端再次请求该资源的时候，会在其请求头上附带上 If-Modified-Since 字段（值就是第一次获取请求资源时响应头中返回的 Last-Modified值）。如果修改时间未改变则表明资源未过期，命中缓存，服务器就直接返回 304 状态码，客户端直接使用本地的资源。否则，服务器重新发送响应资源，从而保证资源的有效性。\nEtag 和 If-None-Match\n当客户端再次请求该资源的时候，会在其请求头上附带上 If-None-Match字段（值就是第一次获取请求资源时响应头中返回的Etag 值），其值与服务器端资源文件的验证码进行对比，如果匹配成功直接返回 304 状态码，从浏览器本地缓存取资源文件。如果不匹配，服务器会把新的验证码放在请求头的 Etag 字段中，并且以 200 状态码返回资源。\n相同的资源，在两台服务器产生的Etag是不是相同的，所以对于使用服务器集群来处理请求的网站来说，Etag的匹配概率会大幅降低。所在在这种情况下，使用Etag来处理缓存，反而会有更大的开销。\nReference【前端词典】从输入 URL 到展现涉及哪些缓存环节(非常详细) - 掘金HTTP缓存机制及原理 - 掘金\n","plink":"https://xkeith.space/post/arc-14/"},{"title":"如何拿下前端面试（性能篇）","date":"2019-03-30T15:39:32.000Z","updated":"2019-03-31T09:05:33.892Z","content":"\n基础知识RAILChrome 团队提出了一个以用户为中心的性能模型被称为 RAIL。RAIL 将影响性能的行为划分为四个方面，分别是: Response, Animation, Idle, Load。\n\n响应流畅的网页对于用户的输入操作的反应时间不应超过 100ms。\n动画现如今大多数设备的屏幕刷新频率是60Hz，也就是每秒钟屏幕刷新60次；因此网页动画的运行速度只要达到60FPS，我们就会觉得动画很流畅。换算下来每一帧的时间是 16ms(1 秒 = 1000 毫秒) / 60 帧 = 16.66 毫秒/帧\n但通常浏览器需要花费一些时间将每一帧的内容绘制到屏幕上（包括样式计算、布局、绘制、合成等工作），所以通常我们只有10毫秒来执行JS代码。一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。\n空闲为了更好的性能，我们通常会充分利用浏览器空闲周期做一些低优先级的事情。例如：在空闲周期预请求一些接下来可能会用到的数据或上报分析数据等。\nRAIL规定，空闲周期内运行的任务不得超过50ms，当然不止RAIL规定，W3C性能工作组的Longtasks标准也规定了超过50毫秒的任务属于长任务，那么50ms这个数字是怎么得来的呢？浏览器是单线程的，这意味着同一时间主线程只能处理一个任务，如果一个任务执行时间过长，浏览器则无法执行其他任务，用户会感觉到浏览器被卡死了，因为他的输入得不到任何响应。为了达到100ms内给出响应，将空闲周期执行的任务限制为50ms意味着，即使用户的输入行为发生在空闲任务刚开始执行，浏览器仍有剩余的50ms时间用来响应用户输入，而不会产生用户可察觉的延迟。\n\n加载如果不能在1秒钟内加载网页并让用户看到内容，用户的注意力就会分散。用户会觉得他要做的事情被打断，如果10秒钟还打不开网页，用户会感到失望，会放弃他们想做的事，以后他们或许都不会再回来。\n网页生成的过程\n网页的生成过程，大致可以分成五步。\n\nHTML 代码转化成 DOM。\nCSS 代码转化成 CSSOM (CSS Object Model)。\n结合 DOM 和 CSSOM，生成一颗渲染树。\n生成布局，将渲染树的所有节点进行平面合成。\n将布局绘制在屏幕上。\n\n五步中，一到三步都非常快，耗时的是第四步和第五步。生成布局（flow）和绘制（paint）这两步，合称为渲染（render）。\n\n重排和重绘网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。以下三种情况，会导致网页重新渲染。\n\n修改DOM\n修改样式表\n用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）\n\n重新渲染，就需要重新生成布局和重新绘制。前者叫做”重排”（reflow），后者叫做”重绘”（repaint）。需要注意的是，”重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，”重排”必然导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。\n触发重排的属性：123456781.盒子模型相关属性： width ,height ,padding ,margin ,display ,border-width ,border2.定位属性及浮动： top ,bottom ,left ,right ,position ,float ,clear3.改变节点内部文字结构：text-align, overflow-y ,font-weight ,overflow, font-family, line-height, vertival-align ,white-space,font-size\n触发重绘的属性：123color,border-style,border-radius ,visibility,text-decoration ,background ,background-image ,background-position ,background-repeat,background-size ,outline-color ,outline ,outline-style ,outline-width ,box-shadow\n常见性能漏洞避免重绘重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。\n12div.style.color = 'blue';div.style.marginTop = '30px';\n上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。如果写得不好，就会触发两次重排和重绘。这种情况也被称为 FSL Forced Synchronous Layouts 强制同步布局。\n123div.style.color = 'blue';var margin = parseInt(div.style.marginTop);div.style.marginTop = (margin + 10) + 'px';\n上面代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。\n\noffsetTop/offsetLeft/offsetWidth/offsetHeight\nscrollTop/scrollLeft/scrollWidth/scrollHeight\nclientTop/clientLeft/clientWidth/clientHeight\ngetComputedStyle()\n\n所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。\n123456789// baddiv.style.left = div.offsetLeft + 10 + \"px\";div.style.top = div.offsetTop + 10 + \"px\";// goodvar left = div.offsetLeft;var top  = div.offsetTop;div.style.left = left + 10 + \"px\";div.style.top = top + 10 + \"px\";\n一般的规则是：\n\n样式表越简单，重排和重绘就越快。\n重排和重绘的DOM元素层级越高，成本就越高。\ntable元素的重排和重绘成本，要高于div元素\n\n常用优化方法浏览器优化图片优化图片格式选择：1.jpg图片\n特点是有损压缩、高质量压缩、体积小、加载快、不支持透明，适用于呈现色彩丰富的图片，适合用作背景图、轮播图或Banner图的格式\n2.png图片\n特点是无损压缩、高质量压缩、体积大、支持透明，适用于呈现小的Logo，或者颜色简单且对比强烈的图片或背景图的格式\n3.SVG图片\n特点是体积小，不失真，兼容性好，可压缩性强，可编程，渲染成本高，学习成本高，最适合带有大型渲染区域的应用程序（地图应用）\n4.雪碧图\n将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background- repeat，background-position 的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节。\n5.Base64\n对图片进行Base64编码，会得到一串字符串，浏览器会直接将这串字符串解码为图片，这样就不用发送http请求了，但是这样的缺点是图片会膨胀，体积会增加，所以它的应用条件是：图片尺寸小、无法用雪碧图、图片更新频率低（不需要我们重复编码和修改文件内容，维护成本较低）\n6.webP\n集各种格式的优点于一身，缺点就是兼容性不好，所以应用时需要判断浏览器\n图片懒加载，就是当图片出现在浏览器的可视区域内时，设置图片真正的路径，让图片显示出来。当一个页面中由许多图片时，使用懒加载，可大大提高页面性能。\n具体完成过程为，先给图片一个假的src,不让图片加载，通过监听滚动时间+函数节流，来完成判断元素距离可视区域顶部的高度，要是高度差&gt;=0，那么就将正确的src赋给图片，图片完成加载。\n缓存优化浏览器缓存机制1.MemoryCache，即在内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。\n2.Services Worker Cache，Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，可利用这一点帮我们实现离线缓存、消息推送和网络代理等功能\n3.Http缓存，分为强缓存和协商缓存\nhttp缓存的是指:当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档\n强缓存（优先于协商缓存，返回码200）：\n利用Expires（http1.0，记录缓存过期时间）和Cache-Control（http1.1，记录缓存过期时间）来控制，Cache-Control优先级高于Expires，Expires 使用的是服务器端的时间，要是客户端时间和服务端不同步，就可能造成浏览器本地的缓存无用或者一直无法过期，Cache-Control使用的是使用的是客户端本地时间的计算，所以不会出现上述情况，Cache-Control优先级高于Expires，\n协商缓存（返回码304）：\n利用If-None-Match（请求头）/Etag（响应头）和If-Modified-Since（请求头）/Last-Modified（响应头），If-None-Match和Etag记录的是服务器为每个资源生成的唯一的标识字符串，缓存的数据要是改变了，那么这两个数据就会变，这样可判断缓存到底有没有更新，If-Modified-Since和Last-Modified记录的是服务端的文件最后改变的时间，通过判断这个，可以缓存有没有被更新，Last-Modified有一个缺陷就是只能精确到1s，所以对于精确更高的可能不适用，Etag优先级高于Last-Modified，Etag生成过程需要服务器额外付出开销，会影响服务器性能，所以要看情况使用Etag\n4.Push Cache\nhttp2阶段的缓存，应用尚处于萌芽阶段，是缓存的最后一道防线。\n浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。\n本地存储机制1.利用WebStorage\nWebStorage提供了一种方式让网站能够把信息存储到本地的计算机上，并在以后需要的时候进行获取。这样一来，当需要用到什么资源时，可以直接在本地存储里获取，而不用发起网络请求等待响应。WebStorage分为localStorage（只支持string类型的存储）与Session Storage（只支持string类型的存储），Session Storage在会话结束消失， localStorage永久有效，手动删除才会消失，Session Storage 和localStorage都遵循同源策略，但是对Session Storage特殊的一定在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。\n2.利用IndexDB\nIndexDB运行在浏览器上的非关系型数据库，突破了WebStorage的存储大小限制，支持存储字符串和二进制数据，IndexDB可创建数据库和表，可以被当成一个真正的数据库使用。\nCSS 优化选择器css是从右往左进行解析的，这也就是说 (ul&gt;li)这种写法，浏览器是先去找到li，再去看每个li的父元素是不是ul,当使用层级较多的选择器时（如：body&gt;div&gt;p&gt;span），会加大浏览器的寻找时间，而我们的原则因当是使浏览器能够尽快的找到相应的元素。所以css选择器方面的优化方案为：\n\n避免后代选择符(后代选择器的开销很高)\n避免链式选择符，避免使用复杂的选择器，层级越少越好\n避免使用通配符（使用通配符会使浏览器找遍所有的元素）\n少用标签选择器，尽量用类选择器代替\n避免不必要的重复\n\n减少 CSS 阻塞当我们在html时，总是在解析到link标签或style标签时，CSSDOM才会开始构建，这个构建过程会导致DOM解析的阻塞，所以为了减少阻塞时间，我们需要尽快完成加载（启用CDN），尽早完成加载（在head元素中引用css相关标签）\nJavaScript 优化window.requestAnimationFrame()即便你能保证每一帧的总耗时都小于16ms，也无法保证一定不会出现丢帧的情况，这取决于触发JS执行的方式。假设使用 setTimeout 或 setInterval 来触发JS执行并修改样式从而导致视觉变化；那么会有这样一种情况，因为setTimeout 或 setInterval没有办法保证回调函数什么时候执行，它可能在每一帧的中间执行，也可能在每一帧的最后执行。所以会导致即便我们能保障每一帧的总耗时小于16ms，但是执行的时机如果在每一帧的中间或最后，最后的结果依然是没有办法每隔16ms让屏幕产生一次变化。\n\n即便我们能保证每一帧总体时间小于16ms，但如果使用定时器触发动画，那么由于定时器的触发时机不确定，所以还是会导致动画丢帧。现在整个Web只有一个API可以解决这个问题，那就是requestAnimationFrame，它可以保证回调函数稳定的在每一帧最开始触发。\n\n应用了 RAF 的网页动画例子：\n12345678910var rAF = window.requestAnimationFrame;var degrees = 0;function update() &#123;  div.style.transform = \"rotate(\" + degrees + \"deg)\";  console.log('updated to degrees ' + degrees);  degrees = degrees + 1;  rAF(update);&#125;rAF(update);\nwindow.requestIdleCallback()还有一个函数 window.requestIdleCallback() ，也可以用来调节重新渲染。它指定只有当一帧的末尾有空闲时间，才会执行回调函数。\n减少JS阻塞页面构建dom树的过程，即从上到下解析HTML文档生成DOM节点树，当解析到&lt;script&gt;标签时，会解析其中的脚本（对于外链的JavaScript文件，需要先加载该文件内容），然后立即执行，这整个过程都会阻塞文档解析，直到脚本执行完才会继续解析文档。如果js文件的数量和内容都比较大，那么就会造成页面空白，所以为了避免这一状况，应该把 &lt;script&gt;标签放在&lt;/body&gt;标签前面，而不是放在&lt;head&gt;标签里,要使用async(异步加载，脚本加载完立刻执行)和defer(异步加载，文档解析完执行)\n在异步任务中实现 DOM 修改时，把它包装成 micro 任务(微任务）事件循环一般是这样，先处理Macro-task（宏任务）,再处理micro 任务，micro 任务处理完后面紧跟着就是渲染的步骤，然后更新界面，处理Web work任务。包装成 micro 任务，这样不用等新的一轮事件循环，直接渲染呈现\nDom方面（从减少页面回流方面来考虑）减少Dom操作，缓存dom变量var a=document.querySelector(&quot;#demo&quot;);\n避免循环更改dom，在更改时创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到相应dom中\n在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的 “访问集合” 包括读取集合的 length属性、访问集合中的元素。　　因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。\n代码方面慎用 withwith 在蝴蝶书里面就被明确的视为禁术，他会延长当前对象的作用域链，使得查找作用域的性能大大降低，请不要因为懒得写几行代码就直接使用 with 。可是使用局部变量来代替 with。\n避免使用 eval 和 Function每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。\nVue 优化使用v-if代替v-show两者的区别是：v-if不渲染DOM，v-show会预渲染DOM除以下情况使用v-show，其他情况尽量使用v-if\n\n有预渲染需求\n需要频繁切换显示状态\n\nv-for必须加上key，并避免同时使用v-if一般我们在两种常见的情况下会倾向于这样做:\n\n为了过滤一个列表中的项目比如v-for=“user in users” v-if=“user.isActive”。在这种情形下，请将users替换为一个计算属性 (比如activeUsers)，让其返回过滤后的列表\n为了避免渲染本应该被隐藏的列表比如v-for=“user in users” v-if=“shouldShowUsers”。这种情形下，请将v-if移动至容器元素上 (比如ul,ol)\n\n事件及时销毁Vue组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。也就是说，在js内使用addEventListener等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：\n123456created() &#123;  addEventListener('touchmove', this.touchmove, false)&#125;,beforeDestroy() &#123;  removeEventListener('touchmove', this.touchmove, false)&#125;\n资源提前请求经测试，Vue项目中各文件的加载顺序为：router.js、main.js、App.vue、[page].vue、[component].vue，如图：\n\n其中，router的加载时间相比于page.vue快近100ms，如果page.vue的文件较多，时间差异会更大。 所以，可以在页面挂载、渲染的同时去请求接口数据，如在router.js中请求数据：\n1234import Router from 'vue-router'import store from './store'store.dispatch('initAjax')\n多使用异步组件和插件不需要首屏加载的组件都使用异步组件的方式来加载，如多 tab。包括需要触发条件的动作也使用异步组件（如弹窗） 使用方式为：v-if来控制显示时机，引入组件的Promise即可。\n网络优化减少网络请求\n浏览器对同一时间针对同一域名下的请求有一定数量限制（一般是6个），超过限制数目的请求会被阻塞  \n\n首屏尽可能减少同域名的请求，包括接口和js；按需减少首屏的chunk.js，合并接口请求\nDNS 解析优化DNS 缓存 -&gt; 减少 DNS 解析时间keep-alive 减少链接建立次数。\nCDN 和 SSRCDN全称是内容分发网络，简单的来说，CDN做的事，就是把资源存在离自己最近的服务器里，从而实现就近访问数据，快速获取到需要的数据\nCDN 往往被用来存放静态资源(像 JS、CSS、图片等不需要业务服务器进行计算即得的资源),可以将静态资源和主页面置于不同的域名下，避免cookie的携带，这样可以做到优化CDN\n\n服务端渲染，就是当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容。\n没有服务器渲染，当浏览器解析html文档解析到&lt;script&gt;标签时，就需要停下html渲染，去解析其中的脚本并执行，这整个过程都会阻塞文档解析，直到脚本执行完才会继续解析文档进行渲染。如果js文件的数量和内容都比较大，那么就会造成页面空白，这样是非常不利于用户体验的，服务器渲染就能很好的解决这一问题。\n服务端渲染也不是随便就能用的，它加重了服务器的压力，也需要合理使用\nReference让你的网页更丝滑（一） - 掘金\n网页性能管理详解 - 阮一峰的网络日志\n如何读懂火焰图？ - 阮一峰的网络日志\n前端性能优化方案都有哪些？ - coober - 博客园\n掘金小册前端性能优化原理与实践读后总结 - loisandyu的博客 - CSDN博客\n一张图说明CDN网络的原理 - coolme的专栏 - CSDN博客\n从4个方面优化你的Vue项目 - 掘金\n2018你应该知道的Web性能信息采集指南 - 掘金\n","plink":"https://xkeith.space/post/arc-12/"},{"title":"前端工程师技术图谱","date":"2019-03-27T10:45:34.000Z","updated":"2019-03-27T10:46:51.634Z","content":"\n","plink":"https://xkeith.space/post/arc-11/"},{"title":"TCP 的三次🤝与四次🙋详解","date":"2019-03-26T14:03:37.000Z","updated":"2019-04-17T13:24:13.642Z","content":"\nTCP 协议如何保证可靠运输通过序列号与确认应答提高可靠性在 TCP 中，当发送端的数据到达接收端的时候，接收端会返回一个已收到消息的通知，这个消息叫做 ACK (Positive Acknowled-gement)。TCP 通过检查 ACK 实现可靠的数据传输。如果接收端成功返回 ACK，说明数据已经成功到达。反之，丢失数据的可能性很大。一定时间内没有收到 ACK 的话，发送端就会对数据包进行重传。\n重传发生的几种情况\n超时重传\n\n￼\n超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。\n\n确认丢失和确认迟到\n\n\n当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：\n\n丢弃这个重复的M1消息，不向上层交付。\n向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。\n\n\nA发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：\n\nA收到重复的确认后，直接丢弃。\nB收到重复的M1后，也直接丢弃重复的M1。\n\n超时时间的确定最理想的超时时间是，找到一个最小时间，他能保证确认应答一定能在这个时间内返回。然而这个时间会根据网络环境的不同而变化。TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。因此它在每次发包的时候都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时时间会比这个值还稍微大一点。一般情况下重发时间都是 0.5s 的整数倍，同时因为偏差时间的最小值也是 0.5s ，因此最小的重发超时时间至少是 1s。一般情况下超时时间设置为 6s，如果数据被重发后还是没有正常收到 ACK，等待确认的时间会以 2倍，4倍…的指数方式增长。如果达到一定重发次数后还是不成功，就会判定为网络异常，强制关闭链接，并且通知应用程序。\n两种重传协议自动重传请求 ARQ 协议停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。优点： 简单缺点： 信道利用率低\n连续ARQ协议连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。\n序列号上述这些确认应答处理，重发控制以及重复控制等功能都可以通过序列号实现。序列号是按顺序给发送数据的每一个字节（8位）都标上号码的编号，接收端查询数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接受的序号返回，这样通过 ACK 和序列号的结合可以实现可靠的运输。\nTCP 以段为单位发送数据TCP 将原始数据报分割成合适的大小进行传输，这个大小叫做最大消息长度 MSS: Maximum Segment Size 。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。TCP 在数据发送和重发的时候都是以 MSS 为单位的。MSS 是在三次握手的时候，在两端主机之间被计算得出。两端在建立连接的时候，会在 TCP 首部写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 大小，然后会在两者之间选择一个较小的值投入使用。\n滑动窗口我们已经了解到 TCP 将数据报分段进行处理，每次发送一个段就进行一次确认应答的处理，这又带来一个缺点，包的往返时间越长，包的数量越多，通信性能就会大大降低。为了解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，他也能控制网络性能的下降。确认应答不再是一对一的，而是以窗口为单位进行确认。也就意味着发送端主机在发送了一个段以后不必要一直等待确认应答，而是继续发送。这个机制需要大量的缓冲区，一个窗口内的数据即便没有收到确认应答也可以发送出去，同时为了解决发送过程中的数据丢失，保证可以及时重发缺失的数据，发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据。如果一个窗口中的某段数据没有成功送达，那么该段之后的数据都会重传，窗口会滑动到以该段数据为起点。\n\n拥塞控制在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。\n\n慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。\n\n快重传和快恢复在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。  当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。\n哪些面试官非常喜欢问的问题为什么不能用两次握手进行连接？一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。\n如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。\n如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。\n为什么客户端最后还要等待2MSL？MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。\n第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。\n第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。\n为什么建立连接是三次握手，关闭连接确是四次挥手呢？建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。\n如果已经建立了连接，但是客户端突然出现故障了怎么办？TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n握手和挥手详细过程三次握手\n四次挥手\nReferenceTCP的三次握手与四次挥手（详解+动图） - qzcsu的博客 - CSDN博客\n计算机网络：这是一份全面 &amp; 详细 的TCP协议学习指南 - 专注分享 Android开发 干货 - CSDN博客\n搞定计算机网络面试，看这篇就够了（补充版） - 掘金\nTCP的三次握手与四次挥手理解及面试题（很全面） - lucky_jun - CSDN博客\n","plink":"https://xkeith.space/post/arc-10/"},{"title":"Top-K 问题","date":"2019-03-25T08:51:45.000Z","updated":"2019-03-25T12:04:23.644Z","content":"\n\n从 n 个数中找出最大的 k 个数  \n\n全局排序最容易的方法，全部排序，取出最大的 k 个。时间复杂度取决于具体使用的排序算法。问题出在当数据数量特别大的时候，花费了很多时间在不需要的元素的排序上。\n局部排序不再全局排序，只对最大的 k 个排序。相当于冒泡排序或者是选择排序，不断选择最大值放到前面。时间复杂度是 O(n * k)但是我们要注意，top-k 问题中的这 k 个最大元素是不需要有序的，因此我们可以进一步减少操作。\n堆先用前 k 个元素生成一个小顶堆，用于存储当前扫描过的数据中最大的 k 个元素。之后从第 k+1 个元素开始扫描，如果有元素大于当前堆顶的元素，那么淘汰当前堆顶元素，替换为新元素，同时调整堆的平衡。最后剩下的 k 个元素组成的堆，就是 top-k 。假设每次堆都发生了调整，那么时间复杂度为 O(n * lg(k) )堆是解决 top-k 的经典算法，接下来要开始更秀的操作了🤒\n随机选择随机选择算法是《算法导论》中一个经典的算法，其时间复杂度为O(n)，是一个线性复杂度的方法。利用快排来寻找 top-k ，找到数组中第 k 大的元素，此时数组中该元素左边的元素即是 top-k。\n快速排序第一次partition，划分之后：i = partition(arr, 1, n);\n\n如果i大于k，则说明arr[i]左边的元素都大于k，于是只递归arr[1, i-1]里第k大的元素即可；\n\n如果i小于k，则说明说明第k大的元素在arr[i]的右边，于是只递归arr[i+1, n]里第k-i大的元素即可；\n\n\n1234567891011121314151617181920212223242526272829let partitionLomuto = function(*arr*, *low*, *high*) &#123;  high--;  const pivot = arr[high];  for (var j = low; j &lt; high; j++) &#123;    if (arr[j] &gt;= pivot) &#123;      var temp = arr[low];      arr[low] = arr[j];      arr[j] = temp;      low ++;    &#125;  &#125;  temp = arr[low];  arr[low] = arr[high];  arr[high] = temp;  return low;&#125;let RS = function(*arr*, *low*, *high*, *k*) &#123;  let i = partitionLomuto(arr, low, high);  let temp = i - low;  if (temp === k)&#123;    return;  &#125;  if (temp &gt; k) &#123;    RS(arr, low, i, k);  &#125;else &#123;    RS(arr, i+1, high, k-i);  &#125;&#125;;\n\nBitMap位图是个很极端的空间换时间的方法。例如，集合S={1,3,5,7,9}，容易发现，S中所有元素都在1-16之间，于是，可以用16个bit来表示这个集合：存在于集合中的元素，对应bit置1，否则置0。画外音：究竟需要多少存存储空间，取决于集合中元素的值域，在什么范围之内。上述集合S，可以用1010101010000000这样一个16bit的bitmap来表示，其中，第1, 3, 5, 7, 9个bit位置是1。假设TopK的n个元素都是int，且元素之间没有重复，只需要申请2^32个bit，即4G的内存，就能够用bitmap表示这n元素。扫描一次所有n个元素，以生成bitmap，其时间复杂度是O(n)。生成后，取TopK只需要找到最高位的k个bit即可。算法总时间复杂度也是O(n)。\nfalse is false, true may be true但是 bitmap 有个问题，重复的元素会被覆盖，这样可能会使得能表达的数据变少，我们采用一种计数的位图来解决问题，如果数据出现重复，那么该位 count + 1，top-k 就成为了从后到前，count 之和 = k。\n\nReferenceTop-K问题 | 易学教程\n","plink":"https://xkeith.space/post/arc-09/"},{"title":"如何拿下前端面试（网络篇）","date":"2019-03-23T13:47:33.000Z","updated":"2019-03-26T12:47:44.348Z","content":"\n\n应用层（HTTP / HTTPS）\n状态码1XX信息性状态码，表示接收的请求正在处理。\n2XX成功状态码，表示请求正常处理完毕\n200 OK请求正常处理，会根据不同的请求方法返回不同的响应信息。\n204 No Content请求成功处理，但在返回的响应报文中不含实体的主体部分。也不允许返回任何实体的主体。一般用于客户端的信息发送，不需要接收任何新信息的时候。\n206 Partial Content表示范围请求成功处理，响应报文中包含由 Content-Range 指定范围的实体内容。\n3XX重定向状态码，表示需要进行附加操作以完成请求\n301 Moved Permanently永久性重定向。表示该请求的资源已经被分配到了其他的 URL 上。\n302 Found临时重定向\n303 See Other表示由于请求对应的资源存在另一个 URL，应使用 GET 方法定向获取请求的资源。\n304 Not Modified如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。简单的表达就是：客户端已经执行了GET，但文件未变化。\n307 Temporary Redirect临时重定向，与 302 有点区别。\n4XX客户端错误状态码，服务器无法处理请求\n400 Bad Request请求报文中存在语法错误。\n401 Unauthorized表示用户未授权，可用于用户状态验证。\n403 Forbidden表示请求被服务器拒绝了，没有访问权限。\n404 Not Found服务器上没有请求的资源。\n5XX服务器错误状态码，服务器处理请求出错\n500 Internal Server Error后台服务器 bug 啦\n503 Service Unavailable服务器超负载或者是停机维护。\nGET 和 POST 的区别常规意义上的区别\nGET在浏览器回退时是无害的，而POST会再次提交请求。\nGET产生的URL地址可以被Bookmark，而POST不可以。\nGET请求会被浏览器主动cache，而POST不会，除非手动设置。\nGET请求只能进行url编码，而POST支持多种编码方式。\nGET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\nGET请求在URL中传送的参数是有长度限制的，而POST么有。\n对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\nGET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\nGET参数通过URL传递，POST放在Request body中。\n\n容易错误的理解GET使用URL或Cookie传参，而POST将数据放在BODY中\nGET和POST是什么？HTTP协议中的两种发送请求的方法。HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。\nGET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。\nHTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。\nGET方式提交的数据有长度限制，则POST的数据则可以非常大\nHTTP协议对GET和POST都没有对长度的限制。HTTP协议明确地指出了，HTTP头和Body都没有长度的要求。首先是”GET方式提交的数据有长度限制”，如果我们使用GET通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。\n注意这个限制是整个URL长度，而不仅仅是你的参数值数据长度。POST也是一样，POST是没有大小限制的，HTTP协议规范也没有对POST数据进行大小限制，起限制作用的是服务器的处理程序的处理能力。当然，我们常说GET的URL会有长度上的限制这个说法是怎么回事呢？虽然这个不是GET和POST的本质区别，但是我们也可以说说导致URL长度限制的两方面的原因：\n\n浏览器。早期的浏览器会对URL长度做限制。而现在的具体限制是怎么样的，我自己没有亲测过，就不复制网上的说法啦。\n服务器。URL长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个M大小的URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，告诉服务器Content-Length是一个很大的数，然后只给服务器发一点儿数据，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。\n\nPOST比GET安全，因为数据在地址栏上不可见\n这个说法其实也是基于上面的1，2两点的基础上来说的，我觉得没什么问题，但是需要明白为什么使用GET在地址栏上就不安全了，以及还有没有其他原因说明“POST比GET安全”。通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。\n满分回答是啥样GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？\n\nGET与POST都有自己的语义，不能随便混用。\n据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。\n并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。\n\nGET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别，上面的只是在使用上的区别。\n什么是幂等性？幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。\n正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。POST 操作具有副作用，也就是说会更改服务器上的状态。另外 POST 操作一般不是幂等的，每次 POST 操作都应该创建一个新的资源。\ncookie、localstroage、sessionstroage的区别Cookie适合存储一些session信息：\n\ncookie限制大小，约4k左右，不适合存储业务数据，尤其是数据量较大的值\n存在有效期，到期自动销毁\ncookie会每次随http请求一起发送，浪费宽\ncookie设置了domain可以在子域共享跨域\n可以使用爬虫抓取localstroage适合存储应用共享的地址信息等：\n存储数据量大，5M或者更大\n有效期为永久\n不会随http请求一起发送\n不能跨域，但是可以使用postMessage和iframe消除这个影响,例如： cross-storage \n在浏览器的隐私模式下不能读取\n不能被爬虫读取sessionstroage适合存储浏览状态等：\n存储数据量大，5M或者更大\n有效期为到浏览器关闭\n不会随http请求一起发送\n不能被爬虫读取\n\nSessionHTTP 是个无状态的链接，为了记录 HTTP 状态，催生了 Cookie 和 Session 。\nCookie 存在客户端，Session 存在服务器。依赖 Cookie 在响应头中 Set-Cookie: JSESSIONID = xxx\n常用的三种实现方式\n\n依赖 Cookie 实现\n直接在 URL 后边重写\n设置一个隐藏的表单域\n\n过多的浏览器请求，会在服务器端创建很多的Session信息，会对浏览器造成一定的内存压力，而且不易于维护。\ntoken基于token的验证是无状态的。服务器不记录哪些用户已登陆或者已经发布了哪些JWT。对服务器的每个请求都需要带上验证请求的token。该标记既可以加在header中，可以在POST请求的主体中发送，也可以作为查询参数发送。\n存储方式\n\n存在 Cookie\n存在 localStorage\n\n工作流程：\n\n用户输入登陆凭据；\n服务器验证凭据是否正确，然后返回一个经过签名的token；\n客户端负责存储token，可以存在local storage，或者cookie中；\n对服务器的请求带上这个token；\n服务器对JWT进行解码，如果token有效，则处理该请求；\n一旦用户登出，客户端销毁token。\n\n优势\n\n基于token的验证是无状态的，这也许是它相对cookie来说最大的优点。后端服务不需要记录token。每个令牌都是独立的，包括检查其有效性所需的所有数据，并通过声明传达用户信息。服务器唯一的工作就是在成功的登陆请求上签署token，并验证传入的token是否有效。\n好的API可以同时支持浏览器，iOS和Android等移动平台。然而，在移动平台上，cookie是不被支持的。\n一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多。\n\n格式\nJWT 包括三个部分：头部、载荷、签名，通过. 连接这三部分。\n头部通常包括两部分：token类型（JWT），和使用到的算法，如HMAC、SHA256或RSA，下面是一个例子，说明这是一个JWT，使用的签名算法是HS256。\n头部会通过Base64Url编码形成JWT的第一部分\n第二部分是载荷，要传递出去的声明，其中包含了实体（通常是用户）和附加元数据。有三种类型的声明：\n\n保留声明：这是一组预定义的声明，非强制性，用来帮助接收方（服务器）更好地理解这个JWT。其中包括：iss（issuer，该JWT的签发者），exp（expiration time，过期时间），sub（subject，该JWT所面向的用户），aud（audience，JWT的接收者），和另外一些声明\n公共声明：这些可以用使用JWT的人随意定义。但是为了避免冲突，应在在IANA JSON WEB令牌注册表中定义它们，或者将其定义为包含防冲突命名空间的URI。\n私有声明：这些是为了在同意使用它们的各方之间共享信息而创建的自定义声明。\n\n传输层（TCP / IP）￼\n三次🤝 四次🙋TCP 与 UDP 的区别网络层IP 协议数据链路层物理层安全CORSCross-Origin Resource Sharing跨来源资源共享，是一份浏览器技术规范，提供了 WEB 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。\n简单请求并不会触发 CORS 预检关于 CORS 的详细介绍参见 MDN 和阮一峰的博客。\nCORS是W3c工作草案，它定义了在跨域访问资源时浏览器和服务器之间如何通信。CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否。同源策略：是浏览器最核心也最基本的安全功能；同源指的是：同协议，同域名和同端口。精髓：认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源；JSON &amp; JSONP:JSON 是一种基于文本的数据交换方式，或者叫做数据描述格式。JSONP是资料格式JSON的一种“使用模式”，可以让网页从别的网域要资料，由于同源策略，一般来说位于server1.example.com的网页无法与不是 server1.example.com的服务器沟通，而HTML的script元素是一个例外。利用script元素的这个开放策略，网页可以得到从其他来源动态产生的JSON资料，而这种使用模式就是所谓的JSONP\n解决方案主要解决思路：使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否.Access-Control-Allow-Origin:指定授权访问的域Access-Control-Allow-Methods：授权请求的方法（GET, POST, PUT, DELETE，OPTIONS等)\n后端解决\n\n增加一个过滤器来处理预检请求\n返回包含哪些与 CORS 有关的响应头\n或者是通过 Nginx 来支持跨域\n\n前端解决\n\nvue 和 webpack 都可以通过调用 http-proxy-middleware 这个库来实现客户端代理，从而解决跨域问题。\n\nXSS 攻击XSS，即为（Cross Site Scripting），中文名为跨站脚本,跨站脚本的重点不在“跨站”上，而在于“脚本”上。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码，实际上是在目标网站的作用域下执行了这段第三方域上的js代码。\n反射型XSS（非持久型XSS）特点：就像镜子反射一样，浏览器发射含XSS的url，服务器将其反射回来\n\n浏览器发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，\n服务器解析并响应，响应结果中包含XSS代码，\n最后浏览器解析并执行。\n\n攻击者会将 XSS 脚本通过请求参数的方式发送到服务器，服务器执行后会返回 cookie 信息等隐私信息。一般黑客会注入一段第三方的js代码，然后将获取到的cookie信息存到他们的服务器上，拿到我们的身份认证做一些违法的事情了。\n存储型XSS（持久型XSS）特点：黑客将XSS代码发送给服务器，然后通过服务器散播\n\n黑客将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。）\n其他人请求页面的时候就会带上XSS代码了。\n\n案例：最典型的就是留言板XSS。\n\n黑客提交了一条包含XSS代码的留言到数据库。\n当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。\n浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。\n\nDOM 型 XSS特点：DOM XSS代码不需要服务器端的解析响应的直接参与，而是完全通过浏览器端的DOM解析。\n\n浏览器的代码中含有eval，new Function等将字符串内容执行的代码\n在执行的字符串中嵌入可以执行XSS代码字符串 案例：\n\n1234567test.addEventListener('click', function () &#123;  var node = window.eval(txt.value)  window.alert(node)&#125;, false)//txt中的代码如下:&lt;img src='null' onerror='alert(123)' /&gt;\n危害和防御\n通过document.cookie盗取cookie\n使用js或css破坏页面正常的结构与样式\n流量劫持（通过访问某段具有window.location.href定位到其他页面）\nDos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。\n利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。\n利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。\n\nXSS攻击可以看出，不能原样的将用户输入的数据直接存到服务器，需要对数据进行一些处理：\n\n过滤危险的DOM节点。如具有执行脚本能力的script, 具有显示广告和色情图片的img, 具有改变样式的link, style, 具有内嵌页面的iframe, frame等元素节点。\n过滤危险的属性节点。如on-, style, src, href等\n对cookie设置httpOnly,但是也会导致前台无法操作cookie，不太推荐。\n\nCSRFCSRF（Cross-site request forgery），中文名称：跨站请求伪造，攻击者盗用了你的身份，以你的名义发送恶意请求。\n\n特点：\n\n登录受信任网站A，并在本地生成Cookie。\n在不登出受信任网站A的情况下，访问危险网站B。\n危险网站会向受信任A的网站发送请求，同时会携带受信任网站A本地生成Cookie(用同一个浏览器访问同一个域的接口)\n\n危害和防御\n篡改目标网站上的用户数据；\n盗取用户隐私数据；\n作为其他攻击向量的辅助攻击手法；\n传播CSRF蠕虫。\n\n防御\n\n验证码，因为验证码必须在受信任的网站上发送给浏览器的，并且伪造的网站和受信任的网站非同源，所以没有办法获取受信任网站发送的session，所以验证码是没有办法伪造的。\nrefer，标识了当前请求的页面的源，伪造网站可以篡改成受信任的网站源，并不保险\ntoken，由于它是通过服务的发送给客户端的令牌，并且存储在浏览器的localstorage中，由于同源策略，并且token还有校验规则，所以token并不能轻易篡改。\n\nHTTPS 怎么预防攻击HTTPS = (HTTP+TLS/SSL)\n\n自己先问问自己点击一个 url 到页面被渲染出来，中间都发生了什么？面试必问，很大概率是第一问，要从五层体系结构开始吹，注意其中的用词，把技术词汇朝自己想好的坑里带，如最短路径，CORS，TCP 和 UDP 的区别，总之就是千万不要出现自己解释不好的词汇，防止给自己挖坑。\n\nHTTP 和 HTTPS 的区别？\n\nTCP 和 UDP 的区别\n\n握手和挥手，说一说\n\n如何解决跨域\n\n\nReferenceCookie和Token - WillieLiu的专栏 - CSDN博客\n搞定计算机网络面试，看这篇就够了 - 掘金\nHTTP｜GET 和 POST 区别？网上多数答案都是错的！ - 简书\n99%的人都理解错了HTTP中GET与POST的区别\n前端必须懂的计算机网络知识—(跨域、代理、本地存储) - 掘金\nCORS 跨域 实现思路及相关解决方案 - sloong - 博客园\nWebpack-dev-server的proxy用法 - 简书\n 阮一峰的 CORS 详解 \nHTTP访问控制（CORS） - HTTP | MDN\nCORS(跨域资源共享) - spaceway - 博客园\n","plink":"https://xkeith.space/post/arc-08/"},{"title":"如何拿下前端面试（基础篇之 MVVM）","date":"2019-03-23T03:57:18.000Z","updated":"2019-03-23T03:59:39.641Z","content":"\n定义Model-View-ViewModel\nMVVM 其实就是提供 View 和 Model 的双向绑定，由前端架构而兴起，为了解决大前端中对 DOM 的频繁操作带来的性能问题，也让前端如 H5 界面拥有了更强大的功能，甚至可以独立与服务端完成数据操作。\nVue.js 是部分遵循了 MVVM 架构的（官方说法可不是一个完全遵循 MVVM 的框架），主打的就是数据驱动的架构方法，采用了数据劫持的方法来为我们实现了 ViewModel 中的双向数据绑定，可以自动保持视图和数据的一致性，让开发更加高效，便捷。\nMVVM，说到底还是一种分层架构。它的分层如下：\n\nModel: 域模型，用于持久化\nView: 作为视图模板存在\nViewModel: 作为视图的模型，为视图服务\n\n\n为什么不用 MVC既然我们想要前端也拥有实现数据操作业务的功能，那么我们为什么不选择更加成熟的 MVC 呢？\n传统的 MVC 在前端开发中会暴露以下几个问题：\n\n开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。\n大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。\n当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。\n\n主要的问题实际上还是直接对原生 DOM 的频繁操作实在是太繁琐而且拉低渲染性能了。\nMVVM 实际上就是把 Model 和 View 之间的同步逻辑自动化了，VM 代替了 MVP 中的 Presenter，而且不在需要我们进行手动操作，整个前端架构的逻辑统统交给数据来驱动。\n\n视图引擎视图引擎：我是视图引擎，我为 View 层作为视图模板提供强力支持，开发者，你们不需要操作 DOM ，丢给我来做！\n数据存取器数据存取器：我是数据存取器，我可以通过Object.defineProperty()API 轻松定义，或通过自行封装存取函数的方式曲线完成。我的内部往往封装了发布/订阅模式，以此来完成对数据的监听、数据变更时通知更新。我是数据绑定实现的基础。\n组件机制组件机制：我是组件机制。有追求的开发者往往希望按照面向未来的组件标准 －Web Components的方式开发，我是为了满足你的追求而生。MVVM 框架提供组件的定义、继承、生命周期、组件间通信机制，为开发者面向未来开发点亮明灯。\n\n\nVue 里头是怎么实现的不同的MVVM框架中，实现双向数据绑定的技术有所不同。目前一些主流的前端框架实现数据绑定的方式大致有以下几种：\n\n数据劫持 (Vue)\n发布-订阅模式 (Knockout、Backbone)\n脏值检查 (Angular)\n\nVue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data选项时，Vue 将遍历它的属性，用Object.defineProperty将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。\n\n从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用Object.defineProperty将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。\n\nObserver数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。\nCompile指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。\nWatcher订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。\nDep消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。\n\n实际上实现数据双向绑定的代码并不复杂，我们可以参考下面的链接自己试着实现一下\nReferenceVue.js 和 MVVM - Sweet\u000eoDream - CSDN博客浅析前端开发中的 MVC/MVP/MVVM 模式 - 掘金不好意思！耽误你的十分钟，让MVVM原理还给你 - 掘金什么是MVVM - JrayZhang - SegmentFault 思否\n","plink":"https://xkeith.space/post/arc-07/"},{"title":"正则表达式详解（JavaScript 描述）","date":"2019-03-22T13:15:04.000Z","updated":"2019-04-25T08:38:07.878Z","content":"\n元字符\\s匹配~任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等~。\\w匹配~字母或数字或下划线或汉字~。\n\n一些🌰：\n1234567\\ba\\w*\\b\t匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w*)，最后是单词结束处(\\b)。\\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\\b\\w&#123;6&#125;\\b匹配刚好6个字符的单词。\n元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\\d{5,12}$。这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配~只能不多不少重复2次~，{5,12}则是~重复的次数不能少于5次，不能多于12次~，否则都不匹配。因为使用了^和$，所以输入的整个字符串都要用来和\\d{5,12}来匹配，也就是说整个输入~必须是5到12个数字~，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了~匹配行的开始处和结束处~。\n字符转义如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用\\.和\\*。当然，要查找\\本身，你也得用\\\\.例如：deerchao\\.net匹配deerchao.net，C:\\\\Windows匹配C:\\Windows。\n重复\n字符类字符类用于匹配没有预定义元字符的字符集合。使用方括号来表示一个字符类。举几个🌰：\n1234567[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。[0-9]代表的含意与\\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。一个更复杂的表达式：\\(?0\\d&#123;2&#125;[) -]?\\d&#123;8&#125;。这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。\n分枝条件分枝条件类似于逻辑运算中的或，只要满足一种规则都应匹配。使用 | 来把不同的规则分隔开。举几个🌰：\n123456780\\d&#123;2&#125;-\\d&#123;8&#125;|0\\d&#123;3&#125;-\\d&#123;7&#125;这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。\\(0\\d&#123;2&#125;\\)[- ]?\\d&#123;8&#125;|0\\d&#123;2&#125;[- ]?\\d&#123;8&#125;这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\\d&#123;5&#125;-\\d&#123;4&#125;|\\d&#123;5&#125;这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。\n最后一个例子能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。\n分组使用分组来重复多个字符。分组可以被后向引用，也可以被部分编程语言直接提取使用。使用小括号来指定一个分组。举几个🌰：12345678910(\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d&#123;1,3&#125;匹配1到3位的数字，(\\d&#123;1,3&#125;\\.)&#123;3&#125;匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d&#123;1,3&#125;)。不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。\n这里请彻底理解 2[0-4]\\d|25[0-5]|[01]?\\d\\d?\n反义反义元字符用来查找不属于定义的字符类的字符，常常是元字符的大写。\n\n后向引用使用小括号分组一个表达式后，匹配这个表达式的文本，也就是分组捕获的内容，可以在表达式或其他程序中做进一步的处理。默认每个分组拥有一个组号，从左向右，第一个分组组号为 1，以此类推。后向引用可以用于重复搜索前面某个分组匹配的文本，而不用重写那些冗长的规则。举几个🌰：\n12345678910\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?&lt;Word&gt;\\w+)(或者把尖括号换成&apos;也行：(?&apos;Word&apos;\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k&lt;Word&gt;,所以上一个例子也可以写成这样：\\b(?&lt;Word&gt;\\w+)\\b\\s+\\k&lt;Word&gt;\\b。\n\n零宽断言接下来的四个断言用于查找在某些内容（不包括这些内容）之前或之后的东西。之所以叫做断言，是因为他们给出了匹配位置应该满足的条件。注意，什么是位置匹配，这些字符并不匹配任何字符，他们匹配的是满足响应条件的位置，我们可以把位置看成是任意两个字符之间的空字符。断言是很典型的用来位置匹配的表达式。\nES5 中共有 6 个锚字符^    $    \\b    \\B    (?=p)    (?!p) \n正向零宽断言零宽度正预测先行断言\n(?=exp)\n它断言自身出现的位置的后边能匹配表达式 exp 。举个🌰：\n1234\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I&apos;m singing while you&apos;re dancing.时，它会匹配sing和danc。\n零宽度正回顾后发断言\n(?&lt;=exp)\n它断言自身出现的位置的前面能匹配表达式 exp。举个🌰：\n123(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。\n负向零宽断言前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词—它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\\b\\w*q[^u]\\w*\\b匹配~包含后面不是字母u的字母q的单词~。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w\\b将会匹配下一个单词，于是`\\b\\wq[^u]\\w\\b就能匹配整个Iraq fighting。**负向零宽断言**能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。现在，我们可以这样来解决这个问题：\\b\\wq(?!u)\\w*\\b`。\n零宽度负预测先行断言\n(?!exp)\n它断言此位置的后边不能匹配表达式 exp举个🌰：\n12\\d&#123;3&#125;(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。\n零宽度负预测后发断言\n(?&lt;!exp)\n它断言此位置的前面不能匹配表达式 exp举个🌰：\n12345678910(?&lt;![a-z])\\d&#123;7&#125;匹配~前面不是小写字母的七位数字~。一个更复杂的例子：(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.(任意的字符串),最后是一个后缀(?=&lt;\\/\\1&gt;)。注意后缀里的\\/，它用到了前面提过的字符转义；\\1则是一个反向引用，引用的正是捕获的第一组，前面的(\\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身)。\n总结其实我们很容易就能发现一个规律。\n\n先行断言的表达式一般放在后面，用来匹配的却是表达式前的内容。\n后发断言的表达式一般放在前面，用来匹配的却是表达式后的内容。\n\n注释小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)。要包含注释的话，最好是启用“忽略模式里的空白符”选项，（JavaScript 是不支持这个的）这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：\n1234567(?&lt;=    # 断言要匹配的文本的前缀&lt;(\\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签))       # 前缀结束.*      # 匹配任意文本(?=     # 断言要匹配的文本的后缀&lt;\\/\\1&gt;  # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签)       # 后缀结束\n贪婪与懒惰当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配~最长的以a开始，以b结束的字符串~。如果用它来搜索aabab的话，它会匹配整个字符串~aabab~。这被称为贪婪匹配。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着~匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复~。现在看看懒惰版的例子吧：a.*?b匹配~最短的，以a开始，以b结束的字符串~。如果把它应用于aabab的话，它会匹配~aab（第一到第三个字符）~和~ab（第四到第五个字符）~。\n\n平衡组和递归匹配递归匹配，可以用于匹配嵌套元素中的最小元素，用法实在是太抽象了，用的时候再查吧。\n\nJavaScript 中的正则表达式JavaScript 有个原生对象，regexp，同时 string 的部分方法也支持正则表达式。使用 /exp/ 来包裹表达式来生成一个 regexp 对象。正则表达式标识：g -&gt; 全局匹配，匹配多次i -&gt; 大小写不敏感m -&gt; 多行，此时的 ^ 和 $ 匹配的是行结束符。\nJavaScript 中能使用正则表达式的方法：\n\n案例分析匹配 16 进制颜色值要求匹配：\n1234#ffbbad#Fc01DF#FFF#ffE\n分析：表示一个16进制字符，可以用字符组[0-9a-fA-F]。其中字符可以出现3或6次，需要是用量词和分支结构。使用分支结构时，需要注意顺序。正则如下：\n12var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g; var string = \"#ffbbad #Fc01DF #FFF #ffE\"; console.log( string.match(regex) ); // =&gt; [\"#ffbbad\", \"#Fc01DF\", \"#FFF\", \"#ffE\"]\n匹配时间要求匹配 24 小时制的时间\n共4位数字，第一位数字可以为[0-2]。当第1位为2时，第2位可以为[0-3]，其他情况时，第2位为[0-9]。第3位数字为[0-5]，第4位为[0-9]正则如下：1var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/; console.log( regex.test(\"23:59\") ); console.log( regex.test(\"02:07\") ); // =&gt; true // =&gt; true\n如果也要求匹配7:9，也就是说时分前面的0可以省略。\n1234567var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;console.log( regex.test(\"23:59\") ); console.log( regex.test(\"02:07\") ); console.log( regex.test(\"7:9\") ); // =&gt; true// =&gt; true// =&gt; true\n不匹配任何东西的正则/.^/\n因为此正则要求只有一个字符，但该字符后面是开头。\n驼峰化1234567function camelize(str) &#123;\treturn str.replace(/[-_\\s]+(.)?/g, function(match, c) &#123;\t\treturn c ? c.toUpperCase() : '';\t&#125;);&#125;console.log( camelize('-moz-transform') ); // =&gt; \"MozTransform\"\n其中分组(.)表示首字母。单词的界定是，前面的字符可以是多个连字符、下划线以及空白符。正则后面的?的目的，是为了应对str尾部的字符可能不是单词字符，比如str是’-moz-transform  ‘。\nReference正则表达式30分钟入门教程\nJS正则表达式完整教程（略长） - 掘金\n","plink":"https://xkeith.space/post/arc-06/"},{"title":"Vue 高级（Vue Router 基础）","date":"2019-03-21T14:07:11.000Z","updated":"2019-03-21T14:08:59.763Z","content":"\n动态路由匹配我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个User组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。\n\n响应路由参数的变化\n这就是为什么 PixelStack 不会刷新，早看了这个早就刷新了。😂  \n\n提醒一下，当使用路由参数时，例如从/user/foo导航到/user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化)$route对象：\n12345678const User = &#123;  template: '...',  watch: &#123;    '$route' (to, from) &#123;      // 对路由变化作出响应...    &#125;  &#125;&#125;\n或者使用 2.2 版本中引入的导航守卫\n1234567const User = &#123;  template: '...',  beforeRouteUpdate (to, from, next) &#123;    // react to route changes...    // don't forget to call next()  &#125;&#125;\n捕获所有路由或 404 Not found 路由常规参数只会匹配被/分隔的 URL 片段中的字符。如果想匹配任意路径，我们可以使用通配符 (*)：\n当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由{ path: ‘’ }通常用于客户端 404 错误。如果你使用了History 模式，请确保 正确配置你的服务器 。当使用一个通配符时，$route.params内会自动添加一个名为pathMatch参数。它包含了 URL 通过通配符*被匹配的部分：\n123456// 给出一个路由 &#123; path: '/user-*' &#125;this.$router.push('/user-admin')this.$route.params.pathMatch // 'admin'// 给出一个路由 &#123; path: '*' &#125;this.$router.push('/non-existing')this.$route.params.pathMatch // '/non-existing'\n高级匹配模式vue-router使用 path-to-regexp 作为路径匹配引擎，所以支持很多高级的匹配模式，例如：可选的动态路径参数、匹配零个或多个、一个或多个，甚至是自定义正则匹配。查看它的 文档 学习高阶的路径匹配，还有 这个例子 展示vue-router怎么使用这类匹配。\n匹配优先级有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。\n嵌套路由要在嵌套的出口中渲染组件，需要在VueRouter的参数中使用children配置：\n1234567891011121314151617181920const router = new VueRouter(&#123;  routes: [    &#123; path: '/user/:id', component: User,      children: [        &#123;          // 当 /user/:id/profile 匹配成功，          // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中          path: 'profile',          component: UserProfile        &#125;,        &#123;          // 当 /user/:id/posts 匹配成功          // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中          path: 'posts',          component: UserPosts        &#125;      ]    &#125;  ]&#125;)\n要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。你会发现，children配置就是像routes配置一样的路由配置数组，所以呢，你可以嵌套多层路由。此时，基于上面的配置，当你访问/user/foo时，User的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由：\n1234567891011121314const router = new VueRouter(&#123;  routes: [    &#123;      path: '/user/:id', component: User,      children: [        // 当 /user/:id 匹配成功，        // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中        &#123; path: '', component: UserHome &#125;,        // ...其他子路由      ]    &#125;  ]&#125;)\n编程式的导航除了使用  标签来定义导航连接，我们还可以借助 router 的实例方法，通过编写代码来实现。常用的方法有三个\nrouter.push(location, onComplete?, onAbort?)\n想要导航到不同的 URL，则使用router.push方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。当你点击时，这个方法会在内部调用，所以说，点击等同于调用router.push(…)。该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：\n1234567891011// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: '123' &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;)\n注意：如果提供了path，params会被忽略，上述例子中的query并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的name或手写完整的带有参数的path：\n12345const userId = '123'router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user\n同样的规则也适用于router-link组件的to属性。在 2.2.0+，可选的在router.push或router.replace中提供onComplete和onAbort回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。注意： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个/users/1-&gt;/users/2)，你需要使用 beforeRouteUpdate 来响应这个变化 (比如抓取用户信息)。\nrouter.replace(location, onComplete?, onAbort?)\n跟router.push很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。\nrouter.go(n)\n这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似window.history.go(n)。\n123456789101112// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100)\n 你也许注意到router.push 、router.replace 和router.go跟 window.history.pushState、window.history.replaceState和window.history.go  好像， 实际上它们确实是效仿window.historyAPI 的。因此，如果你已经熟悉Browser History APIs Browser History APIs，那么在 Vue Router 中操作 history 就是超级简单的。还有值得提及的，Vue Router 的导航方法 (push、replace 、go ) 在各类路由模式 (history 、hash和abstract ) 下表现一致。\n重定向和别名重定向也是通过routes配置来完成，下面例子是从/a重定向到/b：\n12345678910const router = new VueRouter(&#123;  routes: [    \t&#123; path: '/a', redirect: '/b' &#125;,\t\t&#123; path: '/a', redirect: &#123; name: 'foo' &#125;&#125;,    \t&#123; path: '/a', redirect: to =&gt; &#123;      // 方法接收 目标路由 作为参数      // return 重定向的 字符串路径/路径对象    \t&#125;&#125;  ]&#125;)\n注意，导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上，在这个例子中，为 /a 路由添加beforeEach 或 beforeLeave 守卫并不会有任何效果。\n路由组件传参在组件中使用$route会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。\n我们可以使用 props 将其接耦\n如果rops被设置为true ，route.params 将会被设置为组件属性。\n12345678910111213141516const User = &#123;  props: ['id'],  template: '&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123;  routes: [    &#123; path: '/user/:id', component: User, props: true &#125;,    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：    &#123;      path: '/user/:id',      components: &#123; default: User, sidebar: Sidebar &#125;,      props: &#123; default: true, sidebar: false &#125;    &#125;  ]&#125;)\nHTML 5 History 模式\n","plink":"https://xkeith.space/post/arc-05/"},{"title":"TCP or UDP ?","date":"2019-03-20T07:03:45.000Z","updated":"2019-03-20T07:06:12.246Z","content":"\nTCP / IP 网络模型计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。\nTCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。\nTCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。\n\n链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。\n网络层：负责路由以及把分组报文发送给目标网络或主机。\n传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。\n应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。\n\n在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。TCP 和 UDP 就是 TCP/IP 中两个具有代表性的传输层协议。\nTCPTransmission Control Protocol\n当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。\n连接过程三次握手🤝\n\n第一次握手：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。\n第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。\n第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为第三次握手为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。\n\n四次挥手🙋‍♂️\nTCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。\n\n第一次挥手：若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。\n第二次挥手：B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。\n第三次挥手：B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。\n第四次挥手：A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。\n\n特点\n面向连接：面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。\n仅支持单播传输：每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。\n面向字节流：TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。\n可靠传输：对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。\n提供拥塞控制：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。\nTCP提供全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）。\n\nUDPUser Datagram Protocol用户数据报协议\n特点\n面向无连接\n\n不需要像 TCP 一样通过三次握手建立连接，想发就发，而且也不对数据报文进行任何处理。\n具体来说就是：\n\n在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了；\n在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。\n\n\n有单播，多播，广播的功能\n\nUDP 不止支持一对一的传输，同样支持一对多，多对多，多对一，也就是单播，广播，多播。\n\nUDP 是面向报文的\n\nUDP 仅对报文添加首部后就向下交付给 IP 层，UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，因此，应用程序必须选择合适大小的报文。\n\n不可靠性\n\n首先不可靠性就体现在无连接上，想发就发，收到什么就传递什么，不对数据进行备份，而且也不在乎对方是否正确的收到了数据。其次，网络环境时好时坏，因为UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络环境不好，也不会对发送速率进行调整。这样实现的弊端就是在网络环境不好的情况下会导致丢包，但是优点也很明显，在某些实时性要求较高的场景（电话会议，视频直播）我们就需要使用 UDP 而不是 TCP。\n\n头部开销小，传输数据报文时很高效\n\n\nUDP 头部包含了以下几个数据：\n\n两个十六位的端口号，分别为源端口（可选字段）和目标端口；\n整个数据报文的长度；\n整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误。因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。\n\n对比\n\nTCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。\n虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为。\n对数据准确性要求高，速度可以相对较慢的，可以选用TCP。\n\nReferenceTCP和UDP比较 -  浪里行舟的博客 - CSDN博客\n","plink":"https://xkeith.space/post/arc-04/"},{"title":"如何速成前端三件套 （CSS）","date":"2019-03-19T15:08:33.000Z","updated":"2019-03-24T02:26:04.933Z","content":"\n常用属性\n层叠次序一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 4 拥有最高的优先权。\n\n浏览器缺省设置\n外部样式表\n内部样式表（位于  标签内部）\n内联样式（在 HTML 元素内部）\n\n因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。\n盒模型every element in web design is a rectangular box\n盒模型(box model)是CSS中的一个重要概念，它是元素大小的呈现方式。\n\nCSS3中新增了一种盒模型计算方式：box-sizing熟悉。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下：\ncontent-box（默认）\n布局所占宽度Width：Width = width + padding-left + padding-right + border-left + border-right布局所占高度Height:Height = height + padding-top + padding-bottom + border-top + border-bottom\npadding-box\n布局所占宽度Width：Width = width(包含padding-left + padding-right) + border-top + border-bottom布局所占高度Height:Height = height(包含padding-top + padding-bottom) + border-top + border-bottom\nborder-box\n布局所占宽度Width：Width = width(包含padding-left + padding-right + border-left + border-right)布局所占高度Height:Height = height(包含padding-top + padding-bottom + border-top + border-bottom)\nmargin叠加\n外边距叠加是一个相当简单的概念。 但是，在实践中对网页进行布局时， 它会造成许多混淆。 简单的说， 当两个或更多个垂直边距相遇时， 它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。但是注意只有普通文档流中块框的垂直外边距才会发生外边距叠加。 行内框、 浮动框或绝对定位框之间的外边距不会叠加。一般来说， 垂直外边距叠加有三种情况：\n\n元素自身叠加 当元素没有内容（即空元素）、内边距、边框时， 它的上下边距就相遇了， 即会产生叠加（垂直方向）。 当为元素添加内容、 内边距、 边框任何一项， 就会取消叠加。\n相邻元素叠加 相邻的两个元素， 如果它们的上下边距相遇，即会产生叠加。\n包含（父子）元素叠加 包含元素的外边距隔着 父元素的内边距和边框， 当这两项都不存在的时候， 父子元素垂直外边距相邻， 产生叠加。 添加任何一项即会取消叠加。\n\nCSS 普通流（文档流）什么是普通流？简单说就是元素按照其在 HTML 中的位置顺序决定排布的过程。并且这种过程遵循标准的描述。\n一般使用margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“距离”。只要不是float和绝对定位方式布局的，都在普通流里面。\nCSS 定位方式display 属性每一个元素都有默认的display属性，使用最多的是 block,inline 和 inline-block，不常用的是 table-cell。根据 display 属性，我们可以将元素分为块级元素(block)和内联级元素(inline)。它们最大区别是:block元素可以设置宽度，独占一行。inline元素宽度由内容决定，与其他元素并列在一行。常见的block属性元素有：div, h1-h6, ul, li, ol, dl, dd, dt。常见的inline属性元素有:span, a, em。\nblock\n宽高可以自行设置，默认宽度由父容器决定，默认高度由内容决定，自己独占一行。\ninline\n宽度和高度都由内容决定，与其他元素共占一行\ninline-block\n宽度可以自行设置，类似block，但是与其他元素共占一行，类似inline。长用于设置垂直居中。\ntable-cell\n此属性指让标签元素以表格单元格的形式呈现，单元格有一些比较特殊的属性，可以设置元素的垂直居中等。\nposition 属性元素在页面中的布局遵守一套文档流的方式，默认的定位属性值为static。它其实是未被设置定位的。元素如果被定位了，那么它的top,left,bottom,right值就会生效，能设置定位的属性是relative,absolute和fixed。需要注意的另一点是被定位的元素层次(z-index)会得到提高。\nrelative（相对定位）\n设置了相对定位之后，通过修改top,left,bottom,right值，元素会在自身文档流所在位置上被移动，其他的元素则不会调整位置来弥补它偏离后剩下的空隙。\nabsolute（绝对定位）\n设置了绝对定位之后，元素脱离文档流，其他的元素会调整位置来弥补它偏离后剩下的空隙。元素偏移是相对于离它最近的设置了定位属性（position值不为static）的元素。且如果元素为块级元素（display属性值为block)，那么它的宽度也会由内容撑开。因为：默认文档流中块级元素如果没有设置宽度属性，会自动填满整行。\nfixed(固定定位)\n设置了固定定位之后，元素相对的偏移的参考是可视窗口，即使页面滚动，元素仍然会在固定位置。\nCSS 相对|绝对(relative/absolute)定位系列\nCSS 浮动相关这也是CSS定位机制的一种。首先了解两个概念：\n\n文档流：文档流是文档中可显示对象在排列时所占用的位置。\n浮动的定义：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。浮动的实际用途，可设置文字环绕或使元素宽度由内容填充（类似Inline-block)。使用浮动需要注意的是如果浮动的元素高度比父级容器还高，那么需要设置父级容器的overflow属性为auto,使其自动撑满。\nCSS 浮动 \n\n\nCSS 选择器选择器是匹配元素的一种模式，不只是在CSS中，JavaScript对CSS的选择器也是支持的，比如document.document.querySelectorAll。\nCSS 解析器HTML 经过解析生成 DOM Tree（这个我们比较熟悉）；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。\n解析顺序CSS匹配不是从左到右进行查找，而是从右到左进行查找。如果从左到右的顺序，那么每条选择器都需要遍历整个DOM树，性能很受影响。所谓高效的CSS就是让浏览器在查找style匹配的元素的时候尽量进行少的查找, 所以选择器最好写的简洁一点。\n选择器权重权重，也就是选择器的优先级，每条选择器的规则都有其权重，权重大的会覆盖掉权重小的，很多CSS出现问题的场景，都是某处定义了一个更高权重的规则，导致此处规则不生效。根据样式所在位置，对元素的影响也有关系：内联样式（标签内style形式） &gt; style标签 &gt; link标签。另外一点需要注意的是!improtant,凡是属性值后加上了!important，那么它的值不会被其他值替换。\n权重的计算\n主要的规则就是:id选择器 &gt; 类，属性选择器和伪类选择器 &gt; 元素和伪元素\n基本选择器\n\n通配符选择器（＊）\nid选择器（#ID）\n类选择器（.className）\n元素选择器(E)\n后代选择器（Ｅ Ｆ）\n子元素选择器(E&gt;F)\n相邻兄弟元素选择器(E + F)\n群组选择器（selector1,selector2,…,selectorN）\n\n属性选择器使用CSS3属性选择器，你可以只指定元素的某个属性，或者你还可以同时指定元素的某个属性和其对应的属性值。\n\nE[attr]：只使用属性名，但没有确定任何属性值\nE[attr=“value”]：指定属性名，并指定了该属性的属性值\nE[attr~=“value”]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写\nE[attr^=“value”]：指定了属性名，并且有属性值，属性值是以value开头的；\nE[attr$=“value”]：指定了属性名，并且有属性值，而且属性值是以value结束的；\nE[attr*=“value”]：指定了属性名，并且有属性值，而且属值中包含了value；\nE[attr|=“value”]：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn）;\n\n伪类选择器伪类选择器的形式就是:xxx， 比如:hover, :link, :nth。\n动态伪类这些伪类并不存在于HTML中,而只有当用户和网站交互的时候才能体现出来，动态伪类包含两种，第一种是我们在链接中常看到的锚点伪类，如”:link”,”:visited”;另外一种被称作用户行为伪类，如“:hover”,”:active”和”:focus”。先来看最常见的锚点伪类。\n\nhover: 用于当用户把鼠标移动到元素上面时的效果\nactive: 用于用户点击元素那一下的效果（正发生在点的那一下，松开鼠标左键此动作也就完成了）\nfocus: 用于元素成为焦点，这个经常用在表单元素上\n\nUI元素状态伪类\n主要是针对于HTML中的Form元素操作，IE8 不支持 :checked, :enabled, :disabed  这三种选择器。\nCSS3的:nth选择器主要注意的是CSS3添加的nth选择器在IE8下不支持。\n\nfist-child: 选择某个元素的第一个子元素；\nlast-child: 选择某个元素的最后一个子元素；\nnth-child(): 选择某个元素的一个或多个特定的子元素；\n其他： 常用的就是上面三种了，其他自行了解。\n\n\nCSS 布局\n固定尺寸布局可以从固定尺寸先了解，先构思好页面的主要结构，做动画的元素一般需要绝对定位，方便操作移动。\n自适应布局响应式的布局的结构其实就是多个固定尺寸的组合，元素的宽度，字体的大小一般会以半分比的形式设置。通过媒体查询进行不同分辨率下的布局。\n如何只用CSS做到完全居中 - 文章 - 伯乐在线\nMetameta 标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键字），或其他 web 服务。\n\nBEMBEM (Block, Element, Modifier)\n是一种基于组件的对 CSS 类名进行约定的 Web 开发方法。他通过定义命名空间来解决权重问题，从而使 CSS 更易于维护。BEM 使用 Block、Element、Modifier 来解释其结构。Block 是一个可跨项目重用的独立组件，且是子组件（Element）的“命名空间”。Modifier 可标示 Block 或 Element 处于某种状态、结构或特定的样式。\n\n-中划线 ：仅作为连字符使用，表示多个单词之间的连接记号\n__双下划线：用来连接 Block 和 Element\n—双中划线：描述 Block 或 Element 的一种状态、结构或样式\n\n1234567891011121314/* block component */.block-name &#123;&#125;/* element */.block-name__element-name &#123;&#125;/* modifier */.block-name__element-name--modifier-name &#123;&#125; &lt;nav class=\"navbar\"&gt;    &lt;a href=\"/\" class=\"navbar__link navbar__link--active\"&gt;&lt;/a&gt;    &lt;a href=\"/\" class=\"navbar__link\"&gt;&lt;/a&gt;&lt;/nav&gt;\n在示例中，navbar 为 Block，navbar__link 是一个不能独立与navbar 存在的 Element，navbar__link--active是标明navbar__link 不同状态的 Modifier。\n\nBEM 实践中也有使用_替代—的情况\n类命名需要尽可能的简明清晰、没有二意性，例如error就比red-text更加有语义。\n建议 Block 只能有一层 Element 嵌套，且 Element 不能独立 Block 存在。如：\n123456789&lt;form class=\"search-form\"&gt;    &lt;div class=\"search-form__content\"&gt;        &lt;input class=\"search-form__input\"&gt;        &lt;!-- 错误：建议使用 `search-form__button` 或 `search-form__content-button` --&gt;        &lt;button class=\"search-form__content__button\"&gt;Search&lt;/button&gt;    &lt;/div&gt;&lt;/form&gt;&lt;!-- 错误：该 Element 应放在 `search-form` Block 中 --&gt;&lt;i class=\"search-form__icon\"&gt;&lt;/i&gt;\n\n建议同一个 Block 或 Element 上不能使用两个以上的 Modifier 去进行修饰，且 Modifier 需配合 Block 或 Element 使用，不能独立存在。如：\n123456&lt;!-- 错误：缺少 `search-form` Block --&gt;&lt;form class=\"search-form_theme_islands\"&gt;&lt;/form&gt;&lt;!-- 错误：使用多个 Modifier --&gt;&lt;form class=\"search-form search-form_theme_islands search-form_theme_lite\"&gt;&lt;/form&gt;\n\n\n那些你不知道的属性margin padding border     \n这些如果同时设置四个方向上的值的话，顺序应当是顺时针的。\n\nTBD…\nReference前端工程师手册 · GitBook (Legacy)\n","plink":"https://xkeith.space/post/arc-03/"},{"title":"计算机网络体系结构","date":"2019-03-18T14:51:44.000Z","updated":"2019-03-18T15:02:27.795Z","content":"\n计算机网络体系结构1.1 简介\n定义\n\n计算机网络的各层 + 协议的集合\n\n作用\n\n定义该计算机网络的所能完成的所有功能\n1.2 结构介绍一般分为三种：\n\nOSI 体系结构：概念清楚，理念完整，但是复杂，不实用。\nTCP / IP 体系结构：包含一系列构成互联网基础的网络协议，是 Internet 的核心协议，被广泛应用于局域网和广域网。\n五层体系结构：融合了 OSI 与 TCP/ IP 的体系结构，目的是学习和讲解计算机原理。\n\n::低三层为通信子网，负责数据传输。::::高三层为资源子网，相当于计算机系统，完成数据处理。::::传输层承上启下::\nTCP / IP 的体系结构详细介绍\n\nOSI 的体系结构详细介绍\nTCP 协议Transmission Control Protocol  即传输控制协议。\n\n属于传输层通信协议基于 TCP 的应用层协议有 HTTP, SMTP, FTP, Telenet, POP3  \n\nUDP 协议3.1 定义User Datagram Protocol         即用户数据报协议\n\n属于传输层通信协议基于 UDP 的应用层协议有 TFTp, SNMP 与 DNS  \n\n3.2 特点无连接的，不可靠的，面向报文，无拥塞控制，具体介绍如下：\n\n3.3 优缺点\n优点：速度快\n缺点：消息易丢失（特别是网络较差的时候）\n\n3.4 应用场景（对应应用层协议）要求通信速度高\n如：域名转换：DNS 协议文件传输：FTP 协议网络管理：SNMP 协议远程文件服务器：NFS 协议\n3.5 报文段格式\nUDP 报文段共有两个字段：数据字段和首部字段\n主要介绍首部（8字节，4个字段）\n\n\n\n3.6 TCP 和 UDP 的区别\n4. HTTP 协议4.1 简介\n5. Socket5.1 简介即套接字，是应用层与 TCP / IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP 协议族的编程接口 API\n\n\nSocket 不是一种协议，而是一个编程调用接口（API)，属于传输层（主要解决数据如何在网络中传输）\n在 Android 平台，我们只能通过 Socket 才能使用 TCP / IP 协议进行开发\n对用户来说，只需要调用 Socket 去组织数据，以符合制定的协议，即可通信。\n\n成对出现，一对套接字：\n1Socket = &#123;(IP 地址1: PORT 端口号), （IP 地址 2: PORT 端口号）&#125;\n一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路。\n5.2 其他知识关于 Socket 的原理、机制过程和使用方式：Android：这是一份很详细的Socket使用攻略 - 简书\n6. 其他知识6.1 在浏览器中输入 url 地址  -&gt; 显示主页的过程\n打开一个网页整个过程中会使用哪些协议  \n\n\n6.2 IP 地址定义链接在 Internet 中的每一台主机（路由器）的全球唯一的标识符\n组成IP 地址 = 32 位 = 网络号 + 主机号；即 IP 地址 = {&lt;网络号&gt;, &lt;主机号&gt;}\n其中：\n\n网络号：标志主机（路由器）所链接到的网络，一个网络号在整个因特网范围内必须是唯一的。\n主机号：标志该主机（路由器）。一个主机号在它面前的网络号所指明的网络范围内必须是唯一的。\n\n不同类型的 IP 地址，其主机号 &amp; 网络号所占字节数不同；故：一个 IP 地址在整个网络范围内是唯一的。\n分类传统的 IP 地址是分类的地址，分为 A, B, C, D, E 五类区别在于网络号 &amp; 主机号所占的字节数不同。\n\n::在各类 IP 地址中，有一些 IP 地址用于特殊用途，不能用做主机 IP 地址::\n\n6.3 ICMP 协议定义Internet Control Message Protocol     国际控制报文协议\n\n属于 IP 层协议\nICMP 报文不是高层协议，而是作为 IP 层数据报的数据，加上数据报首部，组成 IP 数据报发出去。\n\n作用更有效的转发 IP 数据包 &amp; 提高交付成功的机会同时允许主机 / 路由器报告差错 &amp; 异常情况\n分类ICMP 差错报告报文 &amp; ICMP 询问报文\n主要应用PING （分组网间探测）、Traceroute （跟踪一个分组从源点到终点的路径，原理 = 从源主机向目的主机发送一连串的 IP 数据报）主要介绍 Ping 的过程\n6.4 Ping 的过程定义Packet InterNet Groper        分组网间探测\n\n是 ICMP 报文的一个重要应用：使用了 ICMP 回送请求 &amp; 回送回答报文\n是应用层直接使用网络层 ICMP 的一个例子，无需经过传输层的 TCP, UDP\n\n作用测试两个主机的联通性\n原理\n向目的主机发送多个 ICMP 回送请求报文\n根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间\n最终的显示结果：发送到目的主机的 IP 地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小 &amp; 最大 &amp; 平均值\n\n过程假设有两台主机：（目的主机） PC1：IP = 192.168.1.1（源主机） PC2：IP = 192.168.1.2\n\n6.5 路由器与交换机的区别\n6.6 Cookie 与 Session\n\n6.7 Cookie 与 Token\n基于 Cookie 的身份验证 &amp; 验证流程\n\n基于 Token 的身份验证 &amp; 验证流程\n\nReference这是一份详细 &amp; 清晰的计算机网络基础 学习指南 - 简书\n","plink":"https://xkeith.space/post/arc-02/"},{"title":"基于算法的 Swift 学习之路（排序）","date":"2019-03-16T15:15:00.000Z","updated":"2019-03-16T17:00:00.008Z","content":"\n排序这里给出了六大排序的 Swift 语言实现，大部分代码是基于算法4th 的 JAVA 实现直接实现的，也有充分利用 Swift 语言特性的更为简洁的实现。代码中涉及到的 Swift 特性，我选择用算法这样一种实际应用情况来为大家阐述，更为易懂和实用。\n选择排序123456789101112131415161718func selectionSort&lt;T: Comparable&gt;(_ array: [T]) -&gt; [T] &#123;    var a = array    let N = a.count    var count = 0    for i in 0..&lt;N &#123;        var min = i        for j in (i + 1)..&lt;N &#123;            if a[j] &lt; a[min] &#123;                min = j                count += 1            &#125;        &#125;        // Array 库函数，交换两个元素        a.swapAt(i, min)    &#125;    print(\"selectionSort cost \\(count)\")    return a&#125;\n最简单的排序方式，不断选择最小的元素移到第一个元素，因此是个稳定的算法，这里我们要强调的有两个，第一个就是我们在下面经常用到的 Array.swapAt(_ : Int, _ : Int) ，Swift 直接为我们封装好了交换数组两个元素的方法，简单而高效。接下来要说的就是 Swift 中的泛型，我们在这里为方法定义了一个泛型 T 并且要求这个泛型要实现 Comparable 协议，这于算四里直接使用 JAVA 中的 Comparable 超类差不多，但是泛型就意味着我们需要在调用这个方法的时候明确指出这个泛型的真正类型，这种问题常常并不会出现在函数泛型的使用中，因为我们既然为函数声明了泛型，就一定会为其传入相应的参数，Swift 会通过参数自动推断出该泛型。但是我们要知道，同样的泛型声明方法也是可以在类身上的，我们在 JAVA 中为一个泛型类声明的时候要明显的给出实际类型，但是在 Swift 中，我们除了这样显示给出泛型外，如果我们的构造方法里传入了该类型的参数，那么我们就无需再重复声明泛型，Swift 会帮我们推断出该泛型，同时对于这个对象本身，该泛型已经确定，不能再更改了，否则会出现一个类中两个泛型的困扰。关于 Comparable 协议，任何遵循了该协议的变量都自动拥有该协议中包含的几个方法 &lt; &gt; &lt;= &gt;= 等，也就跟其字面意思相同，这是一个可以比较的变量。同样的协议还有 Equalable ，其包含的方法是 == != `\n插入排序（冒泡排序）1234567891011121314func insertionSort&lt;T&gt;(_ array: [T], _ isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T] &#123;    var a = array    var count = 0    for x in 1..&lt;a.count &#123;        var y = x        while y &gt; 0 &amp;&amp; isOrderedBefore(a[y], a[y - 1]) &#123;            a.swapAt(y - 1, y)            count += 1            y -= 1        &#125;    &#125;    print(\"insert cost \\(count)\")    return a&#125;\n插入排序，很多高级排序的基础，也是对于小型数组排序最快的排序方法。对于有序数组也有着很高的排序效率\n这里涉及的 Swift 特性在于那个特别长的参数，也就是那个函数参数。我们知道在 Swift 中，函数是一等类型，可以作为返回值和参数直接使用。这一次我们的泛型并没有直接实现 Comparable 协议，而是用了一个函数直接将操作符 &gt; &lt; 直接当作参数传入，因此可以通过参数来控制递增排序和递减排序，关于 Swift 中的操作符，实际上也是一个函数，我们也可以通过重载为其增加更多的方法。\n希尔排序12345678910111213141516171819202122232425func shellSort&lt;T&gt; (_ array: [T], _ isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T] &#123;    var a = array    let N = a.count    var h = 1    var count = 0    // 递增序列    while h &lt; N / 3 &#123;        h = 3 * h + 1    &#125;    while h &gt;= 1 &#123;        for i in h..&lt;N &#123;            var j = i            while j &gt;= h &amp;&amp; isOrderedBefore(a[j], a[j-h]) &#123;                a.swapAt(j, j-h)                count += 1                //print(a)                j -= h            &#125;        &#125;        h = h / 3    &#125;    print(\"shell cost \\(count)\")    return a&#125;\n插入排序的优化版，通过递增序列使其性能大大提升。\n归并排序这也是个稳定的排序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123class Merge&lt;T: Comparable&gt; &#123;        var aux = [T]()    var data = [T]()    init(_ array: [T]) &#123;        data = array        self.mergeSort(&amp;data, lo: 0, hi: data.count - 1)    &#125;    // 使用 inout 来操作实际参数    func merge(_ array: inout [T], _ lo: Int, _ mid: Int, _ hi: Int)&#123;        var i = lo        var j = mid + 1        aux = array        for k in lo...hi &#123;            if i &gt; mid &#123;                array[k] = aux[j]                j += 1            &#125;            else if j &gt; hi &#123;                array[k] = aux[i]                i += 1            &#125;            else if aux[j] &lt; aux[i] &#123;                array[k] = aux[j]                j += 1            &#125;            else &#123;                array[k] = aux[i]                i += 1            &#125;        &#125;    &#125;                // merge high to low    func mergeSort(_ array: inout [T], lo: Int, hi: Int)&#123;        if hi &lt;= lo &#123;            return        &#125;                let mid = lo + (hi - lo) / 2        mergeSort(&amp;array, lo: lo, hi: mid)        mergeSort(&amp;array, lo: mid + 1, hi: hi)        merge(&amp;array, lo, mid, hi)    &#125;        // merge low to high    func mergeBU(_ array: [T]) -&gt; [T] &#123;        var a = array        let N = a.count        // 归并子数组大小        var sz = 1        while sz &lt; N &#123;            var lo = 0            while lo &lt; N - sz &#123;                // 用 N - 1 防止数组越界                merge(&amp;a, lo, lo+sz-1, min(lo+sz+sz-1, N-1))                // 参与归并的数组大小是子数组的两倍                lo += sz + sz            &#125;            sz = sz + sz        &#125;        return a    &#125;        // 不操作原数组的方式    func merge(leftPile: [T], rightPile: [T]) -&gt; [T] &#123;        // 1        var leftIndex = 0        var rightIndex = 0                // 2        var orderedPile = [T]()        // 为数组申请备用容量，减少长度动态变化的开销        orderedPile.reserveCapacity(leftPile.count + rightPile.count)                // 3        // 两个归并的数组有一个用完就会停止判断        while leftIndex &lt; leftPile.count &amp;&amp; rightIndex &lt; rightPile.count &#123;            if leftPile[leftIndex] &lt; rightPile[rightIndex] &#123;                orderedPile.append(leftPile[leftIndex])                leftIndex += 1            &#125; else if leftPile[leftIndex] &gt; rightPile[rightIndex] &#123;                orderedPile.append(rightPile[rightIndex])                rightIndex += 1            &#125; else &#123;                // 如果一样大，各放入归并的数组一次                orderedPile.append(leftPile[leftIndex])                leftIndex += 1                orderedPile.append(rightPile[rightIndex])                rightIndex += 1            &#125;        &#125;                // 4        // 右侧数组用完        while leftIndex &lt; leftPile.count &#123;            orderedPile.append(leftPile[leftIndex])            leftIndex += 1        &#125;        // 左侧数组用完        while rightIndex &lt; rightPile.count &#123;            orderedPile.append(rightPile[rightIndex])            rightIndex += 1        &#125;                return orderedPile    &#125;        func mergeSort(_ array: [T]) -&gt; [T] &#123;        // guard 更关注的是 else        guard array.count &gt; 1 else &#123; return array &#125;    // 1                let middleIndex = array.count / 2              // 2                let leftArray = mergeSort(Array(array[0..&lt;middleIndex]))             // 3                let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count]))  // 4                return merge(leftPile: leftArray, rightPile: rightArray)             // 5    &#125;&#125;\n涉及到的 Swift 特性：\n\nArray.reserveCapacity\ninout 和 &amp;\nsubsequence\n\n在归并排序中，我们在知道需要的额外数组长度的情况下使用了 reserveCapacity 这个方法来为数组增加备用容量，我们都知道 Swift 中的数组跟 js python 相同，都是动态数组，多数情况下我们是不需要关心数组大小的，但是通过这种事前为数组增加容量的方式可以让我们在需要大量 append 操作的时候减少系统消耗。\ninout 和 &amp; ，Swift 与 JAVA 不同，对于对象类参数的处理是直接修改其原对象信息。Swift 仍然继承了 C 的基础，对象型参数会复制一份到函数中，同时，这个变量是个 let 型，也就是说我们并不能直接操作这个变量，对这个变量的操作就更不可能影响到函数外。这是 Swift 为了贯彻其安全的理念的措施。那么对于需要直接更改实际变量的操作呢，我们就要用到 inout 和 &amp; 这一对操作符，有一点像 C 中的指针，带有 inout 的参数才能被直接访问和修改。\nsubsequence ，在最后的方法中我们直接使用区间运算作为数组的下标来访问同一个数组的前后两部分，但是我们要注意的是，这样得到的实际上并非是个数组，而是个遵守了 subsequence 的类型，而数组，他实现的是 sequence 协议，这两个还不太一样，因此我们在传入参数的时候将其进行了类型转换。\n快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138class Quick&lt;T: Comparable&gt; &#123;    var data: [T]        init(_ array: [T]) &#123;        self.data = array        // 打乱一个数组 shuffle, shuffled        // https://developer.apple.com/documentation/swift/array/2994757-shuffled        data.shuffle()        //sort(&amp;data, lo: 0, hi: data.count - 1)        //quick3Sort(&amp;data, lo: 0, hi: data.count - 1)        data = quicksort(data)    &#125;    // 最经典的切分方式，取第一个元素作为基准    func sort(_ array: inout [T], lo: Int, hi: Int) &#123;        if hi &lt;= lo &#123;            return        &#125;        let j = partition(&amp;array, lo: lo, hi: hi)        sort(&amp;array, lo: lo, hi: j - 1)        sort(&amp;array, lo: j + 1, hi: hi)    &#125;    // 手写 partition 实际上可以使用高级操作符 filter 来直接完成切分    func partition(_ array: inout [T], lo: Int, hi: Int) -&gt; Int &#123;        var i = lo        var j = hi + 1        let v = array[lo]        while true &#123;            i += 1            while array[i] &gt; v &#123;                if i == hi &#123;                    break                &#125;                i += 1            &#125;            j -= 1            while v &gt; array[j] &#123;                if j == lo &#123;                    break                &#125;                j -= 1            &#125;            if i &gt;= j &#123;                break            &#125;            array.swapAt(i, j)        &#125;        array.swapAt(lo, j)        return j    &#125;        // 更简洁的写法    func quicksortHoare(_ a: inout [T], low: Int, high: Int) &#123;        if low &lt; high &#123;            let p = partitionHoare(&amp;a, low: low, high: high)            quicksortHoare(&amp;a, low: low, high: p)            quicksortHoare(&amp;a, low: p + 1, high: high)        &#125;    &#125;        func partitionHoare(_ a: inout [T], low: Int, high: Int) -&gt; Int &#123;        let pivot = a[low]        var i = low - 1        var j = high + 1                while true &#123;            repeat &#123; j -= 1 &#125; while a[j] &gt; pivot            repeat &#123; i += 1 &#125; while a[i] &lt; pivot                        if i &lt; j &#123;                a.swapAt(i, j)            &#125; else &#123;                return j            &#125;        &#125;    &#125;    // 三向切分    func quick3Sort(_ array: inout [T], lo: Int, hi: Int) &#123;        if hi &lt;= lo &#123;            return        &#125;        var lt = lo, i = lo + 1, gt = hi        let v = array[lo]        while i &lt;= gt &#123;            if array[i] &lt; v &#123;                array.swapAt(lt, i)                lt += 1                i += 1            &#125;            else if v &lt; array[i] &#123;                array.swapAt(i, gt)                gt -= 1            &#125;            else &#123;                i += 1            &#125;        &#125;        quick3Sort(&amp;array, lo: lo, hi: lt - 1)        quick3Sort(&amp;array, lo: gt + 1, hi: hi)    &#125;    // 三项切分，利用高级函数，效率并不太高    func quicksort&lt;T: Comparable&gt;(_ a: [T]) -&gt; [T] &#123;        guard a.count &gt; 1 else &#123; return a &#125;                //let pivot = a[a.count/2]        let pivot = a[0]        let less = a.filter &#123; $0 &lt; pivot &#125;        let equal = a.filter &#123; $0 == pivot &#125;        let greater = a.filter &#123; $0 &gt; pivot &#125;                return quicksort(less) + equal + quicksort(greater)    &#125;    // 三向切分，取最后一个元素作为基准    func partitionLomuto&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) -&gt; Int &#123;        let pivot = a[high]                var i = low        for j in low..&lt;high &#123;            if a[j] &lt;= pivot &#123;                (a[i], a[j]) = (a[j], a[i])                i += 1            &#125;        &#125;        (a[i], a[high]) = (a[high], a[i])        return i    &#125;        func quicksortLomuto&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) &#123;        if low &lt; high &#123;            let p = partitionLomuto(&amp;a, low: low, high: high)            quicksortLomuto(&amp;a, low: low, high: p - 1)            quicksortLomuto(&amp;a, low: p + 1, high: high)        &#125;    &#125;    &#125;\n天下第一的快排\n涉及到的 Swift 特性：有几个数组高级操作：\n\nshuffle()\nfilter\n\nshuffle 和 shuffled ，求求你们不要再🦐几把手写那些鬼随机打乱算法了，人家写的好好的，一个直接操作数组，一个返回打乱后的数组。\nfilter 这是个 Swift 4.2+ 增加的新方法，用于直接选出数组中符合某一类条件的元素，返回值是个数组，用在快排里简直爽到飞起，但是应该是现在的 oj 都还不支持这个函数，这个方法和 reduce ， map 都可能是面试中的重点。\n堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 堆和优先队列class Heap&lt;T: Comparable&gt; &#123;    var data = [T]()    var N = 0    init(size: Int) &#123;        data.reserveCapacity(size + 1)    &#125;        func insert(new: T) &#123;        N += 1        data.append(new)        swim(N)    &#125;    // 大元素上浮    func swim(_ k: Int) &#123;        var k = k        while k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] &#123;            // 大节点不断上浮            data.swapAt(k/2, k)            k = k / 2        &#125;    &#125;        // 小元素下沉    func sink(_ k: Int) &#123;        var k = k        while 2*k &lt;= N &#123;            var j = 2 * k            if j &lt; N &amp;&amp; data[j] &lt; data[j+1] &#123;                // 左节点是较小的节点,选择右节点作为新的根结点                j += 1            &#125;            // 如果当前 k 号节点小于其父节点，下沉            guard data[k] &lt; data[j] else &#123; break &#125;            data.swapAt(k, j)            k = j        &#125;    &#125;        func delMax() -&gt; T &#123;        data.swapAt(1, N)        let max = data.remove(at: N)        N -= 1        sink(1)        return max    &#125;&#125;class heapSort &#123;        func sort(_ array: inout [Int]) &#123;        var N = array.count - 1        for k in stride(from: N/2, through: 1, by: -1) &#123;            sink(&amp;array, k, N)        &#125;                while N &gt; 1 &#123;            array.swapAt(1, N)            N -= 1            sink(&amp;array, 1, N)        &#125;    &#125;        // 大元素上浮    func swim(_ data: inout [Int], _ k: Int, _ N: Int) &#123;        var k = k        while k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] &#123;            // 大节点不断上浮            data.swapAt(k/2, k)            k = k / 2        &#125;    &#125;        // 小元素下沉    func sink(_ data: inout [Int], _ k: Int, _ N: Int) &#123;        var k = k        while 2*k &lt;= N &#123;            var j = 2 * k            if j &lt; N &amp;&amp; data[j] &lt; data[j+1] &#123;                // 左节点是较小的节点,选择右节点作为新的根结点                j += 1            &#125;            // 如果当前 k 号节点小于其父节点，下沉            guard data[k] &lt; data[j] else &#123; break &#125;            data.swapAt(k, j)            k = j        &#125;    &#125;&#125;\n堆排序没啥的，基本都说完了。需要注意的就是这里的 for 循环和 python 的相同，不能带什么操作，同时倒序的话，可以用 reserve 或者是 stride 将步长设定为 -1。\nReference总结 Swift 中随机数的使用 -  CocoaChina 苹果开发中文站 - 最热的iPhone开发社区 最热的苹果开发社区 最热的iPad开发社区\n","thumbnail":"https://xkeith.space/static/halo-frontend/images/thumbnail/thumbnail-5.jpg","plink":"https://xkeith.space/post/基于算法的 Swift 学习之路（排序）/"},{"title":"如何速成前端三件套 （HTML）","date":"2019-03-16T13:46:00.000Z","updated":"2019-03-16T11:00:00.005Z","content":"\nHTML那些你不知道的标签&lt;body bgcolor=&quot;yellow&quot;&gt;\n背景颜色用 bgcolor\n&lt;a href=“mailto:xxx@yyy”&gt;\n发邮件用 mailto\n&lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;\n新窗口用 _blank\n&lt;td align=&quot;left&quot;&gt;\n单元格对其用 align\n&lt;select&gt;  &lt;textarea&gt;\n这个不用 input\n&lt;body background=&quot;background.gif&quot;&gt;\n背景图片用 background\n&lt;hr /&gt;\n水平分割线用 hr\n浏览器会自动地在段落的前后添加空行。（&lt;p&gt;是块级元素）\n 应该避免使用下面这些标签和属性：&lt;center&gt;                    定义居中的内容。&lt;font&gt; 和 &lt;basefont&gt;            定义 HTML 字体。&lt;s&gt; 和 &lt;strike&gt;            定义删除线文本&lt;u&gt;                            定义下划线文本align                        定义文本的对齐方式bgcolor                        定义背景颜色color                        定义文本颜色\nstyle=“text-align:center”\n这样居中最帅\n&lt;sub&gt; &amp; &lt; sup&gt;\n文字下标和上标\n&lt;bdo dir=&quot;rtl&quot;&gt; Here is some Hebrew text &lt;/bdo&gt;\n倒序输出文本\n12345678&lt;blockquote&gt;这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。&lt;/blockquote&gt;这是短的引用：&lt;q&gt;这是短的引用。&lt;/q&gt;\n&lt;abbr&gt; 有下划线， &lt;dfn&gt; 是斜体\n::&lt;img&gt; 的 title 是鼠标悬浮显示的文字 , alt 是图片出不来的时候显示的文字::\n1234这是邮件链接：&lt;a href=\"mailto:someone@microsoft.com?subject=Hello%20again\"&gt;发送邮件&lt;/a&gt;&lt;/p&gt;&lt;a href=\"mailto:someone@microsoft.com?cc=someoneelse@microsoft.com&amp;bcc=andsomeoneelse2@microsoft.com&amp;subject=Summer%20Party&amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!\"&gt;发送邮件！&lt;/a&gt;\n使用 %20 来代替单词之间的空格\n&lt;tr&gt; 来换行 &lt;td&gt; 来定义一个单元格 在 &lt;th&gt; 中使用 colspan 或 rowspan 来跨越列或行\n如何应付老式的浏览器如果浏览器压根没法识别&lt;script&gt; 标签，那么 &lt;script&gt;标签所包含的内容将以文本方式显示在页面上。为了避免这种情况发生，你应该将脚本隐藏在注释标签当中。那些老的浏览器（无法识别 &lt;script&gt;标签的浏览器）将忽略这些注释，所以不会将标签的内容显示到页面上。而那些新的浏览器将读懂这些脚本并执行它们，即使代码被嵌套在注释标签内。\n12345&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--document.write(&quot;Hello World!&quot;)//--&gt;&lt;/script&gt;\nURL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。URL 不能包含空格。URL 编码通常使用 + 来替换空格。\n提示：仅仅有 16 种颜色名被 W3C 的 HTML4.0 标准所支持。它们是：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow。\nHTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 &lt;!DOCTYPE&gt; 的用处。&lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。\n&lt;!DOCTYPE html&gt;     是 HTML5 的声明\n在 &lt;input&gt; 中使用 readonly 来规定输入字段为只读 等同于 readonly=&quot;readonly&quot; \ndisabled属性规定输入字段是禁用的。被禁用的元素是不可用和不可点击的。被禁用的元素不会被提交。\n语义元素清楚地向浏览器和开发者描述其意义。非语义元素的例子：&lt;div&gt; 和 &lt;span&gt; - 无法提供关于其内容的信息。语义元素的例子：&lt;form&gt;、&lt;table&gt; 以及 &lt;img&gt; - 清晰地定义其内容。\n那些你必须要知道的东西\nGET 和 POST 的区别\n\n大多数 web 服务器（Apache、Unix）对文件名的大小写敏感：不能以 london.jpg 访问 London.jpg。其他 web 服务器（微软，IIS）对大小写不敏感：能够以 london.jpg 或 London.jpg 访问 London.jpg。如果使用混合大小写，那么您必须保持高度的一致性。如果您从对大小写不敏感的服务器转到一台对大小写敏感的服务器上，这些小错误将破坏您的网站。为了避免这些问题，请始终使用小写文件名（如果可以的话）。\nHTML5HTML5 新元素\nHTML5 增加了如下表单元素：\n\ndatalist\nkeygen\noutput\n\nInternet Explorer 的问题上述方案可用于所有新的 HTML5 元素，但是：注意：Internet Explorer 8 以及更早的版本，不允许对未知元素添加样式。幸运的是，Sjoerd Visscher 创造了 “HTML5 Enabling JavaScript”,”the shiv”：\n\n\n123&lt;!--[if lt IE 9]&gt;  &lt;script src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;\n这段注释会被 IE 9 以下的浏览器理解，并通过这个脚本文件理解 HTML5 里面新增的标记。\n\n\nCanvas and SVG\nSVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。\nCanvas 通过 JavaScript 来绘制 2D 图形。Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。\nCanvas依赖分辨率\n\n不支持事件处理器\n弱的文本渲染能力\n能够以 .png 或 .jpg 格式保存结果图像\n最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n\nSVG不依赖分辨率\n\n支持事件处理器\n最适合带有大型渲染区域的应用程序（比如谷歌地图）\n复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n不适合游戏应用\n\n\n","thumbnail":"https://xkeith.space/static/halo-frontend/images/thumbnail/thumbnail-8.jpg","plink":"https://xkeith.space/post/如何速成前端三件套 （HTML）/"},{"title":"iOS 面试准备","date":"2019-03-15T17:53:03.478Z","updated":"2019-03-15T22:00:00.039Z","content":"\n基础\n可选项和可选链\n字符串\n闭包 (循环引用)\nweak\nGCD\nruntime\nUIControler\n\n语言和核心原理\nSocket \nTCP / IP\n\nxcode 和各种工具\nCarthage\ncocoapods\n\n\nSwift package manger\n\n\nReactNative\n\n\ncocoa 框架\n\n项目\npixel app\necho app\nAlgorithm \n\nReferenceBeijingIamback - 简书\n","thumbnail":"https://xkeith.me/static/halo-frontend/images/thumbnail/thumbnail-5.jpg","plink":"https://xkeith.space/post/iOS 面试准备/"},{"title":"基于算法的 Swift 学习之路（cocoapod 和 Carthage）","date":"2019-03-14T01:40:00.000Z","updated":"2019-03-16T03:00:00.021Z","content":"\n为啥要用包管理工具我们在开发过程中会用到（依赖于）其他第三方库，这些库或框架还有可能依赖于其他库或者框架，手动管理这些库或者框架非常麻烦，首先我们需要下载这些库或者框架，然后还要考虑版本兼容性问题，需要手动导入一些依赖包(ps:想想就够了)，还好有CocoaPods和Carthage工具管理项目依赖关系。\nCocoaPodsCocoaPods支持项目中采用Objective-C或swift语言。::CocoaPods会将第三方库的源代码编译为静态库.a文件或者静态框架.framework文件的形式，并将它们添加到项目中，建立依赖关系。::\n更换 Ruby 源123456gem sources -l (查看当前ruby的源)gem sources --add https://gems.ruby-china.org/ gem sources --remove https://rubygems.org/ gem sources -lsudo gem install cocoapodspod set\n基本使用pod init  来新建 podfile\n编辑项目路径下的 Podfile ，可以通过官网检索依赖包或者使用 pod search 命令。cocoapods 是中心化的包管理工具，因此有些没有收录在 cocoapods 中的依赖将不能从中心库直接引入（如 GitHub 上的部分开源项目），对于这种依赖，我们可以通过手动标注原链接的方式引入：\npod ‘PNChartSwift’,:git =&gt; &#39;git url&#39;\n注意事项123~&gt;3.0  表示大于等于3.0版本，小于下一个主版本，即4.0版本&gt;=3.0  表示大于等于3.0版本==3.0  表示等于3.0版本\n　　Podfile本质上是用来描述Xcode工程中的targets用的。如果我们不显式指定Podfile对应的target，CocoaPods会创建一个名称为default的隐式target，会和我们工程中的第一个target相对应。换句话说，如果在Podfile中没有指定target，那么只有工程里的第一个target能够使用Podfile中描述的Pods依赖库。　　如果想在一个Podfile中同时描述project中的多个target，根据需求的不同，可以有不同的实现方式。现在的project中包含的target有：CocoapodsTest、CocoapodsTestTests、CocoapodsTestUITests。\n如果引入依赖的时候不显示标示依赖库版本，表示每次都获取最新版本\n移除或修改库后，执行pod update   来让更改生效\nPodfile.lock 文件执行完pod install之后，会生成一个Podfile.lock文件，该文件用于保存已经安装的Pods依赖库的版本。\nPodfile.lock文件最大得用处在于多人开发。对于没有在Podfile中指定Pods依赖库版本的写法，如下：pod ‘Reachability’该句话用于获取当前Reachability这个Pods依赖库的最新版本。当团队中的某个人执行完pod install命令后，生成的Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含 Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的Reachability，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案：\n\n更改Podfile，使其指向最新版本的Reachability依赖库；\n执行pod update命令；鉴于Podfile.lock文件对团队协作如此重要，我们建议将它添加到版本管理中。\n\nCarthageCocoaPods已经是一个非常棒的工具了，我们还有另外一个选择——Carthage,它是一个轻量级的项目依赖管理工具。Carthage主张“::去中心化::”和“::非侵入性::”。CocoaPods搭建了一个中心库，第三方库被收入到该中心库，所以没有收录的第三方库是不能使用CocoaPods管理的，这就是所谓的”中心化“思想。而Carthage没有这样的中心库，::第三方库基本上都是从GitHub或者私有git库中下载的，这就是“去中心化”::。另外，CocoaPods下载第三方库后，会将其编译成静态链接库或者动态框架文件，这种做法会修改Xcode项目属性配置依赖关系，这就是所谓的”侵入性“。而Carthage下载成功后，会将第三方库编译为::动态框架::，由开发人员自己配置依赖关系，::Carthage不会修改Xcode项目属性::，这就是所谓的”非侵入性“。\n基本使用\n创建Xcode工程并切换到该工程路径\n创建一个Cartfile，将你想要使用的框架列在里面github “AFNetworking/AFNetworking” ~&gt; 3.0github “rs/SDWebImage”github “github url”\n运行carthage update，将获取依赖文件到一个Carthage.checkout文件夹，然后编译每个依赖\n在你的应用程序target的General设置标签中的Embedded Binaries区域，将框架从Carthage.build文件夹拖拽进去。\n\n注意事项Carthage编译你的依赖，并提供框架的二进制文件，但你仍然保留对项目的结构和设置的完整控制。Carthage不会自动的修改你的项目文件或编译设置。Carthage只正式支持动态框架，动态框架能够在任何版本的OS X上使用，但只能在iOS 8及以上版本使用。\nCocoaPods 和 Carthage 的区别\nCarthage只支持iOS 8及以上版本使用。\n首先，CocoaPods默认会自动创建并更新你的应用程序和所有依赖的Xcode workspace。Carthage使用xcodebuild来编译框架的二进制文件，但如何集成它们将交由用户自己判断。CocoaPods的方法更易于使用，但Carthage更灵活并且是非侵入性的。\nCocoaPods的目标在它的README文件描述如下：…为提高第三方开源库的可见性和参与度，创建一个更中心化的生态系统。与之对照，Carthage创建的是去中心化的依赖管理器。它没有总项目的列表，这能够减少维护工作并且避免任何中心化带来的问题（如中央服务器宕机）。不过，这样也有一些缺点，就是项目的发现将更困难，用户将依赖于Github的趋势页面或者类似的代码库来寻找项目。\nCocoaPods项目同时还必须包含一个podspec文件，里面是项目的一些元数据，以及确定项目的编译方式。Carthage使用xcodebuild来编译依赖，而不是将他们集成进一个workspace，因此无需类似的设定文件。不过依赖需要包含自己的Xcode工程文件来描述如何编译。\n最后，我们创建Carthage的原因是想要一种尽可能简单的工具——一个只关心本职工作的依赖管理器，而不是取代部分Xcode的功能，或者需要让框架作者做一些额外的工作。CocoaPods提供的一些特性很棒，但由于附加的复杂性，它们将不会被包含在Carthage当中。\n\nReference https://www.jianshu.com/p/6c4b1b4a69c5iOS cocoapods 使用以及版本更新 - chrisbin - 博客园CocoaPods和Carthage浅析(新) - 简书\n","thumbnail":"https://xkeith.me/static/halo-frontend/images/thumbnail/thumbnail-9.jpg","plink":"https://xkeith.space/post/arc-01/"},{"title":"About ME","date":"2019-03-17T12:51:09.000Z","updated":"2019-03-17T13:19:41.570Z","content":"keith\n\n这里是 keith 🤒 ，目前就读于大连海事大学。\n超级喜欢海豹！！！\n正在备战秋招…目标是 JIKE， BAT ，还有头条\n目前的主要研发方向是 iOS 和 前端\n无比热爱 Swift 🐶 和 JavaScript 还有 Python \n目前国内的 Swift 社区基本是靠🐮们的博客撑起来的，希望我也能为 Swift 社区添砖加瓦\n希望加入即厂，遇到更多的 Swift 大🐂\n好的产品自有万钧之力，希望我能不流于世俗\n期待任何方面的交流和沟通\n要首先做个有趣的灵魂！\n\n\n","plink":"https://xkeith.space/about/"}]