{"title":"两种 worker： Web worker 和 Service worker","date":"2019-09-15T08:54:38.000Z","thumbnail":"https://i.loli.net/2019/09/15/UPSNVvZJXbKIqoQ.png","color":"#111","link":"post/workers","tags":["workers"],"categories":["浏览器机制"],"updated":"2019-09-15T09:00:00.475Z","content":"<h2 id=\"Web-worker\">Web worker<a href=\"post/workers#Web-worker\"></a></h2><h3 id=\"专用-worker\">专用 worker<a href=\"post/workers#专用-worker\"></a></h3><p>普通生成的 worker 仅能供一个生成该 worker 的脚本使用，如果想要多个文件共享一个 worker 文件，请使用下面的 SharedWorker。<br>主要涉及的 API 实际上只有两个。<br>因为其全双工特性，两个 api 都能用，要注意的地方是 worker 运行在创建的 worker 的一个全局作用域上，因此不需要将事件处理函数再挂载到 worker 对象了，实际上你也找不到这个。直接用就行。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> Worker(<span class=\"string\">'worker.js'</span>)</span><br><span class=\"line\">worker.postMessage(<span class=\"string\">'somedata'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 监听 onmessage 来响应消息</span></span><br><span class=\"line\">worker.onmessage = func...</span><br><span class=\"line\"><span class=\"comment\">// worker 内</span></span><br><span class=\"line\">onmessage = func...</span><br><span class=\"line\"><span class=\"comment\">// 终止 worker 强行杀死进程 不涉及任何场面处理</span></span><br><span class=\"line\">worker.terminate()</span><br><span class=\"line\"><span class=\"comment\">// 错误处理</span></span><br><span class=\"line\">worker.onerror = func...</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"共享-worker\">共享 worker<a href=\"post/workers#共享-worker\"></a></h3><p>一个共享worker可以被多个脚本使用——即使这些脚本正在被不同的window、iframe或者worker访问。<br><strong>注意：</strong>如果共享worker可以被多个浏览上下文调用，所有这些浏览上下文必须属于同源（相同的协议，主机和端口号）。<br>一个非常大的区别在于，与一个共享worker通信必须通过端口对象——一个确切的打开的端口供脚本与worker通信（在专用worker中这一部分是隐式进行的）。<br>在传递消息之前，端口连接必须被显式的打开，打开方式是使用onmessage事件处理函数或者start()方法。<br>start()方法的调用只在一种情况下需要，那就是消息事件被addEventListener()方法使用。<br>首先，当一个端口连接被创建时（例如：在父级线程中，设置onmessage事件处理函数，或者显式调用start()方法时），使用onconnect事件处理函数来执行代码。<br>使用事件的ports属性来获取端口并存储在变量中。<br>然后，为端口添加一个消息处理函数用来做运算并回传结果给主线程。在worker线程中设置此消息处理函数也会隐式的打开与主线程的端口连接，因此这里跟前文一样，对port.start()的调用也是不必要的。<br>主线程不需要特殊处理，跟原来的保持一样就行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 事件监听发生改变</span></span><br><span class=\"line\">onconnect = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> port = e.ports[<span class=\"number\">0</span>];</span><br><span class=\"line\">  port.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> workerResult = <span class=\"string\">'Result: '</span> + (e.data[<span class=\"number\">0</span>] * e.data[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    port.postMessage(workerResult);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"内容安全策略\">内容安全策略<a href=\"post/workers#内容安全策略\"></a></h3><p>有别于创建它的document对象，worker有它自己的执行上下文。因此普遍来说，worker并不受限于创建它的document（或者父级worker）的内容安全策略。我们来举个例子，假设一个document有如下头部声明：</p>\n<p><code>Content-Security-Policy: script-src ‘self’</code></p>\n<p>这个声明有一部分作用在于，禁止它内部包含的脚本代码使用eval()方法。然而，如果脚本代码创建了一个worker，在worker上下文中执行的代码却是可以使用eval()的。<br>为了给worker指定内容安全策略，必须为发送worker代码的请求本身加上一个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\" target=\"_blank\" rel=\"noopener\">内容安全策略</a> 。<br>有一个例外情况，即worker脚本的源如果是一个全局性的唯一的标识符（例如，它的URL指定了数据模式或者blob），worker则会继承创建它的document或者worker的CSP（Content security policy内容安全策略）。</p>\n<h3 id=\"数据发送与接收的实现原理\">数据发送与接收的实现原理<a href=\"post/workers#数据发送与接收的实现原理\"></a></h3><p>在主页面与 worker 之间传递的数据是通过<strong>拷贝</strong>，而不是共享来完成的。传递给worker的对象需要经过序列化，接下来在另一端还需要反序列化。页面与worker<strong>不会共享同一个实例，</strong>最终的结果就是在每次通信结束时生成了数据的<strong>一个副本。</strong>大部分浏览器使用 <a href=\"https://developer.mozilla.org/en/DOM/The_structured_clone_algorithm\" target=\"_blank\" rel=\"noopener\">结构化拷贝</a> 来实现该特性。<br>如果详细探寻结构化拷贝的原理，你会发现这个其实就是你熟悉的深拷贝的实现，通过递归来拷贝对象，通过保存拷贝过的变量来解决循环引用，同时对于一些特殊对象专门处理了一下。</p>\n<p><strong>通过转让所有权（可转让对象）来传递数据</strong></p>\n<p>部分浏览器通过一种性能更高的方法来转移特定类型的对象如 (ArrayBuffer) 。可转让对象可以从一个上下文对象直接转让到另外一个而不经过任何拷贝动作，之前上下文的那个版本将不复存在。类似于其他语言中的引用传递，对象会毫无保留的转移到另外一个上下文中。</p>\n<h2 id=\"Service-worker\">Service worker<a href=\"post/workers#Service-worker\"></a></h2><h3 id=\"特性\">特性<a href=\"post/workers#特性\"></a></h3><p><code>install -&gt; installed -&gt; actvating -&gt; Active -&gt; Activated -&gt; Redundant</code></p>\n<ul>\n<li>离线缓存（使用 cache API 不支持的版本可以用 IndexDB）</li>\n<li>监听和拦截所有的 HTTP 请求 （代理 fetch，缓存优先，降级处理）</li>\n<li>消息推送</li>\n<li>静默更新（当有新版本的缓存文件的时候，会安装更新版本，但是并不会立即更新应用，当不再有任何已加载的页面在使用旧版的 service worker 的时候，新版本才会激活。可以通过 <code>skipWaiting</code> 跳过 waiting 状态。通过 activate 事件可以清除旧的版本的缓存）</li>\n</ul>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/09/15/9rtKPwhLHOzJkG6.png\" alt=\"9rtKPwhLHOzJkG6.png\" data-zoomable></p></div>\n<h2 id=\"Reference\">Reference<a href=\"post/workers#Reference\"></a></h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers\" target=\"_blank\" rel=\"noopener\">使用 Web Workers - Web API 接口参考 | MDN</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/The_structured_clone_algorithm\" target=\"_blank\" rel=\"noopener\">结构化克隆算法 - Web 开发者指南 | MDN</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers\" target=\"_blank\" rel=\"noopener\">Web Workers可以使用的函数和类 - Web API 接口参考 | MDN</a><br><a href=\"https://html.spec.whatwg.org/multipage/structured-data.html#transferable-objects\" target=\"_blank\" rel=\"noopener\">HTML Standard</a><br><a href=\"http://lzw.me/a/pwa-service-worker.html\" target=\"_blank\" rel=\"noopener\">网站渐进式增强体验(PWA)改造：Service Worker 应用详解 - 志文工作室</a><br><a href=\"https://create-react-app.dev/docs/making-a-progressive-web-app\" target=\"_blank\" rel=\"noopener\">Making a Progressive Web App · Create React App</a></p>\n","next":{"title":"HTTP 1.1 & HTTP 2.0 & SPDY & QUIC","link":"post/newHttp"},"plink":"https://xkeith.space/post/workers/","toc":[{"title":"Web worker","id":"Web-worker","index":"1","children":[{"title":"专用 worker","id":"专用-worker","index":"1.1"},{"title":"共享 worker","id":"共享-worker","index":"1.2"},{"title":"内容安全策略","id":"内容安全策略","index":"1.3"},{"title":"数据发送与接收的实现原理","id":"数据发送与接收的实现原理","index":"1.4"}]},{"title":"Service worker","id":"Service-worker","index":"2","children":[{"title":"特性","id":"特性","index":"2.1"}]},{"title":"Reference","id":"Reference","index":"3"}]}