{"title":"基于算法的 Swift 学习之路（cocoapod 和 Carthage）","date":"2019-03-14T01:40:00.000Z","thumbnail":"https://xkeith.me/static/halo-frontend/images/thumbnail/thumbnail-9.jpg","link":"post/arc-01","tags":["Swift"],"categories":["iOS & Swift"],"updated":"2019-03-16T03:00:00.021Z","content":"<hr>\n<h2 id=\"为啥要用包管理工具\">为啥要用包管理工具<a href=\"post/arc-01#为啥要用包管理工具\"></a></h2><p>我们在开发过程中会用到（依赖于）其他第三方库，这些库或框架还有可能依赖于其他库或者框架，手动管理这些库或者框架非常麻烦，首先我们需要下载这些库或者框架，然后还要考虑版本兼容性问题，需要手动导入一些依赖包(ps:想想就够了)，还好有CocoaPods和Carthage工具管理项目依赖关系。</p>\n<h2 id=\"CocoaPods\">CocoaPods<a href=\"post/arc-01#CocoaPods\"></a></h2><p>CocoaPods支持项目中采用Objective-C或swift语言。::CocoaPods会将第三方库的源代码编译为静态库.a文件或者静态框架.framework文件的形式，并将它们添加到项目中，建立依赖关系。::</p>\n<h3 id=\"更换-Ruby-源\">更换 Ruby 源<a href=\"post/arc-01#更换-Ruby-源\"></a></h3><figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gem sources -l (查看当前ruby的源)</span><br><span class=\"line\">gem sources --add https://gems.ruby-china.org/</span><br><span class=\"line\"> gem sources --remove https://rubygems.org/</span><br><span class=\"line\"> gem sources -l</span><br><span class=\"line\">sudo gem install cocoapods</span><br><span class=\"line\">pod set</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"基本使用\">基本使用<a href=\"post/arc-01#基本使用\"></a></h3><p><code>pod init</code>  来新建 podfile</p>\n<p>编辑项目路径下的 Podfile ，可以通过官网检索依赖包或者使用 pod search 命令。<br>cocoapods 是中心化的包管理工具，因此有些没有收录在 cocoapods 中的依赖将不能从中心库直接引入（如 GitHub 上的部分开源项目），对于这种依赖，我们可以通过手动标注原链接的方式引入：</p>\n<p><code>pod ‘PNChartSwift’,:git =&gt; &#39;git url&#39;</code></p>\n<h3 id=\"注意事项\">注意事项<a href=\"post/arc-01#注意事项\"></a></h3><figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~&gt;3.0  表示大于等于3.0版本，小于下一个主版本，即4.0版本</span><br><span class=\"line\">&gt;=3.0  表示大于等于3.0版本</span><br><span class=\"line\">==3.0  表示等于3.0版本</span><br></pre></td></tr></table></div></figure>\n<p>　　Podfile本质上是用来描述Xcode工程中的targets用的。如果我们不显式指定Podfile对应的target，CocoaPods会创建一个名称为default的隐式target，会和我们工程中的第一个target相对应。换句话说，如果在Podfile中没有指定target，那么只有工程里的第一个target能够使用Podfile中描述的Pods依赖库。<br>　　如果想在一个Podfile中同时描述project中的多个target，根据需求的不同，可以有不同的实现方式。现在的project中包含的target有：CocoapodsTest、CocoapodsTestTests、CocoapodsTestUITests。</p>\n<p>如果引入依赖的时候不显示标示依赖库版本，表示每次都获取最新版本</p>\n<p>移除或修改库后，执行<br><code>pod update</code>   来让更改生效</p>\n<p>Podfile.lock 文件<br>执行完pod install之后，会生成一个Podfile.lock文件，该文件用于保存已经安装的Pods依赖库的版本。</p>\n<p>Podfile.lock文件最大得用处在于多人开发。对于没有在Podfile中指定Pods依赖库版本的写法，如下：<br><code>pod ‘Reachability’</code><br>该句话用于获取当前Reachability这个Pods依赖库的最新版本。<br>当团队中的某个人执行完pod install命令后，生成的Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含 Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的Reachability，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！<br>在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案：</p>\n<ul>\n<li>更改Podfile，使其指向最新版本的Reachability依赖库；</li>\n<li>执行pod update命令；<br>鉴于Podfile.lock文件对团队协作如此重要，我们建议将它添加到版本管理中。</li>\n</ul>\n<h2 id=\"Carthage\">Carthage<a href=\"post/arc-01#Carthage\"></a></h2><p>CocoaPods已经是一个非常棒的工具了，我们还有另外一个选择——Carthage,它是一个轻量级的项目依赖管理工具。Carthage主张“::去中心化::”和“::非侵入性::”。CocoaPods搭建了一个中心库，第三方库被收入到该中心库，所以没有收录的第三方库是不能使用CocoaPods管理的，这就是所谓的”中心化“思想。而Carthage没有这样的中心库，::第三方库基本上都是从GitHub或者私有git库中下载的，这就是“去中心化”::。另外，CocoaPods下载第三方库后，会将其编译成静态链接库或者动态框架文件，这种做法会修改Xcode项目属性配置依赖关系，这就是所谓的”侵入性“。而Carthage下载成功后，会将第三方库编译为::动态框架::，由开发人员自己配置依赖关系，::Carthage不会修改Xcode项目属性::，这就是所谓的”非侵入性“。</p>\n<h3 id=\"基本使用-1\">基本使用<a href=\"post/arc-01#基本使用-1\"></a></h3><ol>\n<li>创建Xcode工程并切换到该工程路径</li>\n<li>创建一个Cartfile，将你想要使用的框架列在里面<br>github “AFNetworking/AFNetworking” ~&gt; 3.0<br>github “rs/SDWebImage”<br>github “github url”</li>\n<li>运行carthage update，将获取依赖文件到一个Carthage.checkout文件夹，然后编译每个依赖</li>\n<li>在你的应用程序target的General设置标签中的Embedded Binaries区域，将框架从Carthage.build文件夹拖拽进去。</li>\n</ol>\n<h3 id=\"注意事项-1\">注意事项<a href=\"post/arc-01#注意事项-1\"></a></h3><p>Carthage编译你的依赖，并提供框架的二进制文件，但你仍然保留对项目的结构和设置的完整控制。Carthage不会自动的修改你的项目文件或编译设置。<br><strong>Carthage只正式支持动态框架，动态框架能够在任何版本的OS X上使用，但只能在iOS 8及以上版本使用。</strong></p>\n<h2 id=\"CocoaPods-和-Carthage-的区别\">CocoaPods 和 Carthage 的区别<a href=\"post/arc-01#CocoaPods-和-Carthage-的区别\"></a></h2><ol>\n<li>Carthage只支持iOS 8及以上版本使用。</li>\n<li>首先，CocoaPods默认会自动创建并更新你的应用程序和所有依赖的Xcode workspace。Carthage使用xcodebuild来编译框架的二进制文件，但如何集成它们将交由用户自己判断。CocoaPods的方法更易于使用，但Carthage更灵活并且是非侵入性的。</li>\n<li>CocoaPods的目标在它的README文件描述如下：<br>…为提高第三方开源库的可见性和参与度，创建一个更中心化的生态系统。<br>与之对照，Carthage创建的是去中心化的依赖管理器。它没有总项目的列表，这能够减少维护工作并且避免任何中心化带来的问题（如中央服务器宕机）。不过，这样也有一些缺点，就是项目的发现将更困难，用户将依赖于Github的趋势页面或者类似的代码库来寻找项目。</li>\n<li>CocoaPods项目同时还必须包含一个podspec文件，里面是项目的一些元数据，以及确定项目的编译方式。Carthage使用xcodebuild来编译依赖，而不是将他们集成进一个workspace，因此无需类似的设定文件。不过依赖需要包含自己的Xcode工程文件来描述如何编译。</li>\n<li>最后，我们创建Carthage的原因是想要一种尽可能简单的工具——一个只关心本职工作的依赖管理器，而不是取代部分Xcode的功能，或者需要让框架作者做一些额外的工作。CocoaPods提供的一些特性很棒，但由于附加的复杂性，它们将不会被包含在Carthage当中。</li>\n</ol>\n<h2 id=\"Reference\">Reference<a href=\"post/arc-01#Reference\"></a></h2><p> <a href=\"https://www.jianshu.com/p/6c4b1b4a69c5\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/6c4b1b4a69c5</a><br><a href=\"https://www.cnblogs.com/chrisbin/p/5413777.html\" target=\"_blank\" rel=\"noopener\">iOS cocoapods 使用以及版本更新 - chrisbin - 博客园</a><br><a href=\"https://www.jianshu.com/p/9d0885f944e3\" target=\"_blank\" rel=\"noopener\">CocoaPods和Carthage浅析(新) - 简书</a></p>\n","prev":{"title":"iOS 面试准备","link":"post/iOS 面试准备"},"plink":"https://xkeith.space/post/arc-01/","toc":[{"title":"为啥要用包管理工具","id":"为啥要用包管理工具","index":"1"},{"title":"CocoaPods","id":"CocoaPods","index":"2","children":[{"title":"更换 Ruby 源","id":"更换-Ruby-源","index":"2.1"},{"title":"基本使用","id":"基本使用","index":"2.2"},{"title":"注意事项","id":"注意事项","index":"2.3"}]},{"title":"Carthage","id":"Carthage","index":"3","children":[{"title":"基本使用","id":"基本使用-1","index":"3.1"},{"title":"注意事项","id":"注意事项-1","index":"3.2"}]},{"title":"CocoaPods 和 Carthage 的区别","id":"CocoaPods-和-Carthage-的区别","index":"4"},{"title":"Reference","id":"Reference","index":"5"}]}