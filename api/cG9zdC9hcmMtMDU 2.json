{"title":"Vue 高级（Vue Router 基础）","date":"2019-03-21T14:07:11.000Z","link":"post/arc-05","tags":["front_end"],"categories":["前端"],"updated":"2019-03-21T14:08:59.763Z","content":"<hr>\n<h2 id=\"动态路由匹配\">动态路由匹配<a href=\"post/arc-05#动态路由匹配\"></a></h2><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个User组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/21/5c939acf2a6c6.png\" alt=\"5c939acf2a6c6.png\" data-zoomable></p></div>\n<h3 id=\"响应路由参数的变化\">响应路由参数的变化<a href=\"post/arc-05#响应路由参数的变化\"></a></h3><blockquote>\n<p>这就是为什么 PixelStack 不会刷新，早看了这个早就刷新了。😂  </p>\n</blockquote>\n<p>提醒一下，当使用路由参数时，例如从/user/foo导航到/user/bar，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。<br>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化)$route对象：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> User = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'...'</span>,</span><br><span class=\"line\">  watch: &#123;</span><br><span class=\"line\">    <span class=\"string\">'$route'</span> (to, <span class=\"keyword\">from</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 对路由变化作出响应...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>或者使用 2.2 版本中引入的导航守卫</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> User = &#123;</span><br><span class=\"line\">  template: <span class=\"string\">'...'</span>,</span><br><span class=\"line\">  beforeRouteUpdate (to, <span class=\"keyword\">from</span>, next) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// react to route changes...</span></span><br><span class=\"line\">    <span class=\"comment\">// don't forget to call next()</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"捕获所有路由或-404-Not-found-路由\">捕获所有路由或 404 Not found 路由<a href=\"post/arc-05#捕获所有路由或-404-Not-found-路由\"></a></h3><p>常规参数只会匹配被/分隔的 URL 片段中的字符。如果想匹配<strong>任意路径</strong>，我们可以使用通配符 (*)：</p>\n<p>当使用<em>通配符</em>路由时，请确保路由的顺序是正确的，也就是说含有<strong>通配符</strong>的路由应该放在最后。路由{ path: ‘<em>’ }通常用于客户端 404 错误。如果你使用了<strong>History 模式</strong>，请确保 <a href=\"https://router.vuejs.org/zh/guide/essentials/history-mode.html\" target=\"_blank\" rel=\"noopener\">正确配置你的服务器</a> 。<br>当使用一个</em>通配符<em>时，$route.params内会自动添加一个名为pathMatch参数。它包含了 URL 通过</em>通配符*被匹配的部分：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给出一个路由 &#123; path: '/user-*' &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/user-admin'</span>)</span><br><span class=\"line\"><span class=\"keyword\">this</span>.$route.params.pathMatch <span class=\"comment\">// 'admin'</span></span><br><span class=\"line\"><span class=\"comment\">// 给出一个路由 &#123; path: '*' &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$router.push(<span class=\"string\">'/non-existing'</span>)</span><br><span class=\"line\"><span class=\"keyword\">this</span>.$route.params.pathMatch <span class=\"comment\">// '/non-existing'</span></span><br></pre></td></tr></table></div></figure>\n<h3 id=\"高级匹配模式\">高级匹配模式<a href=\"post/arc-05#高级匹配模式\"></a></h3><p>vue-router使用 <a href=\"https://github.com/pillarjs/path-to-regexp\" target=\"_blank\" rel=\"noopener\">path-to-regexp</a> 作为路径匹配引擎，所以支持很多高级的匹配模式，例如：可选的动态路径参数、匹配零个或多个、一个或多个，甚至是自定义正则匹配。查看它的 <a href=\"https://github.com/pillarjs/path-to-regexp#parameters\" target=\"_blank\" rel=\"noopener\">文档</a> 学习高阶的路径匹配，还有 <a href=\"https://github.com/vuejs/vue-router/blob/dev/examples/route-matching/app.js\" target=\"_blank\" rel=\"noopener\">这个例子</a> 展示vue-router怎么使用这类匹配。</p>\n<h3 id=\"匹配优先级\">匹配优先级<a href=\"post/arc-05#匹配优先级\"></a></h3><p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>\n<h2 id=\"嵌套路由\">嵌套路由<a href=\"post/arc-05#嵌套路由\"></a></h2><p>要在嵌套的出口中渲染组件，需要在VueRouter的参数中使用children配置：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123; <span class=\"attr\">path</span>: <span class=\"string\">'/user/:id'</span>, <span class=\"attr\">component</span>: User,</span><br><span class=\"line\">      children: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 当 /user/:id/profile 匹配成功，</span></span><br><span class=\"line\">          <span class=\"comment\">// UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class=\"line\">          path: <span class=\"string\">'profile'</span>,</span><br><span class=\"line\">          component: UserProfile</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 当 /user/:id/posts 匹配成功</span></span><br><span class=\"line\">          <span class=\"comment\">// UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class=\"line\">          path: <span class=\"string\">'posts'</span>,</span><br><span class=\"line\">          component: UserPosts</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p><strong>要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。</strong><br>你会发现，children配置就是像routes配置一样的路由配置数组，所以呢，你可以嵌套多层路由。<br>此时，基于上面的配置，当你访问/user/foo时，User的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/user/:id'</span>, <span class=\"attr\">component</span>: User,</span><br><span class=\"line\">      children: [</span><br><span class=\"line\">        <span class=\"comment\">// 当 /user/:id 匹配成功，</span></span><br><span class=\"line\">        <span class=\"comment\">// UserHome 会被渲染在 User 的 &lt;router-view&gt; 中</span></span><br><span class=\"line\">        &#123; <span class=\"attr\">path</span>: <span class=\"string\">''</span>, <span class=\"attr\">component</span>: UserHome &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// ...其他子路由</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"编程式的导航\">编程式的导航<a href=\"post/arc-05#编程式的导航\"></a></h2><p>除了使用 <router-link> 标签来定义导航连接，我们还可以借助 router 的实例方法，通过编写代码来实现。<br>常用的方法有三个</router-link></p>\n<p><code>router.push(location, onComplete?, onAbort?)</code></p>\n<p>想要导航到不同的 URL，则使用router.push方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。<br>当你点击<router-link>时，这个方法会在内部调用，所以说，点击<router-link :to=\"“…”\">等同于调用router.push(…)。<br>该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：</router-link></router-link></p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串</span></span><br><span class=\"line\">router.push(<span class=\"string\">'home'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'home'</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 命名的路由</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'user'</span>, <span class=\"attr\">params</span>: &#123; <span class=\"attr\">userId</span>: <span class=\"string\">'123'</span> &#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带查询参数，变成 /register?plan=private</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'register'</span>, <span class=\"attr\">query</span>: &#123; <span class=\"attr\">plan</span>: <span class=\"string\">'private'</span> &#125;&#125;)</span><br></pre></td></tr></table></div></figure>\n<p><strong>注意：如果提供了path，params会被忽略，上述例子中的query并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的name或手写完整的带有参数的path：</strong></p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> userId = <span class=\"string\">'123'</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">name</span>: <span class=\"string\">'user'</span>, <span class=\"attr\">params</span>: &#123; userId &#125;&#125;) <span class=\"comment\">// -&gt; /user/123</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">`/user/<span class=\"subst\">$&#123;userId&#125;</span>`</span> &#125;) <span class=\"comment\">// -&gt; /user/123</span></span><br><span class=\"line\"><span class=\"comment\">// 这里的 params 不生效</span></span><br><span class=\"line\">router.push(&#123; <span class=\"attr\">path</span>: <span class=\"string\">'/user'</span>, <span class=\"attr\">params</span>: &#123; userId &#125;&#125;) <span class=\"comment\">// -&gt; /user</span></span><br></pre></td></tr></table></div></figure>\n<p>同样的规则也适用于router-link组件的to属性。<br>在 2.2.0+，可选的在router.push或router.replace中提供onComplete和onAbort回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。<br><strong>注意</strong>： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个/users/1-&gt;/users/2)，你需要使用 <a href=\"https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96\" target=\"_blank\" rel=\"noopener\">beforeRouteUpdate</a> 来响应这个变化 (比如抓取用户信息)。</p>\n<p><code>router.replace(location, onComplete?, onAbort?)</code></p>\n<p>跟router.push很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>\n<p><code>router.go(n)</code></p>\n<p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似window.history.go(n)。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class=\"line\">router.go(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后退一步记录，等同于 history.back()</span></span><br><span class=\"line\">router.go(<span class=\"number\">-1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 前进 3 步记录</span></span><br><span class=\"line\">router.go(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class=\"line\">router.go(<span class=\"number\">-100</span>)</span><br><span class=\"line\">router.go(<span class=\"number\">100</span>)</span><br></pre></td></tr></table></div></figure>\n<p> 你也许注意到router.push 、router.replace 和router.go跟 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History\" target=\"_blank\" rel=\"noopener\">window.history.pushState、window.history.replaceState和window.history.go</a>  好像， 实际上它们确实是效仿window.historyAPI 的。<br>因此，如果你已经熟悉Browser History APIs <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API\" target=\"_blank\" rel=\"noopener\">Browser History APIs</a>，那么在 Vue Router 中操作 history 就是超级简单的。还有值得提及的，Vue Router 的导航方法 (push、replace 、go ) 在各类路由模式 (history 、hash和abstract ) 下表现一致。</p>\n<h2 id=\"重定向和别名\">重定向和别名<a href=\"post/arc-05#重定向和别名\"></a></h2><p>重定向也是通过routes配置来完成，下面例子是从/a重定向到/b：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    \t&#123; <span class=\"attr\">path</span>: <span class=\"string\">'/a'</span>, <span class=\"attr\">redirect</span>: <span class=\"string\">'/b'</span> &#125;,</span><br><span class=\"line\">\t\t&#123; <span class=\"attr\">path</span>: <span class=\"string\">'/a'</span>, <span class=\"attr\">redirect</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">'foo'</span> &#125;&#125;,</span><br><span class=\"line\">    \t&#123; <span class=\"attr\">path</span>: <span class=\"string\">'/a'</span>, <span class=\"attr\">redirect</span>: <span class=\"function\"><span class=\"params\">to</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 方法接收 目标路由 作为参数</span></span><br><span class=\"line\">      <span class=\"comment\">// return 重定向的 字符串路径/路径对象</span></span><br><span class=\"line\">    \t&#125;&#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<p><strong>注意，导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上，在这个例子中，为 /a 路由添加beforeEach 或 beforeLeave 守卫并不会有任何效果。</strong></p>\n<h2 id=\"路由组件传参\">路由组件传参<a href=\"post/arc-05#路由组件传参\"></a></h2><p>在组件中使用$route会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。</p>\n<p><strong>我们可以使用 props 将其接耦</strong></p>\n<p>如果<code>rops</code>被设置为<code>true</code> ，<code>route.params</code> 将会被设置为组件属性。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> User = &#123;</span><br><span class=\"line\">  props: [<span class=\"string\">'id'</span>],</span><br><span class=\"line\">  template: <span class=\"string\">'&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123; <span class=\"attr\">path</span>: <span class=\"string\">'/user/:id'</span>, <span class=\"attr\">component</span>: User, <span class=\"attr\">props</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: <span class=\"string\">'/user/:id'</span>,</span><br><span class=\"line\">      components: &#123; <span class=\"attr\">default</span>: User, <span class=\"attr\">sidebar</span>: Sidebar &#125;,</span><br><span class=\"line\">      props: &#123; <span class=\"attr\">default</span>: <span class=\"literal\">true</span>, <span class=\"attr\">sidebar</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"HTML-5-History-模式\">HTML 5 History 模式<a href=\"post/arc-05#HTML-5-History-模式\"></a></h2><div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/21/5c939ae26be08.png\" alt=\"5c939ae26be08.png\" data-zoomable></p></div>\n","prev":{"title":"正则表达式详解（JavaScript 描述）","link":"post/arc-06"},"next":{"title":"TCP or UDP ?","link":"post/arc-04"},"plink":"https://xkeith.space/post/arc-05/","toc":[{"title":"动态路由匹配","id":"动态路由匹配","index":"1","children":[{"title":"响应路由参数的变化","id":"响应路由参数的变化","index":"1.1"},{"title":"捕获所有路由或 404 Not found 路由","id":"捕获所有路由或-404-Not-found-路由","index":"1.2"},{"title":"高级匹配模式","id":"高级匹配模式","index":"1.3"},{"title":"匹配优先级","id":"匹配优先级","index":"1.4"}]},{"title":"嵌套路由","id":"嵌套路由","index":"2"},{"title":"编程式的导航","id":"编程式的导航","index":"3"},{"title":"重定向和别名","id":"重定向和别名","index":"4"},{"title":"路由组件传参","id":"路由组件传参","index":"5"},{"title":"HTML 5 History 模式","id":"HTML-5-History-模式","index":"6"}]}