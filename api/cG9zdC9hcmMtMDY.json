{"title":"正则表达式详解（JavaScript 描述）","date":"2019-03-22T13:15:04.000Z","link":"post/arc-06","tags":["front_end"],"categories":["前端"],"updated":"2019-04-25T08:38:07.878Z","content":"<hr>\n<h2 id=\"元字符\">元字符<a href=\"post/arc-06#元字符\"></a></h2><p><code>\\s</code>匹配~任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等~。<code>\\w</code>匹配~字母或数字或下划线或汉字~。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/22/5c94e01429ebc.png\" alt=\"5c94e01429ebc.png\" data-zoomable></p></div>\n<p>一些🌰：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\ba\\w*\\b\t</span><br><span class=\"line\">匹配以字母a开头的单词——先是某个单词开始处(\\b)，</span><br><span class=\"line\">然后是字母a,然后是任意数量的字母或数字(\\w*)，最后是单词结束处(\\b)。</span><br><span class=\"line\"></span><br><span class=\"line\">\\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，</span><br><span class=\"line\">不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。</span><br><span class=\"line\">\\b\\w&#123;6&#125;\\b匹配刚好6个字符的单词。</span><br></pre></td></tr></table></div></figure>\n<p>元字符<code>^</code>（和数字6在同一个键位上的符号）和<code>$</code>都匹配一个位置，这和<code>\\b</code>有点类似。<code>^</code>匹配你要用来查找的字符串的开头，<code>$</code>匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：<code>^\\d{5,12}$</code>。<br>这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配~只能不多不少重复2次~，{5,12}则是~重复的次数不能少于5次，不能多于12次~，否则都不匹配。<br>因为使用了<code>^</code>和<code>$</code>，所以输入的整个字符串都要用来和<code>\\d{5,12}</code>来匹配，也就是说整个输入~必须是5到12个数字~，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。<br>和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了~匹配行的开始处和结束处~。</p>\n<h2 id=\"字符转义\">字符转义<a href=\"post/arc-06#字符转义\"></a></h2><p>如果你想查找元字符本身的话，比如你查找<code>.</code>,或者<code>*</code>,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用<code>\\</code>来取消这些字符的特殊意义。因此，你应该使用<code>\\.</code>和<code>\\*</code>。当然，要查找<code>\\</code>本身，你也得用<code>\\\\</code>.<br>例如：<code>deerchao\\.net</code>匹配<code>deerchao.net</code>，<code>C:\\\\Windows</code>匹配<code>C:\\Windows</code>。</p>\n<h2 id=\"重复\">重复<a href=\"post/arc-06#重复\"></a></h2><div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/22/5c94e03461c13.png\" alt=\"5c94e03461c13.png\" data-zoomable></p></div>\n<h2 id=\"字符类\">字符类<a href=\"post/arc-06#字符类\"></a></h2><p>字符类用于匹配没有预定义元字符的字符集合。<br>使用方括号来表示一个字符类。<br>举几个🌰：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。</span><br><span class=\"line\">[0-9]代表的含意与\\d就是完全一致的：一位数字；</span><br><span class=\"line\">同理[a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）。</span><br><span class=\"line\"></span><br><span class=\"line\">一个更复杂的表达式：\\(?0\\d&#123;2&#125;[) -]?\\d&#123;8&#125;。</span><br><span class=\"line\">这个表达式可以匹配几种格式的电话号码，</span><br><span class=\"line\">像(010)88886666，或022-22334455，或02912345678等。</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"分枝条件\">分枝条件<a href=\"post/arc-06#分枝条件\"></a></h2><p>分枝条件类似于逻辑运算中的或，只要满足一种规则都应匹配。<br>使用 <code>|</code> 来把不同的规则分隔开。<br>举几个🌰：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0\\d&#123;2&#125;-\\d&#123;8&#125;|0\\d&#123;3&#125;-\\d&#123;7&#125;这个表达式能匹配两种以连字号分隔的电话号码：</span><br><span class=\"line\">一种是三位区号，8位本地号(如010-12345678)，</span><br><span class=\"line\">一种是4位区号，7位本地号(0376-2233445)。</span><br><span class=\"line\">\\(0\\d&#123;2&#125;\\)[- ]?\\d&#123;8&#125;|0\\d&#123;2&#125;[- ]?\\d&#123;8&#125;这个表达式匹配3位区号的电话号码，</span><br><span class=\"line\">其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，</span><br><span class=\"line\">也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。</span><br><span class=\"line\">\\d&#123;5&#125;-\\d&#123;4&#125;|\\d&#123;5&#125;这个表达式用于匹配美国的邮政编码。</span><br><span class=\"line\">美国邮编的规则是5位数字，或者用连字号间隔的9位数字。</span><br></pre></td></tr></table></div></figure>\n<p><strong>最后一个例子能说明一个问题</strong>：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\\d{5}|\\d{5}-\\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p>\n<h2 id=\"分组\">分组<a href=\"post/arc-06#分组\"></a></h2><p>使用分组来重复多个字符。分组可以被后向引用，也可以被部分编程语言直接提取使用。<br>使用小括号来指定一个分组。<br>举几个🌰：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(\\d&#123;1,3&#125;\\.)&#123;3&#125;\\d&#123;1,3&#125;是一个简单的IP地址匹配表达式。</span><br><span class=\"line\">要理解这个表达式，请按下列顺序分析它：</span><br><span class=\"line\">\\d&#123;1,3&#125;匹配1到3位的数字，(\\d&#123;1,3&#125;\\.)&#123;3&#125;</span><br><span class=\"line\">匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，</span><br><span class=\"line\">最后再加上一个一到三位的数字(\\d&#123;1,3&#125;)。</span><br><span class=\"line\">不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。</span><br><span class=\"line\">如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，</span><br><span class=\"line\">所以只能使用冗长的分组，</span><br><span class=\"line\">选择，字符类来描述一个正确的IP地址：</span><br><span class=\"line\">((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)。</span><br></pre></td></tr></table></figure></p>\n<p><strong>这里请彻底理解</strong> <code>2[0-4]\\d|25[0-5]|[01]?\\d\\d?</code></p>\n<h2 id=\"反义\">反义<a href=\"post/arc-06#反义\"></a></h2><p>反义元字符用来查找不属于定义的字符类的字符，常常是元字符的大写。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/22/5c94e04bc4f55.png\" alt=\"5c94e04bc4f55.png\" data-zoomable></p></div>\n<h2 id=\"后向引用\">后向引用<a href=\"post/arc-06#后向引用\"></a></h2><p>使用小括号分组一个表达式后，匹配这个表达式的文本，也就是分组捕获的内容，可以在表达式或其他程序中做进一步的处理。<br>默认每个分组拥有一个组号，从左向右，第一个分组组号为 1，以此类推。<br>后向引用可以用于重复搜索前面某个分组匹配的文本，而不用重写那些冗长的规则。<br>举几个🌰：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。</span><br><span class=\"line\">这个表达式首先是一个单词，</span><br><span class=\"line\">也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，</span><br><span class=\"line\">然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容</span><br><span class=\"line\">（也就是前面匹配的那个单词）(\\1)。</span><br><span class=\"line\"></span><br><span class=\"line\">你也可以自己指定子表达式的组名。要指定一个子表达式的组名，</span><br><span class=\"line\">请使用这样的语法：(?&lt;Word&gt;\\w+)(或者把尖括号换成&apos;也行：(?&apos;Word&apos;\\w+)),</span><br><span class=\"line\">这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k&lt;Word&gt;,所以上一个例子也可以写成这样：</span><br><span class=\"line\">\\b(?&lt;Word&gt;\\w+)\\b\\s+\\k&lt;Word&gt;\\b。</span><br></pre></td></tr></table></div></figure>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/22/5c94e055eae65.png\" alt=\"5c94e055eae65.png\" data-zoomable></p></div>\n<h2 id=\"零宽断言\">零宽断言<a href=\"post/arc-06#零宽断言\"></a></h2><p>接下来的四个断言用于查找在某些内容（不包括这些内容）之前或之后的东西。<br>之所以叫做断言，是因为他们给出了匹配位置应该满足的条件。<br><strong>注意，什么是位置匹配，这些字符并不匹配任何字符，他们匹配的是满足响应条件的位置，我们可以把位置看成是任意两个字符之间的空字符。断言是很典型的用来位置匹配的表达式。</strong></p>\n<p>ES5 中共有 6 个锚字符<br><code>^    $    \\b    \\B    (?=p)    (?!p)</code> </p>\n<h3 id=\"正向零宽断言\">正向零宽断言<a href=\"post/arc-06#正向零宽断言\"></a></h3><p><strong>零宽度正预测先行断言</strong></p>\n<p><code>(?=exp)</code></p>\n<p>它断言自身出现的位置的后边能匹配表达式 exp 。<br>举个🌰：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\b\\w+(?=ing\\b)，匹配以ing结尾的单词的前面部分</span><br><span class=\"line\">(除了ing以外的部分)，</span><br><span class=\"line\">如查找I&apos;m singing while you&apos;re dancing.时，</span><br><span class=\"line\">它会匹配sing和danc。</span><br></pre></td></tr></table></div></figure>\n<p><strong>零宽度正回顾后发断言</strong></p>\n<p><code>(?&lt;=exp)</code></p>\n<p>它断言自身出现的位置的前面能匹配表达式 exp。<br>举个🌰：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?&lt;=\\bre)\\w+\\b会匹配以re开头的单词的后半部分</span><br><span class=\"line\">(除了re以外的部分)，例如在查找reading a book时，</span><br><span class=\"line\">它匹配ading。</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"负向零宽断言\">负向零宽断言<a href=\"post/arc-06#负向零宽断言\"></a></h3><p>前面我们提到过怎么查找<strong>不是某个字符或不在某个字符类里</strong>的字符的方法(反义)。但是如果我们只是想要<strong>确保某个字符没有出现，但并不想去匹配它</strong>时怎么办？例如，如果我们想查找这样的单词—它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：<br><code>\\b\\w*q[^u]\\w*\\b</code>匹配~包含后面不是字母u的字母q的单词~。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像<strong>Iraq</strong>,<strong>Benq</strong>，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\\w<em>\\b将会匹配下一个单词，于是`\\b\\w</em>q[^u]\\w<em>\\b<code>就能匹配整个Iraq fighting。**负向零宽断言**能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。现在，我们可以这样来解决这个问题：</code>\\b\\w</em>q(?!u)\\w*\\b`。</p>\n<p><strong>零宽度负预测先行断言</strong></p>\n<p><code>(?!exp)</code></p>\n<p>它断言此位置的后边不能匹配表达式 exp<br>举个🌰：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\d&#123;3&#125;(?!\\d)匹配三位数字，而且这三位数字的后面不能是数字；</span><br><span class=\"line\">\\b((?!abc)\\w)+\\b匹配不包含连续字符串abc的单词。</span><br></pre></td></tr></table></div></figure>\n<p><strong>零宽度负预测后发断言</strong></p>\n<p><code>(?&lt;!exp)</code></p>\n<p>它断言此位置的前面不能匹配表达式 exp<br>举个🌰：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?&lt;![a-z])\\d&#123;7&#125;匹配~前面不是小写字母的七位数字~。</span><br><span class=\"line\"></span><br><span class=\"line\">一个更复杂的例子：(?&lt;=&lt;(\\w+)&gt;).*(?=&lt;\\/\\1&gt;)匹配不包含属性的简单HTML标签内里的内容。</span><br><span class=\"line\">(?&lt;=&lt;(\\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.(任意的字符串),</span><br><span class=\"line\">最后是一个后缀(?=&lt;\\/\\1&gt;)。注意后缀里的\\/，</span><br><span class=\"line\">它用到了前面提过的字符转义；\\1则是一个反向引用，</span><br><span class=\"line\">引用的正是捕获的第一组，前面的(\\w+)匹配的内容，</span><br><span class=\"line\">这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。</span><br><span class=\"line\">整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，</span><br><span class=\"line\">不包括前缀和后缀本身)。</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"总结\">总结<a href=\"post/arc-06#总结\"></a></h3><p>其实我们很容易就能发现一个规律。</p>\n<ul>\n<li>先行断言的表达式一般放在后面，用来匹配的却是表达式前的内容。</li>\n<li>后发断言的表达式一般放在前面，用来匹配的却是表达式后的内容。</li>\n</ul>\n<h2 id=\"注释\">注释<a href=\"post/arc-06#注释\"></a></h2><p>小括号的另一种用途是通过语法<br><code>(?#comment)来包含注释。例如：2[0-4]\\d(?#200-249)|25[0-5](?#250-255)|[01]?\\d\\d?(?#0-199)</code>。<br>要包含注释的话，最好是启用“忽略模式里的空白符”选项，<strong>（JavaScript 是不支持这个的）</strong>这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?&lt;=    # 断言要匹配的文本的前缀</span><br><span class=\"line\">&lt;(\\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)</span><br><span class=\"line\">)       # 前缀结束</span><br><span class=\"line\">.*      # 匹配任意文本</span><br><span class=\"line\">(?=     # 断言要匹配的文本的后缀</span><br><span class=\"line\">&lt;\\/\\1&gt;  # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签</span><br><span class=\"line\">)       # 后缀结束</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"贪婪与懒惰\">贪婪与懒惰<a href=\"post/arc-06#贪婪与懒惰\"></a></h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配~最长的以a开始，以b结束的字符串~。如果用它来搜索aabab的话，它会匹配整个字符串~aabab~。这被称为<strong>贪婪</strong>匹配。<br>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样<code>.*?</code>就意味着~匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复~。现在看看懒惰版的例子吧：<br><code>a.*?b</code>匹配~最短的，以a开始，以b结束的字符串~。如果把它应用于aabab的话，它会匹配~aab（第一到第三个字符）~和~ab（第四到第五个字符）~。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/22/5c94e0686c424.png\" alt=\"5c94e0686c424.png\" data-zoomable></p></div>\n<h2 id=\"平衡组和递归匹配\">平衡组和递归匹配<a href=\"post/arc-06#平衡组和递归匹配\"></a></h2><p>递归匹配，可以用于匹配嵌套元素中的最小元素，用法实在是太抽象了，用的时候再查吧。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/22/5c94e0718512d.png\" alt=\"5c94e0718512d.png\" data-zoomable></p></div>\n<h2 id=\"JavaScript-中的正则表达式\">JavaScript 中的正则表达式<a href=\"post/arc-06#JavaScript-中的正则表达式\"></a></h2><p>JavaScript 有个原生对象，<strong>regexp</strong>，同时 <strong>string</strong> 的部分方法也支持正则表达式。<br>使用 /exp/ 来包裹表达式来生成一个 regexp 对象。<br>正则表达式标识：<br>g -&gt; 全局匹配，匹配多次<br>i -&gt; 大小写不敏感<br>m -&gt; 多行，此时的 ^ 和 $ 匹配的是行结束符。</p>\n<p>JavaScript 中能使用正则表达式的方法：</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/22/5c94e07d42ead.png\" alt=\"5c94e07d42ead.png\" data-zoomable></p></div>\n<h2 id=\"案例分析\">案例分析<a href=\"post/arc-06#案例分析\"></a></h2><h3 id=\"匹配-16-进制颜色值\">匹配 16 进制颜色值<a href=\"post/arc-06#匹配-16-进制颜色值\"></a></h3><p>要求匹配：</p>\n<figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#ffbbad</span><br><span class=\"line\">#Fc01DF</span><br><span class=\"line\">#FFF</span><br><span class=\"line\">#ffE</span><br></pre></td></tr></table></div></figure>\n<p>分析：<br>表示一个16进制字符，可以用字符组<code>[0-9a-fA-F]</code>。<br>其中字符可以出现3或6次，需要是用量词和分支结构。<br>使用分支结构时，需要注意顺序。<br>正则如下：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regex = <span class=\"regexp\">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>; </span><br><span class=\"line\"><span class=\"keyword\">var</span> string = <span class=\"string\">\"#ffbbad #Fc01DF #FFF #ffE\"</span>; <span class=\"built_in\">console</span>.log( string.match(regex) ); <span class=\"comment\">// =&gt; [\"#ffbbad\", \"#Fc01DF\", \"#FFF\", \"#ffE\"]</span></span><br></pre></td></tr></table></div></figure>\n<h3 id=\"匹配时间\">匹配时间<a href=\"post/arc-06#匹配时间\"></a></h3><p>要求匹配 24 小时制的时间</p>\n<p>共4位数字，第一位数字可以为[0-2]。<br>当第1位为2时，第2位可以为[0-3]，其他情况时，第2位为[0-9]。<br>第3位数字为[0-5]，第4位为[0-9]<br>正则如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regex = <span class=\"regexp\">/^([01][0-9]|[2][0-3]):[0-5][0-9]$/</span>; <span class=\"built_in\">console</span>.log( regex.test(<span class=\"string\">\"23:59\"</span>) ); <span class=\"built_in\">console</span>.log( regex.test(<span class=\"string\">\"02:07\"</span>) ); <span class=\"comment\">// =&gt; true // =&gt; true</span></span><br></pre></td></tr></table></figure></p>\n<p>如果也要求匹配7:9，也就是说时分前面的0可以省略。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> regex = <span class=\"regexp\">/^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( regex.test(<span class=\"string\">\"23:59\"</span>) ); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( regex.test(<span class=\"string\">\"02:07\"</span>) ); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( regex.test(<span class=\"string\">\"7:9\"</span>) ); </span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br><span class=\"line\"><span class=\"comment\">// =&gt; true</span></span><br></pre></td></tr></table></div></figure>\n<h3 id=\"不匹配任何东西的正则\">不匹配任何东西的正则<a href=\"post/arc-06#不匹配任何东西的正则\"></a></h3><p><code>/.^/</code></p>\n<p>因为此正则要求只有一个字符，但该字符后面是开头。</p>\n<h3 id=\"驼峰化\">驼峰化<a href=\"post/arc-06#驼峰化\"></a></h3><figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">camelize</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> str.replace(<span class=\"regexp\">/[-_\\s]+(.)?/g</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">match, c</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c ? c.toUpperCase() : <span class=\"string\">''</span>;</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( camelize(<span class=\"string\">'-moz-transform'</span>) ); </span><br><span class=\"line\"><span class=\"comment\">// =&gt; \"MozTransform\"</span></span><br></pre></td></tr></table></div></figure>\n<p>其中分组(.)表示首字母。单词的界定是，前面的字符可以是多个连字符、下划线以及空白符。正则后面的?的目的，是为了应对str尾部的字符可能不是单词字符，比如str是’-moz-transform  ‘。</p>\n<h2 id=\"Reference\">Reference<a href=\"post/arc-06#Reference\"></a></h2><p><a href=\"http://deerchao.net/tutorials/regex/regex.htm\" target=\"_blank\" rel=\"noopener\">正则表达式30分钟入门教程</a></p>\n<p><a href=\"https://juejin.im/post/5965943ff265da6c30653879#heading-18\" target=\"_blank\" rel=\"noopener\">JS正则表达式完整教程（略长） - 掘金</a></p>\n","prev":{"title":"如何拿下前端面试（基础篇之 MVVM）","link":"post/arc-07"},"next":{"title":"Vue 高级（Vue Router 基础）","link":"post/arc-05"},"plink":"https://xkeith.space/post/arc-06/","toc":[{"title":"元字符","id":"元字符","index":"1"},{"title":"字符转义","id":"字符转义","index":"2"},{"title":"重复","id":"重复","index":"3"},{"title":"字符类","id":"字符类","index":"4"},{"title":"分枝条件","id":"分枝条件","index":"5"},{"title":"分组","id":"分组","index":"6"},{"title":"反义","id":"反义","index":"7"},{"title":"后向引用","id":"后向引用","index":"8"},{"title":"零宽断言","id":"零宽断言","index":"9","children":[{"title":"正向零宽断言","id":"正向零宽断言","index":"9.1"},{"title":"负向零宽断言","id":"负向零宽断言","index":"9.2"},{"title":"总结","id":"总结","index":"9.3"}]},{"title":"注释","id":"注释","index":"10"},{"title":"贪婪与懒惰","id":"贪婪与懒惰","index":"11"},{"title":"平衡组和递归匹配","id":"平衡组和递归匹配","index":"12"},{"title":"JavaScript 中的正则表达式","id":"JavaScript-中的正则表达式","index":"13"},{"title":"案例分析","id":"案例分析","index":"14","children":[{"title":"匹配 16 进制颜色值","id":"匹配-16-进制颜色值","index":"14.1"},{"title":"匹配时间","id":"匹配时间","index":"14.2"},{"title":"不匹配任何东西的正则","id":"不匹配任何东西的正则","index":"14.3"},{"title":"驼峰化","id":"驼峰化","index":"14.4"}]},{"title":"Reference","id":"Reference","index":"15"}]}