{"title":"如何拿下前端面试（基础篇之 MVVM）","date":"2019-03-23T03:57:18.000Z","link":"post/arc-07","tags":["front_end"],"categories":["前端"],"updated":"2019-03-23T03:59:39.641Z","content":"<hr>\n<h2 id=\"定义\">定义<a href=\"post/arc-07#定义\"></a></h2><p><em>Model-View-ViewModel</em></p>\n<p>MVVM 其实就是提供 View 和 Model 的双向绑定，由前端架构而兴起，为了解决大前端中对 DOM 的频繁操作带来的性能问题，也让前端如 H5 界面拥有了更强大的功能，甚至可以独立与服务端完成数据操作。</p>\n<p>Vue.js 是部分遵循了 MVVM 架构的（官方说法可不是一个完全遵循 MVVM 的框架），主打的就是数据驱动的架构方法，采用了数据劫持的方法来为我们实现了 ViewModel 中的双向数据绑定，可以自动保持视图和数据的一致性，让开发更加高效，便捷。</p>\n<p>MVVM，说到底还是一种分层架构。它的分层如下：</p>\n<ul>\n<li>Model: 域模型，用于持久化</li>\n<li>View: 作为视图模板存在</li>\n<li>ViewModel: 作为视图的模型，为视图服务</li>\n</ul>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/23/5c95aee3d8d8e.png\" alt=\"5c95aee3d8d8e.png\" data-zoomable></p></div>\n<h2 id=\"为什么不用-MVC\">为什么不用 MVC<a href=\"post/arc-07#为什么不用-MVC\"></a></h2><p>既然我们想要前端也拥有实现数据操作业务的功能，那么我们为什么不选择更加成熟的 MVC 呢？</p>\n<p>传统的 MVC 在前端开发中会暴露以下几个问题：</p>\n<ol>\n<li>开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。</li>\n<li>大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。</li>\n<li>当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。</li>\n</ol>\n<p><strong>主要的问题实际上还是直接对原生 DOM 的频繁操作实在是太繁琐而且拉低渲染性能了。</strong></p>\n<p>MVVM 实际上就是把 Model 和 View 之间的同步逻辑自动化了，VM 代替了 MVP 中的 Presenter，而且不在需要我们进行手动操作，整个前端架构的逻辑统统交给数据来驱动。</p>\n<ul>\n<li>视图引擎<br>视图引擎：我是视图引擎，我为 View 层作为视图模板提供强力支持，开发者，你们不需要操作 DOM ，丢给我来做！</li>\n<li>数据存取器<br>数据存取器：我是数据存取器，我可以通过<strong>Object.defineProperty()</strong>API 轻松定义，或通过自行封装存取函数的方式曲线完成。我的内部往往封装了<strong>发布/订阅模式</strong>，以此来完成对数据的监听、数据变更时通知更新。我是<strong>数据绑定</strong>实现的基础。</li>\n<li>组件机制<br>组件机制：我是组件机制。有追求的开发者往往希望按照面向未来的组件标准 －<strong>Web Components</strong>的方式开发，我是为了满足你的追求而生。MVVM 框架提供组件的定义、继承、生命周期、组件间通信机制，为开发者面向未来开发点亮明灯。</li>\n</ul>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/23/5c95aeeebb3af.png\" alt=\"5c95aeeebb3af.png\" data-zoomable></p></div>\n<h2 id=\"Vue-里头是怎么实现的\">Vue 里头是怎么实现的<a href=\"post/arc-07#Vue-里头是怎么实现的\"></a></h2><p>不同的MVVM框架中，实现双向数据绑定的技术有所不同。目前一些主流的前端框架实现数据绑定的方式大致有以下几种：</p>\n<ul>\n<li>数据劫持 (Vue)</li>\n<li>发布-订阅模式 (Knockout、Backbone)</li>\n<li>脏值检查 (Angular)</li>\n</ul>\n<p>Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data选项时，Vue 将遍历它的属性，用Object.defineProperty将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/23/5c95af1a51008.png\" alt=\"5c95af1a51008.png\" data-zoomable></p></div>\n<p>从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用Object.defineProperty将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。<br>当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。</p>\n<ul>\n<li>Observer数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。</li>\n<li>Compile指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。</li>\n<li>Watcher订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。</li>\n<li>Dep消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。</li>\n</ul>\n<p><strong>实际上实现数据双向绑定的代码并不复杂，我们可以参考下面的链接自己试着实现一下</strong></p>\n<h2 id=\"Reference\">Reference<a href=\"post/arc-07#Reference\"></a></h2><p><a href=\"https://blog.csdn.net/u014346301/article/details/53812770\" target=\"_blank\" rel=\"noopener\">Vue.js 和 MVVM - Sweet\u000eoDream - CSDN博客</a><br><a href=\"https://juejin.im/post/593021272f301e0058273468\" target=\"_blank\" rel=\"noopener\">浅析前端开发中的 MVC/MVP/MVVM 模式 - 掘金</a><br><a href=\"https://juejin.im/post/5abdd6f6f265da23793c4458\" target=\"_blank\" rel=\"noopener\">不好意思！耽误你的十分钟，让MVVM原理还给你 - 掘金</a><br><a href=\"https://segmentfault.com/a/1190000010756245\" target=\"_blank\" rel=\"noopener\">什么是MVVM - JrayZhang - SegmentFault 思否</a></p>\n","prev":{"title":"如何拿下前端面试（网络篇）","link":"post/arc-08"},"next":{"title":"正则表达式详解（JavaScript 描述）","link":"post/arc-06"},"plink":"https://xkeith.space/post/arc-07/","toc":[{"title":"定义","id":"定义","index":"1"},{"title":"为什么不用 MVC","id":"为什么不用-MVC","index":"2"},{"title":"Vue 里头是怎么实现的","id":"Vue-里头是怎么实现的","index":"3"},{"title":"Reference","id":"Reference","index":"4"}]}