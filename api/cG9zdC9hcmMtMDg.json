{"title":"如何拿下前端面试（网络篇）","date":"2019-03-23T13:47:33.000Z","link":"post/arc-08","tags":["front_end","network"],"categories":["计算机网络"],"updated":"2019-03-26T12:47:44.348Z","content":"<hr>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/23/5c96396f9dcaa.gif\" alt=\"5c96396f9dcaa.gif\" data-zoomable></p></div>\n<h2 id=\"应用层（HTTP-HTTPS）\">应用层（HTTP / HTTPS）<a href=\"post/arc-08#应用层（HTTP-HTTPS）\"></a></h2><div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/23/5c9639774bbee.png\" alt=\"5c9639774bbee.png\" data-zoomable></p></div>\n<h3 id=\"状态码\">状态码<a href=\"post/arc-08#状态码\"></a></h3><h4 id=\"1XX\">1XX<a href=\"post/arc-08#1XX\"></a></h4><p>信息性状态码，表示接收的请求正在处理。</p>\n<h4 id=\"2XX\">2XX<a href=\"post/arc-08#2XX\"></a></h4><p>成功状态码，表示请求正常处理完毕</p>\n<p><strong>200 OK</strong><br>请求正常处理，会根据不同的请求方法返回不同的响应信息。</p>\n<p><strong>204 No Content</strong><br>请求成功处理，但在返回的响应报文中不含实体的主体部分。也不允许返回任何实体的主体。<br>一般用于客户端的信息发送，不需要接收任何新信息的时候。</p>\n<p><strong>206 Partial Content</strong><br>表示范围请求成功处理，响应报文中包含由 Content-Range 指定范围的实体内容。</p>\n<h4 id=\"3XX\">3XX<a href=\"post/arc-08#3XX\"></a></h4><p>重定向状态码，表示需要进行附加操作以完成请求</p>\n<p><strong>301 Moved Permanently</strong><br>永久性重定向。表示该请求的资源已经被分配到了其他的 URL 上。</p>\n<p><strong>302 Found</strong><br>临时重定向</p>\n<p><strong>303 See Other</strong><br>表示由于请求对应的资源存在另一个 URL，应使用 GET 方法定向获取请求的资源。</p>\n<p><strong>304 Not Modified</strong><br>如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。简单的表达就是：客户端已经执行了GET，但文件未变化。</p>\n<p><strong>307 Temporary Redirect</strong><br>临时重定向，与 302 有点区别。</p>\n<h4 id=\"4XX\">4XX<a href=\"post/arc-08#4XX\"></a></h4><p>客户端错误状态码，服务器无法处理请求</p>\n<p><strong>400 Bad Request</strong><br>请求报文中存在语法错误。</p>\n<p><strong>401 Unauthorized</strong><br>表示用户未授权，可用于用户状态验证。</p>\n<p><strong>403 Forbidden</strong><br>表示请求被服务器拒绝了，没有访问权限。</p>\n<p><strong>404 Not Found</strong><br>服务器上没有请求的资源。</p>\n<h4 id=\"5XX\">5XX<a href=\"post/arc-08#5XX\"></a></h4><p>服务器错误状态码，服务器处理请求出错</p>\n<p><strong>500 Internal Server Error</strong><br>后台服务器 bug 啦</p>\n<p><strong>503 Service Unavailable</strong><br>服务器超负载或者是停机维护。</p>\n<h3 id=\"GET-和-POST-的区别\">GET 和 POST 的区别<a href=\"post/arc-08#GET-和-POST-的区别\"></a></h3><h4 id=\"常规意义上的区别\">常规意义上的区别<a href=\"post/arc-08#常规意义上的区别\"></a></h4><ul>\n<li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li>\n<li>GET产生的URL地址可以被Bookmark，而POST不可以。</li>\n<li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li>\n<li>GET请求只能进行url编码，而POST支持多种编码方式。</li>\n<li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li>\n<li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li>\n<li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li>\n<li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li>\n<li>GET参数通过URL传递，POST放在Request body中。</li>\n</ul>\n<h4 id=\"容易错误的理解\">容易错误的理解<a href=\"post/arc-08#容易错误的理解\"></a></h4><p><strong>GET使用URL或Cookie传参，而POST将数据放在BODY中</strong></p>\n<p>GET和POST是什么？HTTP协议中的两种发送请求的方法。<br>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。<br>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p>\n<p>GET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。</p>\n<p>HTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。</p>\n<p><strong>GET方式提交的数据有长度限制，则POST的数据则可以非常大</strong></p>\n<p>HTTP协议对GET和POST都没有对长度的限制。HTTP协议明确地指出了，HTTP头和Body都没有长度的要求。<br>首先是”GET方式提交的数据有长度限制”，如果我们使用GET通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p>\n<p>注意这个限制是整个<strong>URL长度</strong>，而不仅仅是你的参数值数据长度。<br>POST也是一样，POST是没有大小限制的，HTTP协议规范也没有对POST数据进行大小限制，起限制作用的是服务器的处理程序的处理能力。<br>当然，我们常说GET的URL会有长度上的限制这个说法是怎么回事呢？虽然这个不是GET和POST的本质区别，但是我们也可以说说导致URL长度限制的两方面的原因：</p>\n<ol>\n<li>浏览器。早期的浏览器会对URL长度做限制。而现在的具体限制是怎么样的，我自己没有亲测过，就不复制网上的说法啦。</li>\n<li>服务器。URL长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个M大小的URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，告诉服务器Content-Length是一个很大的数，然后只给服务器发一点儿数据，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。</li>\n</ol>\n<p><strong>POST比GET安全，因为数据在地址栏上不可见</strong></p>\n<p>这个说法其实也是基于上面的1，2两点的基础上来说的，我觉得没什么问题，但是需要明白为什么使用GET在地址栏上就不安全了，以及还有没有其他原因说明“POST比GET安全”。<br>通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成<strong>Cross-site request forgery</strong>攻击。</p>\n<h4 id=\"满分回答是啥样\">满分回答是啥样<a href=\"post/arc-08#满分回答是啥样\"></a></h4><p>GET和POST还有一个重大区别，简单的说：<br><strong>GET产生一个TCP数据包；POST产生两个TCP数据包。</strong><br>长的说：<br>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。<br>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。<br>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p>\n<ol>\n<li>GET与POST都有自己的语义，不能随便混用。</li>\n<li>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</li>\n<li>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</li>\n</ol>\n<p>GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别，上面的只是在使用上的区别。</p>\n<p>什么是幂等性？幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>\n<p>正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。<br>POST 操作具有副作用，也就是说会更改服务器上的状态。另外 POST 操作一般不是幂等的，每次 POST 操作都应该创建一个新的资源。</p>\n<h3 id=\"cookie、localstroage、sessionstroage的区别\">cookie、localstroage、sessionstroage的区别<a href=\"post/arc-08#cookie、localstroage、sessionstroage的区别\"></a></h3><p>Cookie适合存储一些session信息：</p>\n<ol>\n<li>cookie限制大小，约4k左右，不适合存储业务数据，尤其是数据量较大的值</li>\n<li>存在有效期，到期自动销毁</li>\n<li>cookie会每次随http请求一起发送，浪费宽</li>\n<li>cookie设置了domain可以在子域共享跨域</li>\n<li>可以使用爬虫抓取<br>localstroage适合存储应用共享的地址信息等：</li>\n<li>存储数据量大，5M或者更大</li>\n<li>有效期为永久</li>\n<li>不会随http请求一起发送</li>\n<li>不能跨域，但是可以使用postMessage和iframe消除这个影响,例如： <a href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fzendesk%2Fcross-storage\" target=\"_blank\" rel=\"noopener\">cross-storage</a> </li>\n<li>在浏览器的隐私模式下不能读取</li>\n<li>不能被爬虫读取<br>sessionstroage适合存储浏览状态等：</li>\n<li>存储数据量大，5M或者更大</li>\n<li>有效期为到浏览器关闭</li>\n<li>不会随http请求一起发送</li>\n<li>不能被爬虫读取</li>\n</ol>\n<h3 id=\"Session\">Session<a href=\"post/arc-08#Session\"></a></h3><p>HTTP 是个无状态的链接，为了记录 HTTP 状态，催生了 Cookie 和 Session 。</p>\n<p>Cookie 存在客户端，Session 存在服务器。<br>依赖 Cookie 在响应头中 Set-Cookie: JSESSIONID = xxx</p>\n<p>常用的三种实现方式</p>\n<ol>\n<li>依赖 Cookie 实现</li>\n<li>直接在 URL 后边重写</li>\n<li>设置一个隐藏的表单域</li>\n</ol>\n<p>过多的浏览器请求，会在服务器端创建很多的Session信息，会对浏览器造成一定的内存压力，而且不易于维护。</p>\n<h3 id=\"token\">token<a href=\"post/arc-08#token\"></a></h3><p>基于token的验证是无状态的。服务器不记录哪些用户已登陆或者已经发布了哪些JWT。对服务器的每个请求都需要带上验证请求的token。该标记既可以加在header中，可以在POST请求的主体中发送，也可以作为查询参数发送。</p>\n<p><strong>存储方式</strong></p>\n<ul>\n<li>存在 Cookie</li>\n<li>存在 localStorage</li>\n</ul>\n<p><strong>工作流程：</strong></p>\n<ul>\n<li>用户输入登陆凭据；</li>\n<li>服务器验证凭据是否正确，然后返回一个经过签名的token；</li>\n<li>客户端负责存储token，可以存在local storage，或者cookie中；</li>\n<li>对服务器的请求带上这个token；</li>\n<li>服务器对JWT进行解码，如果token有效，则处理该请求；</li>\n<li>一旦用户登出，客户端销毁token。</li>\n</ul>\n<p><strong>优势</strong></p>\n<ol>\n<li>基于token的验证是无状态的，这也许是它相对cookie来说最大的优点。后端服务不需要记录token。每个令牌都是独立的，包括检查其有效性所需的所有数据，并通过声明传达用户信息。<br>服务器唯一的工作就是在成功的登陆请求上签署token，并验证传入的token是否有效。</li>\n<li>好的API可以同时支持浏览器，iOS和Android等移动平台。然而，在移动平台上，cookie是不被支持的。</li>\n<li>一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多。</li>\n</ol>\n<p><strong>格式</strong></p>\n<p>JWT 包括三个部分：头部、载荷、签名，通过. 连接这三部分。</p>\n<p>头部通常包括两部分：token类型（JWT），和使用到的算法，如HMAC、SHA256或RSA，下面是一个例子，说明这是一个JWT，使用的签名算法是HS256。</p>\n<p>头部会通过Base64Url编码形成JWT的第一部分</p>\n<p>第二部分是载荷，要传递出去的声明，其中包含了实体（通常是用户）和附加元数据。有三种类型的声明：</p>\n<ul>\n<li>保留声明：这是一组预定义的声明，非强制性，用来帮助接收方（服务器）更好地理解这个JWT。其中包括：iss（issuer，该JWT的签发者），exp（expiration time，过期时间），sub（subject，该JWT所面向的用户），aud（audience，JWT的接收者），和另外一些声明</li>\n<li>公共声明：这些可以用使用JWT的人随意定义。但是为了避免冲突，应在在IANA JSON WEB令牌注册表中定义它们，或者将其定义为包含防冲突命名空间的URI。</li>\n<li>私有声明：这些是为了在同意使用它们的各方之间共享信息而创建的自定义声明。</li>\n</ul>\n<h2 id=\"传输层（TCP-IP）\">传输层（TCP / IP）<a href=\"post/arc-08#传输层（TCP-IP）\"></a></h2><p>￼<br><img src=\"https://i.loli.net/2019/03/23/5c96398fdeef3.png\" alt=\"5c96398fdeef3.png\"></p>\n<h3 id=\"三次🤝-四次🙋\">三次🤝 四次🙋<a href=\"post/arc-08#三次🤝-四次🙋\"></a></h3><h3 id=\"TCP-与-UDP-的区别\">TCP 与 UDP 的区别<a href=\"post/arc-08#TCP-与-UDP-的区别\"></a></h3><h2 id=\"网络层\">网络层<a href=\"post/arc-08#网络层\"></a></h2><h3 id=\"IP-协议\">IP 协议<a href=\"post/arc-08#IP-协议\"></a></h3><h2 id=\"数据链路层\">数据链路层<a href=\"post/arc-08#数据链路层\"></a></h2><h2 id=\"物理层\">物理层<a href=\"post/arc-08#物理层\"></a></h2><h2 id=\"安全\">安全<a href=\"post/arc-08#安全\"></a></h2><h3 id=\"CORS\">CORS<a href=\"post/arc-08#CORS\"></a></h3><p><em>Cross-Origin Resource Sharing</em><br>跨来源资源共享，是一份浏览器技术规范，提供了 WEB 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。<br>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。</p>\n<p><strong>简单请求并不会触发 CORS 预检</strong><br>关于 CORS 的详细介绍参见 MDN 和阮一峰的博客。</p>\n<p><strong>CORS</strong>是W3c工作草案，它定义了在跨域访问资源时浏览器和服务器之间如何通信。CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否。<br><strong>同源策略</strong>：是浏览器最核心也最基本的安全功能；同源指的是：同协议，同域名和同端口。精髓：认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源；<br><strong>JSON &amp; JSONP</strong>:JSON 是一种基于文本的数据交换方式，或者叫做数据描述格式。JSONP是资料格式JSON的一种“使用模式”，可以让网页从别的网域要资料，由于同源策略，一般来说位于<code>server1.example.com</code>的网页无法与不是 <code>server1.example.com</code>的服务器沟通，而HTML的script元素是一个例外。利用script元素的这个开放策略，网页可以得到从其他来源动态产生的JSON资料，而这种使用模式就是所谓的JSONP</p>\n<h4 id=\"解决方案\">解决方案<a href=\"post/arc-08#解决方案\"></a></h4><p>主要解决思路：<br>使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否.<br>Access-Control-Allow-Origin:指定授权访问的域<br>Access-Control-Allow-Methods：授权请求的方法（GET, POST, PUT, DELETE，OPTIONS等)</p>\n<p><strong>后端解决</strong></p>\n<ul>\n<li>增加一个过滤器来处理预检请求</li>\n<li>返回包含哪些与 CORS 有关的响应头</li>\n<li>或者是通过 Nginx 来支持跨域</li>\n</ul>\n<p><strong>前端解决</strong></p>\n<ul>\n<li>vue 和 webpack 都可以通过调用 <a href=\"https://github.com/chimurai/http-proxy-middleware\" target=\"_blank\" rel=\"noopener\">http-proxy-middleware</a> 这个库来实现客户端代理，从而解决跨域问题。</li>\n</ul>\n<h3 id=\"XSS-攻击\">XSS 攻击<a href=\"post/arc-08#XSS-攻击\"></a></h3><p>XSS，即为（Cross Site Scripting），中文名为跨站脚本,跨站脚本的重点不在“跨站”上，而在于“脚本”上。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码，实际上是在目标网站的作用域下执行了这段第三方域上的js代码。</p>\n<h4 id=\"反射型XSS（非持久型XSS）\">反射型XSS（非持久型XSS）<a href=\"post/arc-08#反射型XSS（非持久型XSS）\"></a></h4><p>特点：就像镜子反射一样，浏览器发射含XSS的url，服务器将其反射回来</p>\n<ol>\n<li>浏览器发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，</li>\n<li>服务器解析并响应，响应结果中包含XSS代码，</li>\n<li>最后浏览器解析并执行。</li>\n</ol>\n<p>攻击者会将 XSS 脚本通过请求参数的方式发送到服务器，服务器执行后会返回 cookie 信息等隐私信息。<br>一般黑客会注入一段第三方的js代码，然后将获取到的cookie信息存到他们的服务器上，拿到我们的身份认证做一些违法的事情了。</p>\n<h4 id=\"存储型XSS（持久型XSS）\">存储型XSS（持久型XSS）<a href=\"post/arc-08#存储型XSS（持久型XSS）\"></a></h4><p>特点：黑客将XSS代码发送给服务器，然后通过服务器散播</p>\n<ol>\n<li>黑客将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。）</li>\n<li>其他人请求页面的时候就会带上XSS代码了。</li>\n</ol>\n<p>案例：最典型的就是留言板XSS。</p>\n<ul>\n<li>黑客提交了一条包含XSS代码的留言到数据库。</li>\n<li>当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。</li>\n<li>浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。</li>\n</ul>\n<h4 id=\"DOM-型-XSS\">DOM 型 XSS<a href=\"post/arc-08#DOM-型-XSS\"></a></h4><p>特点：DOM XSS代码不需要服务器端的解析响应的直接参与，而是完全通过浏览器端的DOM解析。</p>\n<ul>\n<li>浏览器的代码中含有eval，new Function等将字符串内容执行的代码</li>\n<li>在执行的字符串中嵌入可以执行XSS代码字符串 案例：</li>\n</ul>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> node = <span class=\"built_in\">window</span>.eval(txt.value)</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.alert(node)</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//txt中的代码如下:</span></span><br><span class=\"line\">&lt;img src=<span class=\"string\">'null'</span> onerror=<span class=\"string\">'alert(123)'</span> /&gt;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"危害和防御\">危害和防御<a href=\"post/arc-08#危害和防御\"></a></h4><ul>\n<li>通过document.cookie盗取cookie</li>\n<li>使用js或css破坏页面正常的结构与样式</li>\n<li>流量劫持（通过访问某段具有window.location.href定位到其他页面）</li>\n<li>Dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。</li>\n<li>利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li>\n<li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li>\n</ul>\n<p>XSS攻击可以看出，不能原样的将用户输入的数据直接存到服务器，需要对数据进行一些处理：</p>\n<ul>\n<li>过滤危险的DOM节点。如具有执行脚本能力的script, 具有显示广告和色情图片的img, 具有改变样式的link, style, 具有内嵌页面的iframe, frame等元素节点。</li>\n<li>过滤危险的属性节点。如on-, style, src, href等</li>\n<li>对cookie设置httpOnly,但是也会导致前台无法操作cookie，不太推荐。</li>\n</ul>\n<h3 id=\"CSRF\">CSRF<a href=\"post/arc-08#CSRF\"></a></h3><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，攻击者盗用了你的身份，以你的名义发送恶意请求。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/23/5c9639a85e304.png\" alt=\"5c9639a85e304.png\" data-zoomable></p></div>\n<p>特点：</p>\n<ol>\n<li>登录受信任网站A，并在本地生成Cookie。</li>\n<li>在不登出受信任网站A的情况下，访问危险网站B。</li>\n<li>危险网站会向受信任A的网站发送请求，同时会携带受信任网站A本地生成Cookie(用同一个浏览器访问同一个域的接口)</li>\n</ol>\n<h4 id=\"危害和防御-1\">危害和防御<a href=\"post/arc-08#危害和防御-1\"></a></h4><ol>\n<li>篡改目标网站上的用户数据；</li>\n<li>盗取用户隐私数据；</li>\n<li>作为其他攻击向量的辅助攻击手法；</li>\n<li>传播CSRF蠕虫。</li>\n</ol>\n<p><strong>防御</strong></p>\n<ul>\n<li>验证码，因为验证码必须在受信任的网站上发送给浏览器的，并且伪造的网站和受信任的网站非同源，所以没有办法获取受信任网站发送的session，所以验证码是没有办法伪造的。</li>\n<li>refer，标识了当前请求的页面的源，伪造网站可以篡改成受信任的网站源，并不保险</li>\n<li>token，由于它是通过服务的发送给客户端的令牌，并且存储在浏览器的localstorage中，由于同源策略，并且token还有校验规则，所以token并不能轻易篡改。</li>\n</ul>\n<h3 id=\"HTTPS-怎么预防攻击\">HTTPS 怎么预防攻击<a href=\"post/arc-08#HTTPS-怎么预防攻击\"></a></h3><p><strong>HTTPS = (HTTP+TLS/SSL)</strong></p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/23/5c9639b1cbef2.png\" alt=\"5c9639b1cbef2.png\" data-zoomable></p></div>\n<h2 id=\"自己先问问自己\">自己先问问自己<a href=\"post/arc-08#自己先问问自己\"></a></h2><h3 id=\"点击一个-url-到页面被渲染出来，中间都发生了什么？\">点击一个 url 到页面被渲染出来，中间都发生了什么？<a href=\"post/arc-08#点击一个-url-到页面被渲染出来，中间都发生了什么？\"></a></h3><p>面试必问，很大概率是第一问，要从五层体系结构开始吹，注意其中的用词，把技术词汇朝自己想好的坑里带，如最短路径，CORS，TCP 和 UDP 的区别，总之就是千万不要出现自己解释不好的词汇，防止给自己挖坑。</p>\n<ul>\n<li><p>HTTP 和 HTTPS 的区别？</p>\n</li>\n<li><p>TCP 和 UDP 的区别</p>\n</li>\n<li><p>握手和挥手，说一说</p>\n</li>\n<li><p>如何解决跨域</p>\n</li>\n</ul>\n<h2 id=\"Reference\">Reference<a href=\"post/arc-08#Reference\"></a></h2><p><a href=\"https://blog.csdn.net/tiger0709/article/details/78095216\" target=\"_blank\" rel=\"noopener\">Cookie和Token - WillieLiu的专栏 - CSDN博客</a></p>\n<p><a href=\"https://juejin.im/post/5b5f20686fb9a04f844adbdd\" target=\"_blank\" rel=\"noopener\">搞定计算机网络面试，看这篇就够了 - 掘金</a></p>\n<p><a href=\"https://www.jianshu.com/p/fd67b576365d\" target=\"_blank\" rel=\"noopener\">HTTP｜GET 和 POST 区别？网上多数答案都是错的！ - 简书</a></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd\" target=\"_blank\" rel=\"noopener\">99%的人都理解错了HTTP中GET与POST的区别</a></p>\n<p><a href=\"https://juejin.im/post/5bb1cc2af265da0ae5052496\" target=\"_blank\" rel=\"noopener\">前端必须懂的计算机网络知识—(跨域、代理、本地存储) - 掘金</a></p>\n<p><a href=\"https://www.cnblogs.com/sloong/p/cors.html\" target=\"_blank\" rel=\"noopener\">CORS 跨域 实现思路及相关解决方案 - sloong - 博客园</a></p>\n<p><a href=\"https://www.jianshu.com/p/f489e7764cb8\" target=\"_blank\" rel=\"noopener\">Webpack-dev-server的proxy用法 - 简书</a></p>\n<p> <a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">阮一峰的 CORS 详解</a> </p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\" rel=\"noopener\">HTTP访问控制（CORS） - HTTP | MDN</a></p>\n<p><a href=\"https://www.cnblogs.com/cityspace/p/6858969.html\" target=\"_blank\" rel=\"noopener\">CORS(跨域资源共享) - spaceway - 博客园</a></p>\n","prev":{"title":"Top-K 问题","link":"post/arc-09"},"next":{"title":"如何拿下前端面试（基础篇之 MVVM）","link":"post/arc-07"},"plink":"https://xkeith.space/post/arc-08/","toc":[{"title":"应用层（HTTP / HTTPS）","id":"应用层（HTTP-HTTPS）","index":"1","children":[{"title":"状态码","id":"状态码","index":"1.1","children":[{"title":"1XX","id":"1XX","index":"1.1.1"},{"title":"2XX","id":"2XX","index":"1.1.2"},{"title":"3XX","id":"3XX","index":"1.1.3"},{"title":"4XX","id":"4XX","index":"1.1.4"},{"title":"5XX","id":"5XX","index":"1.1.5"}]},{"title":"GET 和 POST 的区别","id":"GET-和-POST-的区别","index":"1.2","children":[{"title":"常规意义上的区别","id":"常规意义上的区别","index":"1.2.1"},{"title":"容易错误的理解","id":"容易错误的理解","index":"1.2.2"},{"title":"满分回答是啥样","id":"满分回答是啥样","index":"1.2.3"}]},{"title":"cookie、localstroage、sessionstroage的区别","id":"cookie、localstroage、sessionstroage的区别","index":"1.3"},{"title":"Session","id":"Session","index":"1.4"},{"title":"token","id":"token","index":"1.5"}]},{"title":"传输层（TCP / IP）","id":"传输层（TCP-IP）","index":"2","children":[{"title":"CORS","id":"CORS","index":"2.1","children":[{"title":"解决方案","id":"解决方案","index":"2.1.1"}]},{"title":"XSS 攻击","id":"XSS-攻击","index":"2.2","children":[{"title":"反射型XSS（非持久型XSS）","id":"反射型XSS（非持久型XSS）","index":"2.2.1"},{"title":"存储型XSS（持久型XSS）","id":"存储型XSS（持久型XSS）","index":"2.2.2"},{"title":"DOM 型 XSS","id":"DOM-型-XSS","index":"2.2.3"},{"title":"危害和防御","id":"危害和防御","index":"2.2.4"}]},{"title":"CSRF","id":"CSRF","index":"2.3","children":[{"title":"危害和防御","id":"危害和防御-1","index":"2.3.1"}]},{"title":"HTTPS 怎么预防攻击","id":"HTTPS-怎么预防攻击","index":"2.4"}]},{"title":"自己先问问自己","id":"自己先问问自己","index":"3","children":[{"title":"点击一个 url 到页面被渲染出来，中间都发生了什么？","id":"点击一个-url-到页面被渲染出来，中间都发生了什么？","index":"3.1"}]},{"title":"Reference","id":"Reference","index":"4"}]}