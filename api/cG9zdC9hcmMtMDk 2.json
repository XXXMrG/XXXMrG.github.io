{"title":"Top-K 问题","date":"2019-03-25T08:51:45.000Z","link":"post/arc-09","tags":["Algorithm"],"categories":["算法"],"updated":"2019-03-25T12:04:23.644Z","content":"<hr>\n<blockquote>\n<p>从 n 个数中找出最大的 k 个数  </p>\n</blockquote>\n<h2 id=\"全局排序\">全局排序<a href=\"post/arc-09#全局排序\"></a></h2><p>最容易的方法，全部排序，取出最大的 k 个。<br>时间复杂度取决于具体使用的排序算法。<br>问题出在当数据数量特别大的时候，花费了很多时间在不需要的元素的排序上。</p>\n<h2 id=\"局部排序\">局部排序<a href=\"post/arc-09#局部排序\"></a></h2><p>不再全局排序，只对最大的 k 个排序。<br>相当于冒泡排序或者是选择排序，不断选择最大值放到前面。<br>时间复杂度是 O(n * k)<br>但是我们要注意，top-k 问题中的这 k 个最大元素是不需要有序的，因此我们可以进一步减少操作。</p>\n<h2 id=\"堆\">堆<a href=\"post/arc-09#堆\"></a></h2><p>先用前 k 个元素生成一个小顶堆，用于存储当前扫描过的数据中最大的 k 个元素。<br>之后从第 k+1 个元素开始扫描，如果有元素大于当前堆顶的元素，那么淘汰当前堆顶元素，替换为新元素，同时调整堆的平衡。<br>最后剩下的 k 个元素组成的堆，就是 top-k 。<br>假设每次堆都发生了调整，那么时间复杂度为 O(n * lg(k) )<br>堆是解决 top-k 的经典算法，接下来要开始更秀的操作了🤒</p>\n<h2 id=\"随机选择\">随机选择<a href=\"post/arc-09#随机选择\"></a></h2><p>随机选择算法是《算法导论》中一个经典的算法，其时间复杂度为O(n)，是一个线性复杂度的方法。<br>利用快排来寻找 top-k ，找到数组中第 k 大的元素，此时数组中该元素左边的元素即是 top-k。</p>\n<p>快速排序<strong>第一次</strong>partition，划分之后：<br>i = partition(arr, 1, n);</p>\n<ul>\n<li><p>如果i大于k，则说明arr[i]左边的元素都大于k，于是只递归arr[1, i-1]里第k大的元素即可；</p>\n</li>\n<li><p>如果i小于k，则说明说明第k大的元素在arr[i]的右边，于是只递归arr[i+1, n]里第k-i大的元素即可；</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> partitionLomuto = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">*arr*, *low*, *high*</span>) </span>&#123;</span><br><span class=\"line\">  high--;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> pivot = arr[high];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = low; j &lt; high; j++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr[j] &gt;= pivot) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> temp = arr[low];</span><br><span class=\"line\">      arr[low] = arr[j];</span><br><span class=\"line\">      arr[j] = temp;</span><br><span class=\"line\">      low ++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  temp = arr[low];</span><br><span class=\"line\">  arr[low] = arr[high];</span><br><span class=\"line\">  arr[high] = temp;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> low;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> RS = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">*arr*, *low*, *high*, *k*</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = partitionLomuto(arr, low, high);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp = i - low;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (temp === k)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (temp &gt; k) &#123;</span><br><span class=\"line\">    RS(arr, low, i, k);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    RS(arr, i+<span class=\"number\">1</span>, high, k-i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/25/5c98970e4d1a2.jpg\" alt=\"5c98970e4d1a2.jpg\" data-zoomable></p></div>\n<h2 id=\"BitMap\">BitMap<a href=\"post/arc-09#BitMap\"></a></h2><p>位图是个很极端的空间换时间的方法。<br><strong>例如</strong>，集合S={1,3,5,7,9}，容易发现，S中所有元素都在1-16之间，于是，可以用16个bit来表示这个集合：存在于集合中的元素，对应bit置1，否则置0。<br><em>画外音：究竟需要多少存存储空间，取决于集合中元素的值域，在什么范围之内。</em><br>上述集合S，可以用1010101010000000这样一个16bit的bitmap来表示，其中，第1, 3, 5, 7, 9个bit位置是1。<br>假设TopK的n个元素都是int，且元素之间没有重复，只需要申请2^32个bit，即4G的内存，就能够用bitmap表示这n元素。<br>扫描一次所有n个元素，以生成bitmap，其时间复杂度是O(n)。生成后，取TopK只需要找到最高位的k个bit即可。算法总时间复杂度也是O(n)。</p>\n<p><em>false is false, true may be true</em><br>但是 bitmap 有个问题，重复的元素会被覆盖，这样可能会使得能表达的数据变少，我们采用一种计数的位图来解决问题，如果数据出现重复，那么该位 count + 1，top-k 就成为了从后到前，count 之和 = k。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/25/5c98971be5df7.jpg\" alt=\"5c98971be5df7.jpg\" data-zoomable></p></div>\n<h2 id=\"Reference\">Reference<a href=\"post/arc-09#Reference\"></a></h2><p><a href=\"https://www.e-learn.cn/content/qita/1224371\" target=\"_blank\" rel=\"noopener\">Top-K问题 | 易学教程</a></p>\n","prev":{"title":"TCP 的三次🤝与四次🙋详解","link":"post/arc-10"},"next":{"title":"如何拿下前端面试（网络篇）","link":"post/arc-08"},"plink":"https://xkeith.space/post/arc-09/","toc":[{"title":"全局排序","id":"全局排序","index":"1"},{"title":"局部排序","id":"局部排序","index":"2"},{"title":"堆","id":"堆","index":"3"},{"title":"随机选择","id":"随机选择","index":"4"},{"title":"BitMap","id":"BitMap","index":"5"},{"title":"Reference","id":"Reference","index":"6"}]}