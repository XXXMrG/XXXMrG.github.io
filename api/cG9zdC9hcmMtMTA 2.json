{"title":"TCP 的三次🤝与四次🙋详解","date":"2019-03-26T14:03:37.000Z","link":"post/arc-10","tags":["network"],"categories":["计算机网络"],"updated":"2019-04-17T13:24:13.642Z","content":"<hr>\n<h2 id=\"TCP-协议如何保证可靠运输\">TCP 协议如何保证可靠运输<a href=\"post/arc-10#TCP-协议如何保证可靠运输\"></a></h2><h3 id=\"通过序列号与确认应答提高可靠性\">通过序列号与确认应答提高可靠性<a href=\"post/arc-10#通过序列号与确认应答提高可靠性\"></a></h3><p>在 TCP 中，当发送端的数据到达接收端的时候，接收端会返回一个已收到消息的通知，这个消息叫做 ACK (<em>Positive Acknowled-gement</em>)。<br>TCP 通过检查 ACK 实现可靠的数据传输。如果接收端成功返回 ACK，说明数据已经成功到达。反之，丢失数据的可能性很大。一定时间内没有收到 ACK 的话，发送端就会对数据包进行重传。</p>\n<h4 id=\"重传发生的几种情况\">重传发生的几种情况<a href=\"post/arc-10#重传发生的几种情况\"></a></h4><ol>\n<li>超时重传</li>\n</ol>\n<p>￼<br><img src=\"https://i.loli.net/2019/03/26/5c9a31c3c9083.png\" alt=\"5c9a31c3c9083.png\"></p>\n<p>超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。</p>\n<ol start=\"2\">\n<li>确认丢失和确认迟到</li>\n</ol>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/26/5c9a31cbc3c42.png\" alt=\"5c9a31cbc3c42.png\" data-zoomable></p></div>\n<p>当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</p>\n<ul>\n<li>丢弃这个重复的M1消息，不向上层交付。</li>\n<li>向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>\n</ul>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/26/5c9a31d4ea261.png\" alt=\"5c9a31d4ea261.png\" data-zoomable></p></div>\n<p>A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：</p>\n<ul>\n<li>A收到重复的确认后，直接丢弃。</li>\n<li>B收到重复的M1后，也直接丢弃重复的M1。</li>\n</ul>\n<h4 id=\"超时时间的确定\">超时时间的确定<a href=\"post/arc-10#超时时间的确定\"></a></h4><p>最理想的超时时间是，找到一个最小时间，他能保证确认应答一定能在这个时间内返回。然而这个时间会根据网络环境的不同而变化。<br>TCP 要求不论处在何种网络环境下都要提供高性能通信，并且无论网络拥堵情况发生何种变化，都必须保持这一特性。因此它在每次发包的时候都会计算往返时间及其偏差。将这个往返时间和偏差时间相加，重发超时时间会比这个值还稍微大一点。<br>一般情况下重发时间都是 0.5s 的整数倍，同时因为偏差时间的最小值也是 0.5s ，因此最小的重发超时时间至少是 1s。<br>一般情况下超时时间设置为 6s，如果数据被重发后还是没有正常收到 ACK，等待确认的时间会以 2倍，4倍…的指数方式增长。<br>如果达到一定重发次数后还是不成功，就会判定为网络异常，强制关闭链接，并且通知应用程序。</p>\n<h4 id=\"两种重传协议\">两种重传协议<a href=\"post/arc-10#两种重传协议\"></a></h4><p><strong>自动重传请求 ARQ 协议</strong><br>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。<br><strong>优点：</strong> 简单<br><strong>缺点：</strong> 信道利用率低</p>\n<p>连续ARQ协议<br>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。<br><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。<br><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>\n<h4 id=\"序列号\">序列号<a href=\"post/arc-10#序列号\"></a></h4><p>上述这些确认应答处理，重发控制以及重复控制等功能都可以通过序列号实现。<br>序列号是按顺序给发送数据的每一个字节（8位）都标上号码的编号，接收端查询数据 TCP 首部中的序列号和数据的长度，将自己下一步应该接受的序号返回，这样通过 ACK 和序列号的结合可以实现可靠的运输。</p>\n<h2 id=\"TCP-以段为单位发送数据\">TCP 以段为单位发送数据<a href=\"post/arc-10#TCP-以段为单位发送数据\"></a></h2><p>TCP 将原始数据报分割成合适的大小进行传输，这个大小叫做最大消息长度 <em>MSS: Maximum Segment Size</em> 。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。<br>TCP 在数据发送和重发的时候都是以 MSS 为单位的。<br>MSS 是在三次握手的时候，在两端主机之间被计算得出。两端在建立连接的时候，会在 TCP 首部写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 大小，然后会在两者之间选择一个<strong>较小的值</strong>投入使用。</p>\n<h3 id=\"滑动窗口\">滑动窗口<a href=\"post/arc-10#滑动窗口\"></a></h3><p>我们已经了解到 TCP 将数据报分段进行处理，每次发送一个段就进行一次确认应答的处理，这又带来一个缺点，包的往返时间越长，包的数量越多，通信性能就会大大降低。<br>为了解决这个问题，TCP 引入了窗口这个概念。即使在往返时间较长的情况下，他也能控制网络性能的下降。<br>确认应答不再是一对一的，而是以窗口为单位进行确认。也就意味着发送端主机在发送了一个段以后不必要一直等待确认应答，而是继续发送。<br>这个机制需要大量的<strong>缓冲区</strong>，一个窗口内的数据即便没有收到确认应答也可以发送出去，同时为了解决发送过程中的数据丢失，保证可以及时重发缺失的数据，发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据。<br>如果一个窗口中的某段数据没有成功送达，那么该段之后的数据都会重传，窗口会滑动到以该段数据为起点。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/26/5c9a31de36cc4.png\" alt=\"5c9a31de36cc4.png\" data-zoomable></p></div>\n<h3 id=\"拥塞控制\">拥塞控制<a href=\"post/arc-10#拥塞控制\"></a></h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。<br>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。<br>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>\n<ul>\n<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>\n</ul>\n<h3 id=\"快重传和快恢复\">快重传和快恢复<a href=\"post/arc-10#快重传和快恢复\"></a></h3><p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。  当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。<br><img src=\"https://i.loli.net/2019/03/26/5c9a31eebbe4b.png\" alt=\"5c9a31eebbe4b.png\"></p>\n<h2 id=\"哪些面试官非常喜欢问的问题\">哪些面试官非常喜欢问的问题<a href=\"post/arc-10#哪些面试官非常喜欢问的问题\"></a></h2><h3 id=\"为什么不能用两次握手进行连接？\">为什么不能用两次握手进行连接？<a href=\"post/arc-10#为什么不能用两次握手进行连接？\"></a></h3><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p>\n<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>\n<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>\n<h3 id=\"为什么客户端最后还要等待2MSL？\">为什么客户端最后还要等待2MSL？<a href=\"post/arc-10#为什么客户端最后还要等待2MSL？\"></a></h3><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>\n<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>\n<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>\n<h3 id=\"为什么建立连接是三次握手，关闭连接确是四次挥手呢？\">为什么建立连接是三次握手，关闭连接确是四次挥手呢？<a href=\"post/arc-10#为什么建立连接是三次握手，关闭连接确是四次挥手呢？\"></a></h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>\n<h3 id=\"如果已经建立了连接，但是客户端突然出现故障了怎么办？\">如果已经建立了连接，但是客户端突然出现故障了怎么办？<a href=\"post/arc-10#如果已经建立了连接，但是客户端突然出现故障了怎么办？\"></a></h3><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>\n<h2 id=\"握手和挥手详细过程\">握手和挥手详细过程<a href=\"post/arc-10#握手和挥手详细过程\"></a></h2><h3 id=\"三次握手\">三次握手<a href=\"post/arc-10#三次握手\"></a></h3><div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/04/17/5cb728f85d3ab.png\" alt=\"5cb728f85d3ab.png\" data-zoomable></p></div>\n<h3 id=\"四次挥手\">四次挥手<a href=\"post/arc-10#四次挥手\"></a></h3><div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/04/17/5cb728a0e3013.png\" alt=\"5cb728a0e3013.png\" data-zoomable></p></div>\n<h2 id=\"Reference\">Reference<a href=\"post/arc-10#Reference\"></a></h2><p><a href=\"https://blog.csdn.net/qzcsu/article/details/72861891\" target=\"_blank\" rel=\"noopener\">TCP的三次握手与四次挥手（详解+动图） - qzcsu的博客 - CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/carson_ho/article/details/85316719\" target=\"_blank\" rel=\"noopener\">计算机网络：这是一份全面 &amp; 详细 的TCP协议学习指南 - 专注分享 Android开发 干货 - CSDN博客</a></p>\n<p><a href=\"https://juejin.im/post/5b7be0b2e51d4538db34a51e\" target=\"_blank\" rel=\"noopener\">搞定计算机网络面试，看这篇就够了（补充版） - 掘金</a></p>\n<p><a href=\"https://blog.csdn.net/qq_38950316/article/details/81087809\" target=\"_blank\" rel=\"noopener\">TCP的三次握手与四次挥手理解及面试题（很全面） - lucky_jun - CSDN博客</a></p>\n","prev":{"title":"前端工程师技术图谱","link":"post/arc-11"},"next":{"title":"Top-K 问题","link":"post/arc-09"},"plink":"https://xkeith.space/post/arc-10/","toc":[{"title":"TCP 协议如何保证可靠运输","id":"TCP-协议如何保证可靠运输","index":"1","children":[{"title":"通过序列号与确认应答提高可靠性","id":"通过序列号与确认应答提高可靠性","index":"1.1","children":[{"title":"重传发生的几种情况","id":"重传发生的几种情况","index":"1.1.1"},{"title":"超时时间的确定","id":"超时时间的确定","index":"1.1.2"},{"title":"两种重传协议","id":"两种重传协议","index":"1.1.3"},{"title":"序列号","id":"序列号","index":"1.1.4"}]}]},{"title":"TCP 以段为单位发送数据","id":"TCP-以段为单位发送数据","index":"2","children":[{"title":"滑动窗口","id":"滑动窗口","index":"2.1"},{"title":"拥塞控制","id":"拥塞控制","index":"2.2"},{"title":"快重传和快恢复","id":"快重传和快恢复","index":"2.3"}]},{"title":"哪些面试官非常喜欢问的问题","id":"哪些面试官非常喜欢问的问题","index":"3","children":[{"title":"为什么不能用两次握手进行连接？","id":"为什么不能用两次握手进行连接？","index":"3.1"},{"title":"为什么客户端最后还要等待2MSL？","id":"为什么客户端最后还要等待2MSL？","index":"3.2"},{"title":"为什么建立连接是三次握手，关闭连接确是四次挥手呢？","id":"为什么建立连接是三次握手，关闭连接确是四次挥手呢？","index":"3.3"},{"title":"如果已经建立了连接，但是客户端突然出现故障了怎么办？","id":"如果已经建立了连接，但是客户端突然出现故障了怎么办？","index":"3.4"}]},{"title":"握手和挥手详细过程","id":"握手和挥手详细过程","index":"4","children":[{"title":"三次握手","id":"三次握手","index":"4.1"},{"title":"四次挥手","id":"四次挥手","index":"4.2"}]},{"title":"Reference","id":"Reference","index":"5"}]}