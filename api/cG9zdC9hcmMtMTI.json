{"title":"如何拿下前端面试（性能篇）","date":"2019-03-30T15:39:32.000Z","link":"post/arc-12","tags":["front_end"],"categories":["前端"],"updated":"2019-03-31T09:05:33.892Z","content":"<hr>\n<h2 id=\"基础知识\">基础知识<a href=\"post/arc-12#基础知识\"></a></h2><h3 id=\"RAIL\">RAIL<a href=\"post/arc-12#RAIL\"></a></h3><p>Chrome 团队提出了一个以用户为中心的性能模型被称为 RAIL。<br>RAIL 将影响性能的行为划分为四个方面，分别是: Response, Animation, Idle, Load。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/30/5c9f8e11d0d63.png\" alt=\"5c9f8e11d0d63.png\" data-zoomable></p></div>\n<h4 id=\"响应\">响应<a href=\"post/arc-12#响应\"></a></h4><p>流畅的网页对于用户的输入操作的反应时间不应超过 <strong>100ms</strong>。</p>\n<h4 id=\"动画\">动画<a href=\"post/arc-12#动画\"></a></h4><p>现如今大多数设备的屏幕刷新频率是60Hz，也就是每秒钟屏幕刷新60次；因此网页动画的运行速度只要达到60FPS，我们就会觉得动画很流畅。<br>换算下来每一帧的时间是 16ms<br><code>(1 秒 = 1000 毫秒) / 60 帧 = 16.66 毫秒/帧</code></p>\n<p>但通常浏览器需要花费一些时间将每一帧的内容绘制到屏幕上（包括样式计算、布局、绘制、合成等工作），所以通常我们只有10毫秒来执行JS代码。<br>一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。</p>\n<h4 id=\"空闲\">空闲<a href=\"post/arc-12#空闲\"></a></h4><p>为了更好的性能，我们通常会充分利用浏览器空闲周期做一些低优先级的事情。例如：在空闲周期预请求一些接下来可能会用到的数据或上报分析数据等。</p>\n<p>RAIL规定，空闲周期内运行的任务不得超过<strong>50ms</strong>，当然不止RAIL规定，W3C性能工作组的Longtasks标准也规定了超过50毫秒的任务属于长任务，那么<strong>50ms</strong>这个数字是怎么得来的呢？<br>浏览器是单线程的，这意味着同一时间主线程只能处理一个任务，如果一个任务执行时间过长，浏览器则无法执行其他任务，用户会感觉到浏览器被卡死了，因为他的输入得不到任何响应。<br>为了达到<strong>100ms</strong>内给出响应，将空闲周期执行的任务限制为<strong>50ms</strong>意味着，即使用户的输入行为发生在空闲任务刚开始执行，浏览器仍有剩余的50ms时间用来响应用户输入，而不会产生用户可察觉的延迟。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/30/5c9f8e1d55a5c.png\" alt=\"5c9f8e1d55a5c.png\" data-zoomable></p></div>\n<h4 id=\"加载\">加载<a href=\"post/arc-12#加载\"></a></h4><p>如果不能在<strong>1秒钟</strong>内加载网页并让用户看到内容，用户的注意力就会分散。用户会觉得他要做的事情被打断，如果<strong>10秒钟</strong>还打不开网页，用户会感到失望，会放弃他们想做的事，以后他们或许都不会再回来。</p>\n<h3 id=\"网页生成的过程\">网页生成的过程<a href=\"post/arc-12#网页生成的过程\"></a></h3><div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/31/5ca08055488f6.png\" alt=\"5ca08055488f6.png\" data-zoomable></p></div>\n<p>网页的生成过程，大致可以分成五步。</p>\n<ol>\n<li>HTML 代码转化成 DOM。</li>\n<li>CSS 代码转化成 CSSOM (CSS Object Model)。</li>\n<li>结合 DOM 和 CSSOM，生成一颗渲染树。</li>\n<li>生成布局，将渲染树的所有节点进行平面合成。</li>\n<li>将布局绘制在屏幕上。</li>\n</ol>\n<p>五步中，一到三步都非常快，耗时的是第四步和第五步。<br><strong>生成布局（flow）和绘制（paint）这两步，合称为渲染（render）。</strong></p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/31/5ca0805d5ad24.png\" alt=\"5ca0805d5ad24.png\" data-zoomable></p></div>\n<h3 id=\"重排和重绘\">重排和重绘<a href=\"post/arc-12#重排和重绘\"></a></h3><p><strong>网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。</strong><br>以下三种情况，会导致网页重新渲染。</p>\n<ul>\n<li>修改DOM</li>\n<li>修改样式表</li>\n<li>用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）</li>\n</ul>\n<p><strong>重新渲染，就需要重新生成布局和重新绘制。前者叫做”重排”（reflow），后者叫做”重绘”（repaint）。</strong><br>需要注意的是，<strong>”重绘”不一定需要”重排”</strong>，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，<strong>”重排”必然导致”重绘”</strong>，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。</p>\n<p>触发重排的属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.盒子模型相关属性： width ,height ,padding ,margin ,display ,border-width ,border</span><br><span class=\"line\"></span><br><span class=\"line\">2.定位属性及浮动： top ,bottom ,left ,right ,position ,float ,clear</span><br><span class=\"line\"></span><br><span class=\"line\">3.改变节点内部文字结构：</span><br><span class=\"line\"></span><br><span class=\"line\">text-align, overflow-y ,font-weight ,overflow, </span><br><span class=\"line\">font-family, line-height, vertival-align ,white-space,font-size</span><br></pre></td></tr></table></figure></p>\n<p>触发重绘的属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">color,border-style,border-radius ,visibility,text-decoration ,</span><br><span class=\"line\">background ,background-image ,background-position ,background-repeat,</span><br><span class=\"line\">background-size ,outline-color ,outline ,outline-style ,outline-width ,box-shadow</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"常见性能漏洞\">常见性能漏洞<a href=\"post/arc-12#常见性能漏洞\"></a></h2><h3 id=\"避免重绘\">避免重绘<a href=\"post/arc-12#避免重绘\"></a></h3><p>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。<br><strong>提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。</strong><br>前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.style.color = <span class=\"string\">'blue'</span>;</span><br><span class=\"line\">div.style.marginTop = <span class=\"string\">'30px'</span>;</span><br></pre></td></tr></table></div></figure>\n<p>上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。<br>如果写得不好，就会触发两次重排和重绘。这种情况也被称为 FSL <em>Forced Synchronous Layouts</em> 强制同步布局。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div.style.color = <span class=\"string\">'blue'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> margin = <span class=\"built_in\">parseInt</span>(div.style.marginTop);</span><br><span class=\"line\">div.style.marginTop = (margin + <span class=\"number\">10</span>) + <span class=\"string\">'px'</span>;</span><br></pre></td></tr></table></div></figure>\n<p>上面代码对div元素设置背景色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。<br>一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。</p>\n<ul>\n<li>offsetTop/offsetLeft/offsetWidth/offsetHeight</li>\n<li>scrollTop/scrollLeft/scrollWidth/scrollHeight</li>\n<li>clientTop/clientLeft/clientWidth/clientHeight</li>\n<li>getComputedStyle()</li>\n</ul>\n<p>所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">div.style.left = div.offsetLeft + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">div.style.top = div.offsetTop + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// good</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> left = div.offsetLeft;</span><br><span class=\"line\"><span class=\"keyword\">var</span> top  = div.offsetTop;</span><br><span class=\"line\">div.style.left = left + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">div.style.top = top + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>;</span><br></pre></td></tr></table></div></figure>\n<p>一般的规则是：</p>\n<ul>\n<li>样式表越简单，重排和重绘就越快。</li>\n<li>重排和重绘的DOM元素层级越高，成本就越高。</li>\n<li>table元素的重排和重绘成本，要高于div元素</li>\n</ul>\n<h2 id=\"常用优化方法\">常用优化方法<a href=\"post/arc-12#常用优化方法\"></a></h2><h3 id=\"浏览器优化\">浏览器优化<a href=\"post/arc-12#浏览器优化\"></a></h3><h4 id=\"图片优化\">图片优化<a href=\"post/arc-12#图片优化\"></a></h4><p><strong>图片格式选择</strong>：<br>1.jpg图片</p>\n<p>特点是有损压缩、高质量压缩、体积小、加载快、不支持透明，适用于呈现色彩丰富的图片，适合用作背景图、轮播图或Banner图的格式</p>\n<p>2.png图片</p>\n<p>特点是无损压缩、高质量压缩、体积大、支持透明，适用于呈现小的Logo，或者颜色简单且对比强烈的图片或背景图的格式</p>\n<p>3.SVG图片</p>\n<p>特点是体积小，不失真，兼容性好，可压缩性强，可编程，渲染成本高，学习成本高，最适合带有大型渲染区域的应用程序（地图应用）</p>\n<p><strong>4.雪碧图</strong></p>\n<p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background- repeat，background-position 的组合进行背景定位。利用CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能；CSS Sprites能减少图片的字节。</p>\n<p>5.Base64</p>\n<p>对图片进行Base64编码，会得到一串字符串，浏览器会直接将这串字符串解码为图片，这样就不用发送http请求了，但是这样的缺点是图片会膨胀，体积会增加，所以它的应用条件是：图片尺寸小、无法用雪碧图、图片更新频率低（不需要我们重复编码和修改文件内容，维护成本较低）</p>\n<p><strong>6.webP</strong></p>\n<p>集各种格式的优点于一身，缺点就是<strong>兼容性</strong>不好，所以应用时需要判断浏览器</p>\n<p><strong>图片懒加载</strong>，就是当图片出现在浏览器的可视区域内时，设置图片真正的路径，让图片显示出来。当一个页面中由许多图片时，使用懒加载，可大大提高页面性能。</p>\n<p>具体完成过程为，先给图片一个假的src,不让图片加载，通过监听滚动时间+函数节流，来完成判断元素距离可视区域顶部的高度，要是高度差&gt;=0，那么就将正确的src赋给图片，图片完成加载。</p>\n<h4 id=\"缓存优化\">缓存优化<a href=\"post/arc-12#缓存优化\"></a></h4><h5 id=\"浏览器缓存机制\">浏览器缓存机制<a href=\"post/arc-12#浏览器缓存机制\"></a></h5><p>1.MemoryCache，即在内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。</p>\n<p>2.Services Worker Cache，Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，可利用这一点帮我们实现离线缓存、消息推送和网络代理等功能</p>\n<p>3.Http缓存，分为强缓存和协商缓存</p>\n<p>http缓存的是指:当Web请求抵达缓存时， 如果本地有“已缓存的”副本，就可以从本地存储设备而不是从原始服务器中提取这个文档</p>\n<p>强缓存（优先于协商缓存，返回码200）：</p>\n<p>利用Expires（http1.0，记录缓存过期时间）和Cache-Control（http1.1，记录缓存过期时间）来控制，Cache-Control优先级高于Expires，Expires 使用的是服务器端的时间，要是客户端时间和服务端不同步，就可能造成浏览器本地的缓存无用或者一直无法过期，Cache-Control使用的是使用的是客户端本地时间的计算，所以不会出现上述情况，Cache-Control优先级高于Expires，</p>\n<p>协商缓存（返回码304）：</p>\n<p>利用If-None-Match（请求头）/Etag（响应头）和If-Modified-Since（请求头）/Last-Modified（响应头），If-None-Match和Etag记录的是服务器为每个资源生成的唯一的标识字符串，缓存的数据要是改变了，那么这两个数据就会变，这样可判断缓存到底有没有更新，If-Modified-Since和Last-Modified记录的是服务端的文件最后改变的时间，通过判断这个，可以缓存有没有被更新，Last-Modified有一个缺陷就是只能精确到1s，所以对于精确更高的可能不适用，Etag优先级高于Last-Modified，Etag生成过程需要服务器额外付出开销，会影响服务器性能，所以要看情况使用Etag</p>\n<p>4.Push Cache</p>\n<p>http2阶段的缓存，应用尚处于萌芽阶段，是缓存的最后一道防线。</p>\n<p>浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。</p>\n<h5 id=\"本地存储机制\">本地存储机制<a href=\"post/arc-12#本地存储机制\"></a></h5><p>1.利用WebStorage</p>\n<p>WebStorage提供了一种方式让网站能够把信息存储到本地的计算机上，并在以后需要的时候进行获取。这样一来，当需要用到什么资源时，可以直接在本地存储里获取，而不用发起网络请求等待响应。WebStorage分为localStorage（只支持string类型的存储）与Session Storage（只支持string类型的存储），Session Storage在会话结束消失， localStorage永久有效，手动删除才会消失，Session Storage 和localStorage都遵循同源策略，但是对Session Storage特殊的一定在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享。</p>\n<p>2.利用IndexDB</p>\n<p>IndexDB运行在浏览器上的非关系型数据库，突破了WebStorage的存储大小限制，支持存储字符串和二进制数据，IndexDB可创建数据库和表，可以被当成一个真正的数据库使用。</p>\n<h3 id=\"CSS-优化\">CSS 优化<a href=\"post/arc-12#CSS-优化\"></a></h3><h4 id=\"选择器\">选择器<a href=\"post/arc-12#选择器\"></a></h4><p>css是从右往左进行解析的，这也就是说 (ul&gt;li)这种写法，浏览器是先去找到li，再去看每个li的父元素是不是ul,当使用层级较多的选择器时（如：body&gt;div&gt;p&gt;span），会加大浏览器的寻找时间，而我们的原则因当是使浏览器能够尽快的找到相应的元素。所以css选择器方面的优化方案为：</p>\n<ul>\n<li>避免后代选择符(后代选择器的开销很高)</li>\n<li>避免链式选择符，避免使用复杂的选择器，层级越少越好</li>\n<li>避免使用通配符（使用通配符会使浏览器找遍所有的元素）</li>\n<li>少用标签选择器，尽量用类选择器代替</li>\n<li>避免不必要的重复</li>\n</ul>\n<h4 id=\"减少-CSS-阻塞\">减少 CSS 阻塞<a href=\"post/arc-12#减少-CSS-阻塞\"></a></h4><p>当我们在html时，总是在解析到link标签或style标签时，CSSDOM才会开始构建，这个构建过程会导致DOM解析的阻塞，所以为了减少阻塞时间，我们需要尽快完成加载（启用CDN），尽早完成加载（在head元素中引用css相关标签）</p>\n<h3 id=\"JavaScript-优化\">JavaScript 优化<a href=\"post/arc-12#JavaScript-优化\"></a></h3><h4 id=\"window-requestAnimationFrame\">window.requestAnimationFrame()<a href=\"post/arc-12#window-requestAnimationFrame\"></a></h4><p>即便你能保证每一帧的总耗时都小于16ms，也无法保证一定不会出现丢帧的情况，这取决于触发JS执行的方式。<br>假设使用 <code>setTimeout</code> 或 <code>setInterval</code> 来触发JS执行并修改样式从而导致视觉变化；那么会有这样一种情况，因为<code>setTimeout</code> 或 <code>setInterval</code>没有办法保证回调函数什么时候执行，它可能在每一帧的中间执行，也可能在每一帧的最后执行。所以会导致即便我们能保障每一帧的总耗时小于<strong>16ms</strong>，但是执行的时机如果在每一帧的中间或最后，最后的结果依然是没有办法每隔16ms让屏幕产生一次变化。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/31/5ca0806c5d89f.png\" alt=\"5ca0806c5d89f.png\" data-zoomable></p></div>\n<p>即便我们能保证每一帧总体时间小于<strong>16ms</strong>，但如果使用定时器触发动画，那么由于定时器的触发时机不确定，所以还是会导致动画丢帧。现在整个Web只有一个API可以解决这个问题，那就是requestAnimationFrame，它可以<strong>保证回调函数稳定的在每一帧最开始触发</strong>。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/31/5ca080735f5b4.png\" alt=\"5ca080735f5b4.png\" data-zoomable></p></div>\n<p>应用了 RAF 的网页动画例子：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> rAF = <span class=\"built_in\">window</span>.requestAnimationFrame;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> degrees = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">update</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  div.style.transform = <span class=\"string\">\"rotate(\"</span> + degrees + <span class=\"string\">\"deg)\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'updated to degrees '</span> + degrees);</span><br><span class=\"line\">  degrees = degrees + <span class=\"number\">1</span>;</span><br><span class=\"line\">  rAF(update);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">rAF(update);</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"window-requestIdleCallback\">window.requestIdleCallback()<a href=\"post/arc-12#window-requestIdleCallback\"></a></h4><p>还有一个函数 <a href=\"https://w3c.github.io/requestidlecallback/\" target=\"_blank\" rel=\"noopener\">window.requestIdleCallback()</a> ，也可以用来调节重新渲染。<br>它指定只有当一帧的末尾有空闲时间，才会执行回调函数。</p>\n<h4 id=\"减少JS阻塞\">减少JS阻塞<a href=\"post/arc-12#减少JS阻塞\"></a></h4><p>页面构建dom树的过程，即从上到下解析HTML文档生成DOM节点树，当解析到<code>&lt;script&gt;</code>标签时，会解析其中的脚本（对于外链的JavaScript文件，需要先加载该文件内容），然后立即执行，这整个过程都会阻塞文档解析，直到脚本执行完才会继续解析文档。如果js文件的数量和内容都比较大，那么就会造成页面空白，所以为了避免这一状况，应该把 <code>&lt;script&gt;</code>标签放在<code>&lt;/body&gt;</code>标签前面，而不是放在<code>&lt;head&gt;</code>标签里,要使用async(异步加载，脚本加载完立刻执行)和defer(异步加载，文档解析完执行)</p>\n<h4 id=\"在异步任务中实现-DOM-修改时，把它包装成-micro-任务-微任务）\">在异步任务中实现 DOM 修改时，把它包装成 micro 任务(微任务）<a href=\"post/arc-12#在异步任务中实现-DOM-修改时，把它包装成-micro-任务-微任务）\"></a></h4><p>事件循环一般是这样，先处理Macro-task（宏任务）,再处理micro 任务，micro 任务处理完后面紧跟着就是渲染的步骤，然后更新界面，处理Web work任务。包装成 micro 任务，这样不用等新的一轮事件循环，直接渲染呈现</p>\n<h4 id=\"Dom方面（从减少页面回流方面来考虑）\">Dom方面（从减少页面回流方面来考虑）<a href=\"post/arc-12#Dom方面（从减少页面回流方面来考虑）\"></a></h4><p>减少Dom操作，缓存dom变量<br><code>var a=document.querySelector(&quot;#demo&quot;);</code></p>\n<p>避免循环更改dom，在更改时创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到相应dom中</p>\n<p>在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比<strong>数组要差很多</strong>，原因是这个集合并不是一个<strong>静态</strong>的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会<strong>重新执行</strong>这个查询从而更新查询结果。所谓的 “访问集合” 包括读取集合的 length属性、访问集合中的元素。<br>　　因此，当你需要遍历 HTML Collection的时候，<strong>尽量将它转为数组后再访问</strong>，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。</p>\n<h4 id=\"代码方面\">代码方面<a href=\"post/arc-12#代码方面\"></a></h4><p><strong>慎用 with</strong><br>with 在蝴蝶书里面就被明确的视为禁术，他会延长当前对象的作用域链，使得查找作用域的性能大大降低，请不要因为懒得写几行代码就直接使用 with 。可是使用局部变量来代替 with。</p>\n<p><strong>避免使用 eval 和 Function</strong><br>每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 <strong>100倍以上。</strong><br>eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。<br>Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。<br>此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。</p>\n<h3 id=\"Vue-优化\">Vue 优化<a href=\"post/arc-12#Vue-优化\"></a></h3><h4 id=\"使用v-if代替v-show\">使用v-if代替v-show<a href=\"post/arc-12#使用v-if代替v-show\"></a></h4><p>两者的区别是：v-if不渲染DOM，v-show会预渲染DOM<br>除以下情况使用v-show，其他情况尽量使用v-if</p>\n<ul>\n<li>有预渲染需求</li>\n<li>需要频繁切换显示状态</li>\n</ul>\n<h4 id=\"v-for必须加上key，并避免同时使用v-if\">v-for必须加上key，并避免同时使用v-if<a href=\"post/arc-12#v-for必须加上key，并避免同时使用v-if\"></a></h4><p>一般我们在两种常见的情况下会倾向于这样做:</p>\n<ul>\n<li>为了过滤一个列表中的项目<br>比如<code>v-for=“user in users” v-if=“user.isActive”</code>。在这种情形下，请将users替换为一个<strong>计算属性</strong> (比如activeUsers)，让其返回过滤后的列表</li>\n<li>为了避免渲染本应该被隐藏的列表<br>比如<code>v-for=“user in users” v-if=“shouldShowUsers”</code>。这种情形下，请将v-if移动至容器元素上 (比如ul,ol)</li>\n</ul>\n<h4 id=\"事件及时销毁\">事件及时销毁<a href=\"post/arc-12#事件及时销毁\"></a></h4><p>Vue组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。<br>也就是说，在js内使用addEventListener等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">created() &#123;</span><br><span class=\"line\">  addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"keyword\">this</span>.touchmove, <span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">beforeDestroy() &#123;</span><br><span class=\"line\">  removeEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"keyword\">this</span>.touchmove, <span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"资源提前请求\">资源提前请求<a href=\"post/arc-12#资源提前请求\"></a></h4><p>经测试，Vue项目中各文件的加载顺序为：router.js、main.js、App.vue、[page].vue、[component].vue，如图：</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/31/5ca082ae567e8.png\" alt=\"5ca082ae567e8.png\" data-zoomable></p></div>\n<p>其中，router的加载时间相比于page.vue快近100ms，如果page.vue的文件较多，时间差异会更大。 所以，可以在页面挂载、渲染的同时去请求接口数据，如在router.js中请求数据：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Router <span class=\"keyword\">from</span> <span class=\"string\">'vue-router'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">'./store'</span></span><br><span class=\"line\"></span><br><span class=\"line\">store.dispatch(<span class=\"string\">'initAjax'</span>)</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"多使用异步组件和插件\">多使用异步组件和插件<a href=\"post/arc-12#多使用异步组件和插件\"></a></h4><p>不需要首屏加载的组件都使用异步组件的方式来加载，如多 tab。包括需要触发条件的动作也使用异步组件（如弹窗） 使用方式为：v-if来控制显示时机，引入组件的Promise即可。</p>\n<h3 id=\"网络优化\">网络优化<a href=\"post/arc-12#网络优化\"></a></h3><h4 id=\"减少网络请求\">减少网络请求<a href=\"post/arc-12#减少网络请求\"></a></h4><blockquote>\n<p>浏览器对同一时间针对同一域名下的请求有一定数量限制（一般是6个），超过限制数目的请求会被阻塞  </p>\n</blockquote>\n<p>首屏尽可能减少同域名的请求，包括接口和js；按需减少首屏的chunk.js，合并接口请求</p>\n<h4 id=\"DNS-解析优化\">DNS 解析优化<a href=\"post/arc-12#DNS-解析优化\"></a></h4><p>DNS 缓存 -&gt; 减少 DNS 解析时间<br>keep-alive 减少链接建立次数。</p>\n<h4 id=\"CDN-和-SSR\">CDN 和 SSR<a href=\"post/arc-12#CDN-和-SSR\"></a></h4><p>CDN全称是内容分发网络，简单的来说，CDN做的事，就是把资源存在离自己最近的服务器里，从而实现就近访问数据，快速获取到需要的数据</p>\n<p>CDN 往往被用来存放静态资源(像 JS、CSS、图片等不需要业务服务器进行计算即得的资源),可以将静态资源和主页面置于不同的域名下，避免cookie的携带，这样可以做到优化CDN</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/03/31/5ca082c42434d.png\" alt=\"5ca082c42434d.png\" data-zoomable></p></div>\n<p>服务端渲染，就是当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容。</p>\n<p>没有服务器渲染，当浏览器解析html文档解析到<code>&lt;script&gt;</code>标签时，就需要停下html渲染，去解析其中的脚本并执行，这整个过程都会阻塞文档解析，直到脚本执行完才会继续解析文档进行渲染。如果js文件的数量和内容都比较大，那么就会造成页面空白，这样是非常不利于用户体验的，服务器渲染就能很好的解决这一问题。</p>\n<p>服务端渲染也不是随便就能用的，它加重了服务器的压力，也需要合理使用</p>\n<h2 id=\"Reference\">Reference<a href=\"post/arc-12#Reference\"></a></h2><p><a href=\"https://juejin.im/post/5c874d9ce51d4574bd6ad8ca\" target=\"_blank\" rel=\"noopener\">让你的网页更丝滑（一） - 掘金</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html\" target=\"_blank\" rel=\"noopener\">网页性能管理详解 - 阮一峰的网络日志</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2017/09/flame-graph.html\" target=\"_blank\" rel=\"noopener\">如何读懂火焰图？ - 阮一峰的网络日志</a></p>\n<p><a href=\"http://www.cnblogs.com/coober/p/8078847.html\" target=\"_blank\" rel=\"noopener\">前端性能优化方案都有哪些？ - coober - 博客园</a></p>\n<p><a href=\"https://blog.csdn.net/loisandyu/article/details/83348763\" target=\"_blank\" rel=\"noopener\">掘金小册前端性能优化原理与实践读后总结 - loisandyu的博客 - CSDN博客</a></p>\n<p><a href=\"https://blog.csdn.net/coolmeme/article/details/9468743?utm_source=blogxgwz0\" target=\"_blank\" rel=\"noopener\">一张图说明CDN网络的原理 - coolme的专栏 - CSDN博客</a></p>\n<p><a href=\"https://juejin.im/post/5c4e6d7951882522c03ea809\" target=\"_blank\" rel=\"noopener\">从4个方面优化你的Vue项目 - 掘金</a></p>\n<p><a href=\"https://juejin.im/post/5b9214c2f265da0aeb70e36e\" target=\"_blank\" rel=\"noopener\">2018你应该知道的Web性能信息采集指南 - 掘金</a></p>\n","prev":{"title":"从 URL 到显示网页到底发生了什么（前端满分回答考虑缓存存在无敌终极版本）","link":"post/arc-14"},"next":{"title":"前端工程师技术图谱","link":"post/arc-11"},"plink":"https://xkeith.space/post/arc-12/","toc":[{"title":"基础知识","id":"基础知识","index":"1","children":[{"title":"RAIL","id":"RAIL","index":"1.1","children":[{"title":"响应","id":"响应","index":"1.1.1"},{"title":"动画","id":"动画","index":"1.1.2"},{"title":"空闲","id":"空闲","index":"1.1.3"},{"title":"加载","id":"加载","index":"1.1.4"}]},{"title":"网页生成的过程","id":"网页生成的过程","index":"1.2"},{"title":"重排和重绘","id":"重排和重绘","index":"1.3"}]},{"title":"常见性能漏洞","id":"常见性能漏洞","index":"2","children":[{"title":"避免重绘","id":"避免重绘","index":"2.1"}]},{"title":"常用优化方法","id":"常用优化方法","index":"3","children":[{"title":"浏览器优化","id":"浏览器优化","index":"3.1","children":[{"title":"图片优化","id":"图片优化","index":"3.1.1"},{"title":"缓存优化","id":"缓存优化","index":"3.1.2"}]},{"title":"CSS 优化","id":"CSS-优化","index":"3.2","children":[{"title":"选择器","id":"选择器","index":"3.2.1"},{"title":"减少 CSS 阻塞","id":"减少-CSS-阻塞","index":"3.2.2"}]},{"title":"JavaScript 优化","id":"JavaScript-优化","index":"3.3","children":[{"title":"window.requestAnimationFrame()","id":"window-requestAnimationFrame","index":"3.3.1"},{"title":"window.requestIdleCallback()","id":"window-requestIdleCallback","index":"3.3.2"},{"title":"减少JS阻塞","id":"减少JS阻塞","index":"3.3.3"},{"title":"在异步任务中实现 DOM 修改时，把它包装成 micro 任务(微任务）","id":"在异步任务中实现-DOM-修改时，把它包装成-micro-任务-微任务）","index":"3.3.4"},{"title":"Dom方面（从减少页面回流方面来考虑）","id":"Dom方面（从减少页面回流方面来考虑）","index":"3.3.5"},{"title":"代码方面","id":"代码方面","index":"3.3.6"}]},{"title":"Vue 优化","id":"Vue-优化","index":"3.4","children":[{"title":"使用v-if代替v-show","id":"使用v-if代替v-show","index":"3.4.1"},{"title":"v-for必须加上key，并避免同时使用v-if","id":"v-for必须加上key，并避免同时使用v-if","index":"3.4.2"},{"title":"事件及时销毁","id":"事件及时销毁","index":"3.4.3"},{"title":"资源提前请求","id":"资源提前请求","index":"3.4.4"},{"title":"多使用异步组件和插件","id":"多使用异步组件和插件","index":"3.4.5"}]},{"title":"网络优化","id":"网络优化","index":"3.5","children":[{"title":"减少网络请求","id":"减少网络请求","index":"3.5.1"},{"title":"DNS 解析优化","id":"DNS-解析优化","index":"3.5.2"},{"title":"CDN 和 SSR","id":"CDN-和-SSR","index":"3.5.3"}]}]},{"title":"Reference","id":"Reference","index":"4"}]}