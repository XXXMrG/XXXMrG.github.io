{"title":"小谈防抖和节流","date":"2019-04-13T13:33:39.000Z","link":"post/arc-16","tags":["front_end"],"categories":["前端"],"updated":"2019-04-13T13:35:22.444Z","content":"<hr>\n<p>在进行窗口的<code>resize</code>、<code>scroll</code>，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会产生大量 DOM 重绘，使浏览器性能下降，导致用户体验非常糟糕。此时我们可以采用<em>debounce（防抖）</em>和<em>throttle（节流）</em>的方式来减少调用频率，同时又不影响实际效果。</p>\n<h2 id=\"函数防抖\">函数防抖<a href=\"post/arc-16#函数防抖\"></a></h2><p>函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/04/13/5cb1e56c3e109.png\" alt=\"5cb1e56c3e109.png\" data-zoomable></p></div>\n<p><strong>防抖最常见的使用场景就是带有即时搜索功能的文本框了，如果每输入一个字符都要进行一次请求的话会大大拖慢性能，因此在结束输入的一段时间后再发起请求是比较常见的防止页面抖动的方式。</strong></p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        timeout &amp;&amp; clearTimeout(timeout);</span><br><span class=\"line\">        timeout = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            fn.call(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"函数节流\">函数节流<a href=\"post/arc-16#函数节流\"></a></h2><p>函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/04/13/5cb1e579c3f81.png\" alt=\"5cb1e579c3f81.png\" data-zoomable></p></div>\n<p><strong>节流最常见的使用场景就是资源懒加载的时候要计算滚动条的位置，如果用户反复触发滚动条移动会使得多次触发计算，我们常常使用节流按一定的时间频率获取滚动条位置。</strong><br><strong>或者在用户提交的时候，我们在已知接口大致返回时间的情况下，可以使用节流限制用户的请求频率。</strong><br>事件的重复触发并不会使得函数彻底停止触发，而是让其按照给定的时间触发。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节流函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> canRun = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!canRun) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 这句话是用来防止多次重复触发的关键</span></span><br><span class=\"line\">        canRun = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            fn.call(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">            canRun = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"Reference\">Reference<a href=\"post/arc-16#Reference\"></a></h2><p><a href=\"https://mp.weixin.qq.com/s/Vkshf-nEDwo2ODUJhxgzVA\" target=\"_blank\" rel=\"noopener\">JS的防抖与节流</a><br><a href=\"https://juejin.im/post/5c87b54ce51d455f7943dddb#chapter-three\" target=\"_blank\" rel=\"noopener\">2019 面试准备 - JS 防抖与节流 - 掘金</a></p>\n","prev":{"title":"如何拿下前端面试（Promise 和异步编程详解）","link":"post/arc-17"},"next":{"title":"如何拿下前端面试（函数和上下文闭包）","link":"post/arc-15"},"plink":"https://xkeith.space/post/arc-16/","toc":[{"title":"函数防抖","id":"函数防抖","index":"1"},{"title":"函数节流","id":"函数节流","index":"2"},{"title":"Reference","id":"Reference","index":"3"}]}