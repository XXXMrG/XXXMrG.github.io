{"title":"如何拿下前端面试（Promise 和异步编程详解）","date":"2019-04-13T13:37:59.000Z","link":"post/arc-17","tags":["front_end"],"categories":["前端"],"updated":"2019-04-13T13:39:35.364Z","content":"<hr>\n<blockquote>\n<p>在JavaScript中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行。  </p>\n</blockquote>\n<h2 id=\"浏览器线程\">浏览器线程<a href=\"post/arc-17#浏览器线程\"></a></h2><p>浏览器的内核是多线程的，他们在内核控制下相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>\n<ul>\n<li>GUI 渲染线程</li>\n<li>JavaScript 引擎线程</li>\n<li>浏览器事件触发线程</li>\n<li>定时触发器线程</li>\n<li>异步 HTTP 请求线程</li>\n</ul>\n<h3 id=\"几种常见的异步编程方案\">几种常见的异步编程方案<a href=\"post/arc-17#几种常见的异步编程方案\"></a></h3><ul>\n<li>回调函数</li>\n<li>事件监听</li>\n<li>发布 / 订阅</li>\n<li>Promise</li>\n</ul>\n<h3 id=\"GUI-渲染线程\">GUI 渲染线程<a href=\"post/arc-17#GUI-渲染线程\"></a></h3><p>负责渲染浏览器界面 HTML 元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在 Javascript 引擎运行脚本期间, GUI 渲染线程都是处于挂起状态的,也就是说被<strong>”冻结”</strong>。即 GUI 渲染线程与 JS 引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</p>\n<h3 id=\"JavaScript-引擎线程\">JavaScript 引擎线程<a href=\"post/arc-17#JavaScript-引擎线程\"></a></h3><p>也可以称为 JS 内核，主要负责处理 Javascript 脚本程序，例如 V8 引擎。Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。浏览器无论什么时候都只有一个 JS 线程在运行 JS 程序。</p>\n<h3 id=\"浏览器事件触发线程\">浏览器事件触发线程<a href=\"post/arc-17#浏览器事件触发线程\"></a></h3><p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于JS的单线程关系所有这些事件都得排队等待 JS 引擎处理。</p>\n<h3 id=\"定时触发器线程\">定时触发器线程<a href=\"post/arc-17#定时触发器线程\"></a></h3><p>浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 javaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</p>\n<h3 id=\"异步-HTTP-请求线程\">异步 HTTP 请求线程<a href=\"post/arc-17#异步-HTTP-请求线程\"></a></h3><p>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。</p>\n<h3 id=\"线程工作\">线程工作<a href=\"post/arc-17#线程工作\"></a></h3><p>例子1:异步请求是由线程 JavaScript 执行线程、HTTP 请求线程 和 事件触发线程 共同完成的。JavaScript 执行线程 执行异步请求代码，这时浏览器会开一条<strong>新的 HTTP 请求线程 来执行请求</strong>，JavaScript 执行线程则继续执行 执行队列 中剩下的其他任务。然后在未来的某一时刻 事件触发线程 监视到之前的发起的 HTTP 请求已完成，它就会把完成事件的<strong>回调代码</strong>插入到 JavaScript <strong>执行队列尾部</strong> 等待 JavaScript 执行线程空闲时来处理。<br>例子2:定时触发（setTimeout 和 setInterval）是由浏览器的 定时器线程 执行的定时计数，然后在定时时间结束时把定时处理函数的执行代码插入到 JavaScript 执行队列的<strong>尾端（所以用这两个函数的时候，实际的执行时间是大于或等于指定时间的，不保证能准确定时的）</strong>。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/04/13/5cb1e679e49c3.png\" alt=\"5cb1e679e49c3.png\" data-zoomable></p></div>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/04/13/5cb1e6844458e.png\" alt=\"5cb1e6844458e.png\" data-zoomable></p></div>\n<p><strong>主线程在执行完当前循环中的所有代码后，就会到任务（消息）队列取出一条消息，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，工作线程就没必要通知主线程，从而也没必要往消息队列放消息。</strong></p>\n<h3 id=\"setTimeout-fn-0-的作用\">setTimeout(fn, 0) 的作用<a href=\"post/arc-17#setTimeout-fn-0-的作用\"></a></h3><p>理解了浏览器异步任务的执行过程我们就会知道，将一个任务设置成零延迟并不意味着立即执行该任务，该任务仍然要被加入异步队列中，等待主线程结束，并且异步队列前面的任务也结束才执行。<br>在某种程度上，我们可以利用setTimeout(fn,0)的特性，修正浏览器的任务顺序。</p>\n<h2 id=\"Promise\">Promise<a href=\"post/arc-17#Promise\"></a></h2><h3 id=\"描述\">描述<a href=\"post/arc-17#描述\"></a></h3><p><strong>Promise</strong>对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p>\n<p>一个Promise有以下几种状态:</p>\n<ul>\n<li>pending: 初始状态，既不是成功，也不是失败状态。</li>\n<li>fulfilled: 意味着操作成功完成。</li>\n<li>rejected: 意味着操作失败。<br>pending 状态的 Promise 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的then方法绑定的处理方法（handlers）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。<br>因为 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then\" target=\"_blank\" rel=\"noopener\">Promise.prototype.then</a> 和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch\" target=\"_blank\" rel=\"noopener\">Promise.prototype.catch</a> 方法返回promise 对象， 所以它们可以被链式调用。</li>\n</ul>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/04/13/5cb1e68f0581c.png\" alt=\"5cb1e68f0581c.png\" data-zoomable></p></div>\n<h3 id=\"常见错误\">常见错误<a href=\"post/arc-17#常见错误\"></a></h3><p>在编写 Promise 链时，需要注意以下示例中展示的几个错误：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误示例，包含 3 个问题</span></span><br><span class=\"line\"></span><br><span class=\"line\">doSomething().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  doSomethingElse(result) <span class=\"comment\">// 没有返回 Promise 以及没有必要的嵌套 Promise</span></span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">newResult</span> =&gt;</span> doThirdThing(newResult));</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> doFourthThing());</span><br><span class=\"line\"><span class=\"comment\">// 最后是没有使用 catch 终止 Promise 调用链，可能导致没有捕获的异常</span></span><br></pre></td></tr></table></div></figure>\n<p>第一个错误是没有正确地将事物相连接。当我们创建新 Promise 但忘记返回它时，会发生这种情况。因此，链条被打破，或者更确切地说，我们有两个独立的链条竞争<strong>（同时在执行两个异步而非一个一个的执行）</strong>。这意味着doFourthThing()不会等待doSomethingElse()或doThirdThing()完成，并且将与它们并行运行，可能是无意的。单独的链也有单独的错误处理，导致未捕获的错误。<br>第二个错误是不必要地嵌套，实现第一个错误。嵌套还限制了内部错误处理程序的范围，如果是非预期的，可能会导致未捕获的错误。其中一个变体是 <a href=\"https://stackoverflow.com/questions/23803743/what-is-the-explicit-promise-construction-antipattern-and-how-do-i-avoid-it\" target=\"_blank\" rel=\"noopener\">promise 构造函数反模式</a> ，它结合了 Promise 构造函数的多余使用和嵌套。<br>第三个错误是忘记用catch终止链。这导致在大多数浏览器中不能终止的 Promise 链里的 rejection。<br>一个好的经验法则是总是返回或终止 Promise 链，并且一旦你得到一个新的 Promise，返回它。下面是修改后的平面化的代码：</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> doSomethingElse(result);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">newResult</span> =&gt;</span> doThirdThing(newResult))</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> doFourthThing());</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> <span class=\"built_in\">console</span>.log(error));</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"async-await\">async / await<a href=\"post/arc-17#async-await\"></a></h2><h2 id=\"Reference\">Reference<a href=\"post/arc-17#Reference\"></a></h2><p><a href=\"https://juejin.im/post/59c25c936fb9a00a3f24e114\" target=\"_blank\" rel=\"noopener\">【 js 基础 】 setTimeout(fn, 0) 的作用 - 掘金</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises\" target=\"_blank\" rel=\"noopener\">使用 Promises - JavaScript | MDN</a><br><a href=\"https://juejin.im/post/5b31a4b7f265da595725f322\" target=\"_blank\" rel=\"noopener\">面试精选之Promise - 掘金</a><br><a href=\"https://juejin.im/post/5aa7868b6fb9a028dd4de672\" target=\"_blank\" rel=\"noopener\">Promise原理讲解 &amp;&amp; 实现一个Promise对象 (遵循Promise/A+规范) - 掘金</a></p>\n","prev":{"title":"浅谈博弈论（Nim 游戏）","link":"post/arc-18"},"next":{"title":"小谈防抖和节流","link":"post/arc-16"},"plink":"https://xkeith.space/post/arc-17/","toc":[{"title":"浏览器线程","id":"浏览器线程","index":"1","children":[{"title":"几种常见的异步编程方案","id":"几种常见的异步编程方案","index":"1.1"},{"title":"GUI 渲染线程","id":"GUI-渲染线程","index":"1.2"},{"title":"JavaScript 引擎线程","id":"JavaScript-引擎线程","index":"1.3"},{"title":"浏览器事件触发线程","id":"浏览器事件触发线程","index":"1.4"},{"title":"定时触发器线程","id":"定时触发器线程","index":"1.5"},{"title":"异步 HTTP 请求线程","id":"异步-HTTP-请求线程","index":"1.6"},{"title":"线程工作","id":"线程工作","index":"1.7"},{"title":"setTimeout(fn, 0) 的作用","id":"setTimeout-fn-0-的作用","index":"1.8"}]},{"title":"Promise","id":"Promise","index":"2","children":[{"title":"描述","id":"描述","index":"2.1"},{"title":"常见错误","id":"常见错误","index":"2.2"}]},{"title":"Reference","id":"Reference","index":"3"}]}