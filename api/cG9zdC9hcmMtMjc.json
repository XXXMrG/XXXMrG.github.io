{"title":"搞定 node","date":"2019-06-26T12:43:14.000Z","thumbnail":"https://i.loli.net/2019/06/26/5d1368c49367d72234.png","color":"#111","link":"post/arc-27","tags":["node"],"categories":["前端"],"updated":"2019-06-26T13:03:52.722Z","content":"<blockquote>\n<p>一切能用 JavaScript 实现的软件都必有其 JavaScript 版本。</p>\n</blockquote>\n<p>我们要知道 node 并非一种语言，他仅仅是一种 JavaScript 执行环境，得益于 Google 的 v8 引擎的高性能，node 环境下的服务端在处理 IO 密集型任务的时候的效率相当的高，node 同样支持微服务架构。<br><a id=\"more\"></a></p>\n<h2 id=\"node-事件循环\">node 事件循环<a href=\"post/arc-27#node-事件循环\"></a></h2><p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。<br>Node.js 几乎每一个 API 都是支持回调函数的。<br>Node.js 基本上所有的事件机制都是用<strong>设计模式中观察者模式</strong>实现。<br>Node.js 单线程类似进入一个<code>while(true)</code>的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p>\n<h3 id=\"事件驱动程序\">事件驱动程序<a href=\"post/arc-27#事件驱动程序\"></a></h3><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。<br>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。<br>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）<br>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/06/26/5d136d376b9e980702.jpg\" alt=\"5d136d376b9e980702.jpg\" data-zoomable></p></div>\n","prev":{"title":"Redux 哲学","link":"post/arc-28"},"next":{"title":"Airbnb JavaScript Style Guide","link":"post/arc-26"},"plink":"https://xkeith.space/post/arc-27/","toc":[{"title":"node 事件循环","id":"node-事件循环","index":"1","children":[{"title":"事件驱动程序","id":"事件驱动程序","index":"1.1"}]}]}