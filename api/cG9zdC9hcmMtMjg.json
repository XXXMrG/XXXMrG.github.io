{"title":"Redux 哲学","date":"2019-07-16T14:05:53.000Z","thumbnail":"https://i.loli.net/2019/07/16/5d2dda4196d9b25564.png","color":"#111","link":"post/arc-28","tags":["React"],"categories":["前端"],"updated":"2019-07-16T14:09:19.604Z","content":"<p>Redux is a predictable state container for JavaScript apps.</p>\n<p>It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as live code editing combined with a time traveling debugger.<br><a id=\"more\"></a></p>\n<h2 id=\"Reducer\">Reducer<a href=\"post/arc-28#Reducer\"></a></h2><p>We’ll start by specifying the initial state. Redux will call our reducer with anundefinedstate for the first time. This is our chance to return the initial state of our app<br>关于 state 的默认值，首次 call reducer 的时候 state 的默认值是 undefined 我们可以通过 es6 的默认参数来指定默认初始值，或者保证每一个 reducer 中都有对于 undefined 的判断，这很重要，需要保证 reducer 在默认操作的时候返回原对象来避免不必要的重复渲染。</p>\n<h3 id=\"关于-combineReducers\">关于 combineReducers<a href=\"post/arc-28#关于-combineReducers\"></a></h3><p><strong>Note that each of these reducers is managing its own part of the global state. The state parameter is different for every reducer, and corresponds to the part of the state it manages.</strong><br>核心实现点在于 combine 的每一个 reducer 所对应的 key 都应该在 state 中能够找到相对应的 key 。<br>实际上 comboine  的 reducer 在每一次 dispatch 的时候都会被调用，同时分别进行比较，而匹配到的 action.type 则必然会触发其所对应的部分 state 的改变，因此会返回新的对象，而如果没有匹配项或者是 state 不变，那么就仍然会返回原对象，避免不必要的重复渲染。</p>\n<p><strong>我们要知道 redux 中的对象 diff 判断是简单的浅对比，即  ===  因此只要是返回一个新的对象就一定会引起重复 render</strong></p>\n<p><em>核心源码</em></p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> reducerKeys = <span class=\"built_in\">Object</span>.keys(reducers)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducers = &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// copy the reducers to a new object 并通过闭包保存</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = reducerKeys[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      finalReducers[key] = reducers[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(finalReducers)</span><br><span class=\"line\">  <span class=\"comment\">// 对外返回的格式就是一个普通的 reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combination</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shapeAssertionError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> shapeAssertionError</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> key = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> reducer = finalReducers[key]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> previousStateForKey = state[key]</span><br><span class=\"line\">      <span class=\"keyword\">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(errorMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      nextState[key] = nextStateForKey</span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"connect-到底是干特么啥的\">connect 到底是干特么啥的<a href=\"post/arc-28#connect-到底是干特么啥的\"></a></h2><p>更优雅且更常用的 store.subscribe() 用于在 store 更新的时候将数据通过 props 传递到使用了更新部分数据的组件，并触发该组件重新 render </p>\n<h2 id=\"store-是怎么和-compontents-关联到一起的\">store 是怎么和 compontents 关联到一起的<a href=\"post/arc-28#store-是怎么和-compontents-关联到一起的\"></a></h2><p><a href=\"https://react-redux.js.org/using-react-redux/connect-mapstate\" target=\"_blank\" rel=\"noopener\">Connect: Extracting Data with mapStateToProps · React Redux</a></p>\n<p>现在来创建一些容器组件把这些展示组件和 Redux 关联起来。技术上讲，容器组件就是使用 <a href=\"http://cn.redux.js.org/docs/api/Store.html#subscribe\" target=\"_blank\" rel=\"noopener\">store.subscribe()</a> 从 Redux state 树中读取部分数据，并通过 props 来把这些数据提供给要渲染的组件。你可以手工来开发容器组件，但建议使用 React Redux 库的 <a href=\"https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options\" target=\"_blank\" rel=\"noopener\">connect()</a> 方法来生成，这个方法做了性能优化来避免很多不必要的重复渲染。（这样你就不必为了性能而手动实现 <a href=\"https://doc.react-china.org/docs/optimizing-performance.html\" target=\"_blank\" rel=\"noopener\">React 性能优化建议</a> 中的shouldComponentUpdate方法。）</p>\n<p>As the first argument passed in toconnect,mapStateToPropsis used for selecting the part of the data from the store that the connected component needs. It’s frequently referred to as justmapStatefor short.</p>\n<p>connect 的第一个参数，通过 mapState 来过滤 store 中的与相连组件有关的数据，数据会通过 props 传递到组件内部。</p>\n<p><strong>state</strong><br>The first argument to a mapStateToPropsfunction is the entire Redux store state (the same value returned by a call tostore.getState()). Because of this, the first argument is traditionally just calledstate. (While you can give the argument any name you want, calling itstorewould be incorrect - it’s the “state value”, not the “store instance”.)<br>ThemapStateToPropsfunction should always be written with at leaststatepassed in.</p>\n<p><strong>ownProps**</strong>(optional)**<br>You may define the function with a second argument,ownProps, if your component needs the data from its own props to retrieve data from the store. This argument will contain all of the props given to the wrapper component that was generated byconnect.<br>通过 ownProps 得到组件使用的时候传入的 props 通常用于映射到另外一个 state 并连接到视图组件中。</p>\n<h2 id=\"在-connect-中发起-dispatch\">在 connect 中发起 dispatch<a href=\"post/arc-28#在-connect-中发起-dispatch\"></a></h2><p><a href=\"https://react-redux.js.org/using-react-redux/connect-mapdispatch\" target=\"_blank\" rel=\"noopener\">Connect: Dispatching Actions with mapDispatchToProps · React Redux</a></p>\n<p>dispatch 的发起方式有两种，一种是简单的从 <code>this.props.dispatch</code> 中直接调用，另外一种就是通过 connect 传递一个 具名化的 dispatch 给连接的组件供组件使用。</p>\n<p>Providing a mapDispatchToProps allows you to specify which actions your component might need to dispatch. It lets you provide action dispatching functions as props. Therefore, instead of calling props.dispatch(() =&gt; increment()),  you may call props.increment() directly. There are a few reasons why you might want to do that.</p>\n<p><strong>More Declarative</strong><br>First, encapsulating the dispatch logic into function makes the implementation more declarative. Dispatching an action and letting the Redux store handle the data flow is<em>how to</em>implement the behavior, rather than<em>what</em>it does.<br>A good example would be dispatching an action when a button is clicked. Connecting the button directly probably doesn’t make sense conceptually, and neither does having the button referencedispatch.<br>更直观，屏蔽组件对 dispatch 的存在，更关注与怎么做的层面。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// button needs to be aware of \"dispatch\"</span></span><br><span class=\"line\">&lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">\"SOMETHING\"</span> &#125;)&#125; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// button unaware of \"dispatch\",</span></span><br><span class=\"line\">&lt;button onClick=&#123;doSomething&#125; /&gt;</span><br></pre></td></tr></table></div></figure>\n<p>Once you’ve wrapped all our action creators with functions that dispatch the actions, the component is free of the need ofdispatch. Therefore,<strong>if you define your own <em>mapDispatchToProps</em>, the connected component will no longer receive dispatch</strong>.</p>\n<p><strong>Pass Down Action Dispatching Logic to ( Unconnected ) Child Components</strong></p>\n<p>In addition, <strong>you also gain the ability to pass down the action dispatching functions to child ( likely unconnected ) components</strong>. This allows more components to dispatch actions, while keeping them “unaware” of Redux.<br>通过传递 dispatch 可以让子组件也发起 dispatch 。即使这个子组件可能并没有直接与 store 相连。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pass down toggleTodo to child component</span></span><br><span class=\"line\"><span class=\"comment\">// making Todo able to dispatch the toggleTodo action</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> TodoList = <span class=\"function\">(<span class=\"params\">&#123; todos, toggleTodo &#125;</span>) =&gt;</span> (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;todos.map(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> (</span><br><span class=\"line\">      &lt;Todo todo=&#123;todo&#125; onClick=&#123;toggleTodo&#125; /&gt;</span><br><span class=\"line\">    ))&#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></div></figure>\n<blockquote>\n<p>This is what React Redux’s connect does — it encapsulates the logic of talking to the Redux store and lets you not worry about it. And this is what you should totally make full use of in your implementation.</p>\n</blockquote>\n<h2 id=\"middleware-又是干特么啥的\">middleware 又是干特么啥的<a href=\"post/arc-28#middleware-又是干特么啥的\"></a></h2><h2 id=\"Reference\">Reference<a href=\"post/arc-28#Reference\"></a></h2><p><a href=\"https://segmentfault.com/q/1010000019057564\" target=\"_blank\" rel=\"noopener\">javascript - 为什么action会触发所有reducers - SegmentFault 思否</a></p>\n","next":{"title":"搞定 node","link":"post/arc-27"},"plink":"https://xkeith.space/post/arc-28/","toc":[{"title":"Reducer","id":"Reducer","index":"1","children":[{"title":"关于 combineReducers","id":"关于-combineReducers","index":"1.1"}]},{"title":"connect 到底是干特么啥的","id":"connect-到底是干特么啥的","index":"2"},{"title":"store 是怎么和 compontents 关联到一起的","id":"store-是怎么和-compontents-关联到一起的","index":"3"},{"title":"在 connect 中发起 dispatch","id":"在-connect-中发起-dispatch","index":"4"},{"title":"Reference","id":"Reference","index":"5"}]}