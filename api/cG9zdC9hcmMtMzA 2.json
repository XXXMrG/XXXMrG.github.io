{"title":"函数式编程 in JavaScript","date":"2019-08-03T09:26:44.000Z","thumbnail":"https://i.loli.net/2019/08/04/V7loXmD21wbeiSC.jpg","color":"#111","link":"post/arc-30","tags":["JavaScript"],"categories":["前端"],"updated":"2019-08-04T13:07:44.228Z","content":"<blockquote>\n<p>对我来说，重大演变还是向更加函数式的风格的发展，它使得我们放弃很多旧的习惯，并从一些面向对象思想中逐渐退出。  —— John Carmack</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>函数式编程有别于我们传统的学习的面向对象编程，它使用函数来将值转换成抽象单元，接着用于构建软件系统。<br>不同于命令式编程的流水线编程方式，函数式编程并不需要事无巨细的将整个程序的流程编写出来，或者说在函数式编程中，程序通过一个个黑盒来进行数据的处理，通过黑盒的结合来得到结果，我们并不需要关系黑盒内部发生了什么，同时我们也一定要保证每一次黑盒的调用的相同输入会产生相同的输出。<br>函数式与面向对象编程的最大区别在于对问题的处理方式，面向对象编程指导我们将问题分解并组合，用实际生活的思想去思考编程风格，用对象组合来解决问题。而函数式编程的思考方式则更为直接，直接将问题提出到得出结果的流程抽象成多个函数处理结果的过程，通过用函数来分布计算输入得到输出结果。<br>而在函数式编程中最为重要的前提就是编程语言应将函数作为“一等公民”来处理，这意味着函数应该同其他基本类型是没有区别的，可以作为参数传入另一个函数，也可以作为函数的返回值，这就赋予了我们更多的处理函数的能力，如参数分解调用（Currying）纯函数。函数式编程赋予了 JavaScript 编程很多新的编程思想，这些编程思想在很多前端框架中广为使用，但函数式编程同样不仅仅是前端的专利，同时我们也不应落入函数式编程是“政治正确”的误区，保持程序的高效可维护，团队代码风格统一这些才应该是我们重点考虑的，函数式编程只是一种工具而已。<br><em>使之运行，使之正确，使之快速</em></p>\n<h2 id=\"高阶函数\">高阶函数<a href=\"post/arc-30#高阶函数\"></a></h2><h2 id=\"由函数构建函数\">由函数构建函数<a href=\"post/arc-30#由函数构建函数\"></a></h2><h2 id=\"递归\">递归<a href=\"post/arc-30#递归\"></a></h2><h2 id=\"纯度和不变性\">纯度和不变性<a href=\"post/arc-30#纯度和不变性\"></a></h2><h2 id=\"Mixin\">Mixin<a href=\"post/arc-30#Mixin\"></a></h2><p>Mixin 是一个从一开始被提出就饱受争议的模式，它实际上的核心思想仍然是面向对象编程中的继承和组合，只是在 JavaScript 中实现原型链继承的方式和其他语言有很大的不同，这种直接操作原型的方式一旦操作不当或是文档不健全的话会使得代码的可读性大大降低，代码中会出现很多从函数原理层就存在的<em>魔法编程</em>，因此在后来的标准不断的修订 Mixin 模式被直接使用的情况大大减少，而我们要掌握的就是除了 Mixin 这种不优雅的拓展方式，我们是否还有更符合函数式编程思想的方式来拓展所谓的”类”呢？<br>Mixin 实际上就是通过扩展收集功能的一种手段，而在 JavaScript 中的实现方式就是扩展现有构造器函数的原型，也就是利用 JavaScript 的原型链来扩展与该原型派生的所有实例，提高代码的复用性。但是这样做的弊端显而易见，大多数的程序员是不会允许污染原型的操作出现的，因为对于原型的修改是牵一发而动全身，而且这种情况下的故障追踪和定位将极其困难。</p>\n<h3 id=\"Vue-为什么选择了-Mixin\">Vue 为什么选择了 Mixin<a href=\"post/arc-30#Vue-为什么选择了-Mixin\"></a></h3><p>Vue 中对 Mixin 提供了较为良好的支持，包括方法混入的时候的合并策论，以及组件钩子函数混入时的执行顺序等，而且还可以在全局 Vue 对象中混入属性或方法，这也是一种实现全局变量的手段，因为全局混入的属性在任何一个子页面都是可以访问和操作的，但也同时注意任何对全局混入的操作都会影响到所有子组件，这可能是会引起大量的连锁反应。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/08/04/AbdW7nSewuGrygk.png\" alt=\"AbdW7nSewuGrygk.png\" data-zoomable></p></div>\n<p>Vue 选择了 Mixin 与其本身的实现原理也有很大的关系，因为我们要知道 Vue 是一个渐进式的前端框架，可以说所有的模版文件都是基于全局 Vue 对象的，Vue 中大量的操作都涉及到原型链，因此在 Vue 中使用 Mixin 进行重复代码的复用或是与现有的钩子函数进行合并的操作都是很容易的，也是很符合 Vue 的代码风格的，但 Mixin 的弊端依然是存在的，需要开发团队在使用的时候保证文档的健全和风格的统一。</p>\n<h3 id=\"React-为什么抛弃了-Mixin\">React 为什么抛弃了 Mixin<a href=\"post/arc-30#React-为什么抛弃了-Mixin\"></a></h3><ul>\n<li>Mixin可能会相互依赖，相互耦合，不利于代码维护</li>\n<li>不同的Mixin中的方法可能会相互冲突</li>\n<li>Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</li>\n</ul>\n<p>而在另一个更被大型团队偏爱的前端框架 React 中，Mixin 却是早早被官方拉入了黑名单，API 甚至都被删除，曾经的 Mixin 只在 <code>createClass</code> 这样常见的组件中可以使用，在 React 全面拥抱 ES6 之后就更是无人问津了。从目前 React 生态的发展来看，编程模式在从 Mixin 到 HOC 到新出的 hooks 方向发展。<br>为什么 React 对 Mixin 如此避讳呢，这与 React 最初也是最核心的思想有关，不同于 Vue 的渐进式引入，React 从一开始设计的时候就被给予了能够有管理整个大型复杂的前端架构的能力，从它的单向数据流就可见一斑，在大型的项目中最重要的莫过于代码的清晰度和易读性，也就是说比起 Mixin 可以带来的复用性，避免出现原型污染，避免代码中的隐患更为重要。因此 React 推崇的是使用高阶组件 (HOC) 来代替 Mixin 来实现组件间的组合和功能的复用，以及必要的生命周期和渲染的控制。（关于 HOC 更为详细的文章以后也会有产出）</p>\n<h2 id=\"Reference\">Reference<a href=\"post/arc-30#Reference\"></a></h2><p><a href=\"https://juejin.im/post/5cad39b3f265da03502b1c0a\" target=\"_blank\" rel=\"noopener\">【React深入】从Mixin到HOC再到Hook - 掘金</a><br><a href=\"https://react.docschina.org/blog/2016/07/13/mixins-considered-harmful.html\" target=\"_blank\" rel=\"noopener\">Mixins Considered Harmful - React Blog</a><br><a href=\"https://cn.vuejs.org/v2/guide/mixins.html\" target=\"_blank\" rel=\"noopener\">混入 — Vue.js</a><br><a href=\"https://juejin.im/post/5b7bb9b56fb9a019f671266a\" target=\"_blank\" rel=\"noopener\">为什么Vue.mixin中的定义的data全局可用 - 掘金</a></p>\n","prev":{"title":"如何优雅的在 Material UI 中使用 form","link":"post/arc-31"},"next":{"title":"看破 React-Router v4","link":"post/arc-29"},"plink":"https://xkeith.space/post/arc-30/","toc":[{"title":"Mixin","id":"Mixin","index":"1","children":[{"title":"Vue 为什么选择了 Mixin","id":"Vue-为什么选择了-Mixin","index":"1.1"},{"title":"React 为什么抛弃了 Mixin","id":"React-为什么抛弃了-Mixin","index":"1.2"}]},{"title":"Reference","id":"Reference","index":"2"}]}