{"title":"HTTP 1.1 & HTTP 2.0 & SPDY & QUIC","date":"2019-09-15T04:50:10.000Z","thumbnail":"https://i.loli.net/2019/09/15/H6dg32y9GnXcWm8.png","color":"#111","link":"post/newHttp","tags":["http"],"categories":["计算机网络"],"updated":"2019-09-15T04:52:55.589Z","content":"<h2 id=\"HTTP-1-1\">HTTP 1.1<a href=\"post/newHttp#HTTP-1-1\"></a></h2><ul>\n<li>引入更多缓存策略</li>\n<li>断点续传，range 头</li>\n<li>Host 头域来解决一个 IP 下多个虚拟主机的情况</li>\n<li>长链接<a id=\"more\"></a>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h3></li>\n</ul>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/09/15/1K3QrHmDwyOYGsp.png\" alt=\"1K3QrHmDwyOYGsp.png\" data-zoomable></p></div>\n<p>在HTTP 1.1版本后，默认都开启Keep-Alive模式，只有加入加入Connection: close才关闭连接，当然也可以设置Keep-Alive模式的属性，例如Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。</p>\n<p>Httpd守护进程，一般都提供了keep-alive timeout时间设置参数。比如nginx的keepalive_timeout，和Apache的KeepAliveTimeout。这个keepalive_timout时间值意味着：一个http产生的tcp连接在传送完最后一个响应后，还需要hold住keepalive_timeout秒后，才开始关闭这个连接。<br>当httpd守护进程发送完一个响应后，理应马上主动关闭相应的tcp连接，设置 keepalive_timeout后，httpd守护进程会想说：”再等等吧，看看浏览器还有没有请求过来”，这一等，便是keepalive_timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览器发过来http请求，则关闭这个http连接。</p>\n<p>如何判断数据请求结束？</p>\n<p><em>Content-Length</em><br>Content-Length表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。<br>所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置Content-Length来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，Content-Length就无法解决上面的问题，这个时候就需要用到Transfer-Encoding字段。</p>\n<p><em>Transfer-Encoding</em><br>Transfer-Encoding<br>Transfer-Encoding是指传输编码，在上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定Transfer-Encoding: chunked来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定Transfer-Encoding: gzip, chunked表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。</p>\n<h3 id=\"TCP-的-keep-alive\">TCP 的 keep alive<a href=\"post/newHttp#TCP-的-keep-alive\"></a></h3><p>通过保活计时器不断向客户端发送探测包，如果两小时都没收到，那就断开连接。<br>如果发生粘包，处理方式同上，你就带上点信息，让他能把包给拆开就行了。</p>\n<h2 id=\"SPDY\">SPDY<a href=\"post/newHttp#SPDY\"></a></h2><ul>\n<li>多路复用</li>\n<li>请求优先级设置</li>\n<li>header 压缩</li>\n<li>强制使用 HTTPS</li>\n<li>server push 服务端自动推送多个文件</li>\n</ul>\n<h2 id=\"HTTP-2-0\">HTTP 2.0<a href=\"post/newHttp#HTTP-2-0\"></a></h2><ul>\n<li>支持使用 HTTP 并不用强制使用 HTTPS</li>\n<li>HTTP2.0 消息头的压缩算法采用<a href=\"http://http2.github.io/http2-spec/compression.html\" target=\"_blank\" rel=\"noopener\">HPACK</a>，而非 SPDY 采用的<a href=\"http://zh.wikipedia.org/wiki/DEFLATE\" target=\"_blank\" rel=\"noopener\">DEFLATE</a></li>\n<li>新的二进制格式</li>\n<li>多路复用</li>\n<li>header 压缩</li>\n<li>server push</li>\n</ul>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/09/15/CJcSpMmDAePGVL2.jpg\" alt=\"CJcSpMmDAePGVL2.jpg\" data-zoomable></p></div>\n<p>自动将依赖的资源一起发送到客户端，省去了客户端再去发起请求的步骤。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/09/15/GjEtgRNZB8vFhIS.png\" alt=\"GjEtgRNZB8vFhIS.png\" data-zoomable></p></div>\n<h3 id=\"实现基础\">实现基础<a href=\"post/newHttp#实现基础\"></a></h3><h4 id=\"新的数据报格式-Frame\">新的数据报格式 Frame<a href=\"post/newHttp#新的数据报格式-Frame\"></a></h4><figure class=\"highlight plain\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-----------------------------------------------+</span><br><span class=\"line\">|                 Length (24)                   |</span><br><span class=\"line\">+---------------+---------------+---------------+</span><br><span class=\"line\">|   Type (8)    |   Flags (8)   |</span><br><span class=\"line\">+-+-------------+---------------+-------------------+</span><br><span class=\"line\">|R|                 Stream Identifier (31)          |</span><br><span class=\"line\">+=+=================================================+</span><br><span class=\"line\">|                   Frame Payload (0...)        ...</span><br><span class=\"line\">+---------------------------------------------------+</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li><p><strong>Length</strong>: 表示 Frame Payload 部分的长度，另外 Frame Header 的长度是固定的 9 字节（Length + Type + Flags + R + Stream Identifier = 72 bit）。</p>\n</li>\n<li><p><strong>Type</strong>: 区分这个 Frame Payload 存储的数据是属于 HTTP Header 还是 HTTP Body；另外 HTTP/2 新定义了一些其他的 Frame Type，例如，这个字段为 0 时，表示 DATA 类型（即 HTTP/1.x 里的 Body 部分数据）</p>\n</li>\n<li><p><strong>Flags</strong>: 共 8 位， 每位都起标记作用。每种不同的 Frame Type 都有不同的 Frame Flags。例如发送最后一个 DATA 类型的 Frame 时，就会将 Flags 最后一位设置 1（flags &amp;= 0x01），表示 END_STREAM，说明这个 Frame 是流的最后一个数据包。</p>\n</li>\n<li><p><strong>R</strong>: 保留位。</p>\n</li>\n<li><p><strong>Stream Identifier</strong>: 流 ID，当客户端和服务端建立 TCP 链接时，就会先发送一个 Stream ID = 0 的流，用来做些初始化工作。之后客户端和服务端从 1 开始发送请求/响应。</p>\n</li>\n</ul>\n<h4 id=\"头压缩算法-HPACK\">头压缩算法 HPACK<a href=\"post/newHttp#头压缩算法-HPACK\"></a></h4><p>基本的实现思路是将请求头维护成一张字典表，使得每次请求头的大小得到压缩。通过索引的键值对来降低数据量，同时还会将字符串进行霍夫曼压缩。</p>\n<h4 id=\"多路复用实现\">多路复用实现<a href=\"post/newHttp#多路复用实现\"></a></h4><p>基于 Frame Header 上的 Stream ID 来实现此特性。每个请求使用不同的 Stream ID 来实现让所有的请求都并发的跑在同一条连接上。<br>当流并发时，就会涉及到流的优先级和依赖。优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 SCRIPT，这个设计可以确保重要的东西可以被优先加载完。</p>\n<h4 id=\"Server-Push-实现\">Server Push 实现<a href=\"post/newHttp#Server-Push-实现\"></a></h4><p>当服务端需要主动推送某个资源时，便会发送一个 Frame Type 为 PUSH_PROMISE 的 Frame，里面带了 PUSH 需要新建的 Stream ID。意思是告诉客户端：接下来我要用这个 ID 向你发送东西，客户端准备好接着。客户端解析 Frame 时，发现它是一个 PUSH_PROMISE 类型，便会准备接收服务端要推送的流。</p>\n<h2 id=\"QUIC\">QUIC<a href=\"post/newHttp#QUIC\"></a></h2><p>基于 UDP 实现的快速安全传输协议。得益于 UDP 的非连接机制，能够大大缩减握手消耗的 RTT。其安全传输也并非像 TCP 那样使用 TLS 缝缝补补实现的，而是直接从协议底层拓展实现的。<br>同时基于 UDP 传输 ，不会出现 TCP 那种一个包需要重传从而阻塞后续数据传输的情况。<br>基于 UUID 实现的连接标记，在同一设备网络环境发生变化的时候不需要重新建立连接。<br>基于 FEC 前向纠错，使用冗余包的方式来解决数据包丢失的问题。</p>\n<h3 id=\"提速之握手机制\">提速之握手机制<a href=\"post/newHttp#提速之握手机制\"></a></h3><p>传统的 TCP + TLS 1.3 的握手机制一般需要 2RTT，也就是两次消息往返。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/09/15/avueEG36xfcYPSV.png\" alt=\"avueEG36xfcYPSV.png\" data-zoomable></p></div>\n<p>而 QUIC 在客户端保存完成服务端配置的情况下握手只消耗 0RTT ，得益于 UDP 传输的非连接机制。而在初始链接或者是配置缺失的情况下，QUIC 能达到最小只消耗一个 RTT。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/09/15/H6dg32y9GnXcWm8.png\" alt=\"H6dg32y9GnXcWm8.png\" data-zoomable></p></div>\n<p>详细握手和加密通信过程</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/09/15/VJUnlHFE7purkRI.jpg\" alt=\"VJUnlHFE7purkRI.jpg\" data-zoomable></p></div>\n<h3 id=\"如何实现可靠传输\">如何实现可靠传输<a href=\"post/newHttp#如何实现可靠传输\"></a></h3><p>QUIC协议的每个数据包除了本身的数据以外，会带有其他数据包的部分数据，在少量丢包的情况下，可以使用其他数据包的冗余数据完成数据组装而无需重传，从而提高数据的传输速度。具体实现类似于RAID5，将N个包的校验和（异或）建立一个单独的数据包发送，这样如果在这N个包中丢了一个包可以直接恢复出来。除此之外还可以用来校验包的正确性。</p>\n<div class=\"article-img\"><p><img src=\"https://i.loli.net/2019/09/15/ZEUyQ6oKPWBxiXe.png\" alt=\"ZEUyQ6oKPWBxiXe.png\" data-zoomable></p></div>\n<h2 id=\"Reference\">Reference<a href=\"post/newHttp#Reference\"></a></h2><p><a href=\"http://http2.github.io/http2-spec/compression.html\" target=\"_blank\" rel=\"noopener\">HPACK: Header Compression for HTTP/2</a><br><a href=\"https://www.cnblogs.com/bluestorm/p/7382091.html\" target=\"_blank\" rel=\"noopener\">HTTPS、SPDY和HTTP/2的性能比较 - petercao - 博客园</a><br><a href=\"https://blog.csdn.net/weixin_37672169/article/details/80283935\" target=\"_blank\" rel=\"noopener\">浅谈Http长连接和Keep-Alive以及Tcp的Keepalive - 许文杰的博客 - CSDN博客</a><br><a href=\"https://cloud.tencent.com/developer/news/385657\" target=\"_blank\" rel=\"noopener\">QUIC为什么那么快 - 云+社区 - 腾讯云</a><br><a href=\"https://blog.csdn.net/b2222505/article/details/79391430\" target=\"_blank\" rel=\"noopener\">Quic浅析 - 啊浪的博客 - CSDN博客</a><br><a href=\"https://www.jianshu.com/p/2fbc26eb348a\" target=\"_blank\" rel=\"noopener\">通往QUIC之路 - 简书</a></p>\n","next":{"title":"浅谈 React Fiber 架构","link":"post/fiber"},"plink":"https://xkeith.space/post/newHttp/","toc":[{"title":"HTTP 1.1","id":"HTTP-1-1","index":"1","children":[{"title":"","id":"keep-alive","index":"1.1"},{"title":"TCP 的 keep alive","id":"TCP-的-keep-alive","index":"1.2"}]},{"title":"SPDY","id":"SPDY","index":"2"},{"title":"HTTP 2.0","id":"HTTP-2-0","index":"3","children":[{"title":"实现基础","id":"实现基础","index":"3.1","children":[{"title":"新的数据报格式 Frame","id":"新的数据报格式-Frame","index":"3.1.1"},{"title":"头压缩算法 HPACK","id":"头压缩算法-HPACK","index":"3.1.2"},{"title":"多路复用实现","id":"多路复用实现","index":"3.1.3"},{"title":"Server Push 实现","id":"Server-Push-实现","index":"3.1.4"}]}]},{"title":"QUIC","id":"QUIC","index":"4","children":[{"title":"提速之握手机制","id":"提速之握手机制","index":"4.1"},{"title":"如何实现可靠传输","id":"如何实现可靠传输","index":"4.2"}]},{"title":"Reference","id":"Reference","index":"5"}]}