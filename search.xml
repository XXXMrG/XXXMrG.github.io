<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue 高级（Vue Router 基础）]]></title>
    <url>%2F2019%2F03%2F21%2Farc-05%2F</url>
    <content type="text"><![CDATA[动态路由匹配我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个User组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。 响应路由参数的变化 这就是为什么 PixelStack 不会刷新，早看了这个早就刷新了。😂 提醒一下，当使用路由参数时，例如从/user/foo导航到/user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化)$route对象： 12345678const User = &#123; template: '...', watch: &#123; '$route' (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125; 或者使用 2.2 版本中引入的导航守卫 1234567const User = &#123; template: '...', beforeRouteUpdate (to, from, next) &#123; // react to route changes... // don't forget to call next() &#125;&#125; 捕获所有路由或 404 Not found 路由常规参数只会匹配被/分隔的 URL 片段中的字符。如果想匹配任意路径，我们可以使用通配符 (*)： 当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由{ path: ‘’ }通常用于客户端 404 错误。如果你使用了History 模式，请确保 正确配置你的服务器 。当使用一个通配符时，$route.params内会自动添加一个名为pathMatch参数。它包含了 URL 通过通配符*被匹配的部分： 123456// 给出一个路由 &#123; path: '/user-*' &#125;this.$router.push('/user-admin')this.$route.params.pathMatch // 'admin'// 给出一个路由 &#123; path: '*' &#125;this.$router.push('/non-existing')this.$route.params.pathMatch // '/non-existing' 高级匹配模式vue-router使用 path-to-regexp 作为路径匹配引擎，所以支持很多高级的匹配模式，例如：可选的动态路径参数、匹配零个或多个、一个或多个，甚至是自定义正则匹配。查看它的 文档 学习高阶的路径匹配，还有 这个例子 展示vue-router怎么使用这类匹配。 匹配优先级有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。 嵌套路由要在嵌套的出口中渲染组件，需要在VueRouter的参数中使用children配置： 1234567891011121314151617181920const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'profile', component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'posts', component: UserPosts &#125; ] &#125; ]&#125;) 要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。你会发现，children配置就是像routes配置一样的路由配置数组，所以呢，你可以嵌套多层路由。此时，基于上面的配置，当你访问/user/foo时，User的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由： 1234567891011121314const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中 &#123; path: '', component: UserHome &#125;, // ...其他子路由 ] &#125; ]&#125;) 编程式的导航除了使用 标签来定义导航连接，我们还可以借助 router 的实例方法，通过编写代码来实现。常用的方法有三个 router.push(location, onComplete?, onAbort?) 想要导航到不同的 URL，则使用router.push方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。当你点击时，这个方法会在内部调用，所以说，点击等同于调用router.push(…)。该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如： 1234567891011// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: '123' &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) 注意：如果提供了path，params会被忽略，上述例子中的query并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的name或手写完整的带有参数的path： 12345const userId = '123'router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user 同样的规则也适用于router-link组件的to属性。在 2.2.0+，可选的在router.push或router.replace中提供onComplete和onAbort回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。注意： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个/users/1-&gt;/users/2)，你需要使用 beforeRouteUpdate 来响应这个变化 (比如抓取用户信息)。 router.replace(location, onComplete?, onAbort?) 跟router.push很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。 router.go(n) 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似window.history.go(n)。 123456789101112// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100) 你也许注意到router.push 、router.replace 和router.go跟 window.history.pushState、window.history.replaceState和window.history.go 好像， 实际上它们确实是效仿window.historyAPI 的。因此，如果你已经熟悉Browser History APIs Browser History APIs，那么在 Vue Router 中操作 history 就是超级简单的。还有值得提及的，Vue Router 的导航方法 (push、replace 、go ) 在各类路由模式 (history 、hash和abstract ) 下表现一致。 重定向和别名重定向也是通过routes配置来完成，下面例子是从/a重定向到/b： 12345678910const router = new VueRouter(&#123; routes: [ &#123; path: '/a', redirect: '/b' &#125;, &#123; path: '/a', redirect: &#123; name: 'foo' &#125;&#125;, &#123; path: '/a', redirect: to =&gt; &#123; // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 &#125;&#125; ]&#125;) 注意，导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上，在这个例子中，为 /a 路由添加beforeEach 或 beforeLeave 守卫并不会有任何效果。 路由组件传参在组件中使用$route会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。 我们可以使用 props 将其接耦 如果rops被设置为true ，route.params 将会被设置为组件属性。 12345678910111213141516const User = &#123; props: ['id'], template: '&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, props: true &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: '/user/:id', components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) HTML 5 History 模式]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP or UDP ?]]></title>
    <url>%2F2019%2F03%2F20%2Farc-04%2F</url>
    <content type="text"><![CDATA[TCP / IP 网络模型计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。 TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。 TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。 链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。 网络层：负责路由以及把分组报文发送给目标网络或主机。 传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。 应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。 在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。TCP 和 UDP 就是 TCP/IP 中两个具有代表性的传输层协议。 TCPTransmission Control Protocol 当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。 连接过程三次握手🤝 第一次握手：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。 第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为第三次握手为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。 四次挥手🙋‍♂️ TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。 第一次挥手：若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。 第二次挥手：B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。 第三次挥手：B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。 第四次挥手：A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 特点 面向连接：面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 仅支持单播传输：每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。 面向字节流：TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。 可靠传输：对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。 提供拥塞控制：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。 TCP提供全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）。 UDPUser Datagram Protocol用户数据报协议 特点 面向无连接 不需要像 TCP 一样通过三次握手建立连接，想发就发，而且也不对数据报文进行任何处理。 具体来说就是： 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了； 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。 有单播，多播，广播的功能 UDP 不止支持一对一的传输，同样支持一对多，多对多，多对一，也就是单播，广播，多播。 UDP 是面向报文的 UDP 仅对报文添加首部后就向下交付给 IP 层，UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，因此，应用程序必须选择合适大小的报文。 不可靠性 首先不可靠性就体现在无连接上，想发就发，收到什么就传递什么，不对数据进行备份，而且也不在乎对方是否正确的收到了数据。其次，网络环境时好时坏，因为UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络环境不好，也不会对发送速率进行调整。这样实现的弊端就是在网络环境不好的情况下会导致丢包，但是优点也很明显，在某些实时性要求较高的场景（电话会议，视频直播）我们就需要使用 UDP 而不是 TCP。 头部开销小，传输数据报文时很高效 UDP 头部包含了以下几个数据： 两个十六位的端口号，分别为源端口（可选字段）和目标端口； 整个数据报文的长度； 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误。因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。 对比 TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为。 对数据准确性要求高，速度可以相对较慢的，可以选用TCP。 ReferenceTCP和UDP比较 - 浪里行舟的博客 - CSDN博客]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何速成前端三件套 （CSS）]]></title>
    <url>%2F2019%2F03%2F19%2Farc-03%2F</url>
    <content type="text"><![CDATA[CSS常用属性 层叠次序一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 4 拥有最高的优先权。 浏览器缺省设置 外部样式表 内部样式表（位于 标签内部） 内联样式（在 HTML 元素内部） 因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。 盒模型every element in web design is a rectangular box 盒模型(box model)是CSS中的一个重要概念，它是元素大小的呈现方式。 CSS3中新增了一种盒模型计算方式：box-sizing熟悉。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下： content-box（默认） 布局所占宽度Width：Width = width + padding-left + padding-right + border-left + border-right布局所占高度Height:Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box 布局所占宽度Width：Width = width(包含padding-left + padding-right) + border-top + border-bottom布局所占高度Height:Height = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box 布局所占宽度Width：Width = width(包含padding-left + padding-right + border-left + border-right)布局所占高度Height:Height = height(包含padding-top + padding-bottom + border-top + border-bottom) margin叠加 外边距叠加是一个相当简单的概念。 但是，在实践中对网页进行布局时， 它会造成许多混淆。 简单的说， 当两个或更多个垂直边距相遇时， 它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。但是注意只有普通文档流中块框的垂直外边距才会发生外边距叠加。 行内框、 浮动框或绝对定位框之间的外边距不会叠加。一般来说， 垂直外边距叠加有三种情况： 元素自身叠加 当元素没有内容（即空元素）、内边距、边框时， 它的上下边距就相遇了， 即会产生叠加（垂直方向）。 当为元素添加内容、 内边距、 边框任何一项， 就会取消叠加。 相邻元素叠加 相邻的两个元素， 如果它们的上下边距相遇，即会产生叠加。 包含（父子）元素叠加 包含元素的外边距隔着 父元素的内边距和边框， 当这两项都不存在的时候， 父子元素垂直外边距相邻， 产生叠加。 添加任何一项即会取消叠加。 CSS 普通流（文档流）什么是普通流？简单说就是元素按照其在 HTML 中的位置顺序决定排布的过程。并且这种过程遵循标准的描述。 一般使用margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“距离”。只要不是float和绝对定位方式布局的，都在普通流里面。 CSS 定位方式display 属性每一个元素都有默认的display属性，使用最多的是 block,inline 和 inline-block，不常用的是 table-cell。根据 display 属性，我们可以将元素分为块级元素(block)和内联级元素(inline)。它们最大区别是:block元素可以设置宽度，独占一行。inline元素宽度由内容决定，与其他元素并列在一行。常见的block属性元素有：div, h1-h6, ul, li, ol, dl, dd, dt。常见的inline属性元素有:span, a, em。 block 宽高可以自行设置，默认宽度由父容器决定，默认高度由内容决定，自己独占一行。 inline 宽度和高度都由内容决定，与其他元素共占一行 inline-block 宽度可以自行设置，类似block，但是与其他元素共占一行，类似inline。长用于设置垂直居中。 table-cell 此属性指让标签元素以表格单元格的形式呈现，单元格有一些比较特殊的属性，可以设置元素的垂直居中等。 position 属性元素在页面中的布局遵守一套文档流的方式，默认的定位属性值为static。它其实是未被设置定位的。元素如果被定位了，那么它的top,left,bottom,right值就会生效，能设置定位的属性是relative,absolute和fixed。需要注意的另一点是被定位的元素层次(z-index)会得到提高。 relative（相对定位） 设置了相对定位之后，通过修改top,left,bottom,right值，元素会在自身文档流所在位置上被移动，其他的元素则不会调整位置来弥补它偏离后剩下的空隙。 absolute（绝对定位） 设置了绝对定位之后，元素脱离文档流，其他的元素会调整位置来弥补它偏离后剩下的空隙。元素偏移是相对于离它最近的设置了定位属性（position值不为static）的元素。且如果元素为块级元素（display属性值为block)，那么它的宽度也会由内容撑开。因为：默认文档流中块级元素如果没有设置宽度属性，会自动填满整行。 fixed(固定定位) 设置了固定定位之后，元素相对的偏移的参考是可视窗口，即使页面滚动，元素仍然会在固定位置。 CSS 相对|绝对(relative/absolute)定位系列 CSS 浮动相关这也是CSS定位机制的一种。首先了解两个概念： 文档流：文档流是文档中可显示对象在排列时所占用的位置。 浮动的定义：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。浮动的实际用途，可设置文字环绕或使元素宽度由内容填充（类似Inline-block)。使用浮动需要注意的是如果浮动的元素高度比父级容器还高，那么需要设置父级容器的overflow属性为auto,使其自动撑满。 CSS 浮动 CSS 选择器选择器是匹配元素的一种模式，不只是在CSS中，JavaScript对CSS的选择器也是支持的，比如document.document.querySelectorAll。 CSS 解析器HTML 经过解析生成 DOM Tree（这个我们比较熟悉）；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。 解析顺序CSS匹配不是从左到右进行查找，而是从右到左进行查找。如果从左到右的顺序，那么每条选择器都需要遍历整个DOM树，性能很受影响。所谓高效的CSS就是让浏览器在查找style匹配的元素的时候尽量进行少的查找, 所以选择器最好写的简洁一点。 选择器权重权重，也就是选择器的优先级，每条选择器的规则都有其权重，权重大的会覆盖掉权重小的，很多CSS出现问题的场景，都是某处定义了一个更高权重的规则，导致此处规则不生效。根据样式所在位置，对元素的影响也有关系：内联样式（标签内style形式） &gt; style标签 &gt; link标签。另外一点需要注意的是!improtant,凡是属性值后加上了!important，那么它的值不会被其他值替换。 权重的计算 主要的规则就是:id选择器 &gt; 类，属性选择器和伪类选择器 &gt; 元素和伪元素 基本选择器 通配符选择器（＊） id选择器（#ID） 类选择器（.className） 元素选择器(E) 后代选择器（Ｅ Ｆ） 子元素选择器(E&gt;F) 相邻兄弟元素选择器(E + F) 群组选择器（selector1,selector2,…,selectorN） 属性选择器使用CSS3属性选择器，你可以只指定元素的某个属性，或者你还可以同时指定元素的某个属性和其对应的属性值。 E[attr]：只使用属性名，但没有确定任何属性值 E[attr=“value”]：指定属性名，并指定了该属性的属性值 E[attr~=“value”]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写 E[attr^=“value”]：指定了属性名，并且有属性值，属性值是以value开头的； E[attr$=“value”]：指定了属性名，并且有属性值，而且属性值是以value结束的； E[attr*=“value”]：指定了属性名，并且有属性值，而且属值中包含了value； E[attr|=“value”]：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn）; 伪类选择器伪类选择器的形式就是:xxx， 比如:hover, :link, :nth。 动态伪类这些伪类并不存在于HTML中,而只有当用户和网站交互的时候才能体现出来，动态伪类包含两种，第一种是我们在链接中常看到的锚点伪类，如”:link”,”:visited”;另外一种被称作用户行为伪类，如“:hover”,”:active”和”:focus”。先来看最常见的锚点伪类。 hover: 用于当用户把鼠标移动到元素上面时的效果 active: 用于用户点击元素那一下的效果（正发生在点的那一下，松开鼠标左键此动作也就完成了） focus: 用于元素成为焦点，这个经常用在表单元素上 UI元素状态伪类 主要是针对于HTML中的Form元素操作，IE8 不支持 :checked, :enabled, :disabed 这三种选择器。 CSS3的:nth选择器主要注意的是CSS3添加的nth选择器在IE8下不支持。 fist-child: 选择某个元素的第一个子元素； last-child: 选择某个元素的最后一个子元素； nth-child(): 选择某个元素的一个或多个特定的子元素； 其他： 常用的就是上面三种了，其他自行了解。 CSS 布局 固定尺寸布局可以从固定尺寸先了解，先构思好页面的主要结构，做动画的元素一般需要绝对定位，方便操作移动。 自适应布局响应式的布局的结构其实就是多个固定尺寸的组合，元素的宽度，字体的大小一般会以半分比的形式设置。通过媒体查询进行不同分辨率下的布局。 如何只用CSS做到完全居中 - 文章 - 伯乐在线 Metameta 标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键字），或其他 web 服务。 BEMBEM (Block, Element, Modifier) 是一种基于组件的对 CSS 类名进行约定的 Web 开发方法。他通过定义命名空间来解决权重问题，从而使 CSS 更易于维护。BEM 使用 Block、Element、Modifier 来解释其结构。Block 是一个可跨项目重用的独立组件，且是子组件（Element）的“命名空间”。Modifier 可标示 Block 或 Element 处于某种状态、结构或特定的样式。 -中划线 ：仅作为连字符使用，表示多个单词之间的连接记号 __双下划线：用来连接 Block 和 Element —双中划线：描述 Block 或 Element 的一种状态、结构或样式 1234567891011121314/* block component */.block-name &#123;&#125;/* element */.block-name__element-name &#123;&#125;/* modifier */.block-name__element-name--modifier-name &#123;&#125; &lt;nav class="navbar"&gt; &lt;a href="/" class="navbar__link navbar__link--active"&gt;&lt;/a&gt; &lt;a href="/" class="navbar__link"&gt;&lt;/a&gt;&lt;/nav&gt; 在示例中，navbar 为 Block，navbar__link 是一个不能独立与navbar 存在的 Element，navbar__link--active是标明navbar__link 不同状态的 Modifier。 BEM 实践中也有使用_替代—的情况 类命名需要尽可能的简明清晰、没有二意性，例如error就比red-text更加有语义。 建议 Block 只能有一层 Element 嵌套，且 Element 不能独立 Block 存在。如： 123456789&lt;form class="search-form"&gt; &lt;div class="search-form__content"&gt; &lt;input class="search-form__input"&gt; &lt;!-- 错误：建议使用 `search-form__button` 或 `search-form__content-button` --&gt; &lt;button class="search-form__content__button"&gt;Search&lt;/button&gt; &lt;/div&gt;&lt;/form&gt;&lt;!-- 错误：该 Element 应放在 `search-form` Block 中 --&gt;&lt;i class="search-form__icon"&gt;&lt;/i&gt; 建议同一个 Block 或 Element 上不能使用两个以上的 Modifier 去进行修饰，且 Modifier 需配合 Block 或 Element 使用，不能独立存在。如： 123456&lt;!-- 错误：缺少 `search-form` Block --&gt;&lt;form class="search-form_theme_islands"&gt;&lt;/form&gt;&lt;!-- 错误：使用多个 Modifier --&gt;&lt;form class="search-form search-form_theme_islands search-form_theme_lite"&gt;&lt;/form&gt; 那些你不知道的属性margin padding border 这些如果同时设置四个方向上的值的话，顺序应当是顺时针的。 TBD… Reference前端工程师手册 · GitBook (Legacy)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络体系结构]]></title>
    <url>%2F2019%2F03%2F18%2Farc-02%2F</url>
    <content type="text"><![CDATA[计算机网络体系结构1.1 简介 定义 计算机网络的各层 + 协议的集合 作用 定义该计算机网络的所能完成的所有功能 1.2 结构介绍一般分为三种： OSI 体系结构：概念清楚，理念完整，但是复杂，不实用。 TCP / IP 体系结构：包含一系列构成互联网基础的网络协议，是 Internet 的核心协议，被广泛应用于局域网和广域网。 五层体系结构：融合了 OSI 与 TCP/ IP 的体系结构，目的是学习和讲解计算机原理。 ::低三层为通信子网，负责数据传输。::::高三层为资源子网，相当于计算机系统，完成数据处理。::::传输层承上启下:: TCP / IP 的体系结构详细介绍 OSI 的体系结构详细介绍 TCP 协议Transmission Control Protocol 即传输控制协议。 属于传输层通信协议基于 TCP 的应用层协议有 HTTP, SMTP, FTP, Telenet, POP3 UDP 协议3.1 定义User Datagram Protocol 即用户数据报协议 属于传输层通信协议基于 UDP 的应用层协议有 TFTp, SNMP 与 DNS 3.2 特点无连接的，不可靠的，面向报文，无拥塞控制，具体介绍如下： 3.3 优缺点 优点：速度快 缺点：消息易丢失（特别是网络较差的时候） 3.4 应用场景（对应应用层协议）要求通信速度高 如：域名转换：DNS 协议文件传输：FTP 协议网络管理：SNMP 协议远程文件服务器：NFS 协议 3.5 报文段格式 UDP 报文段共有两个字段：数据字段和首部字段 主要介绍首部（8字节，4个字段） 3.6 TCP 和 UDP 的区别 4. HTTP 协议4.1 简介 5. Socket5.1 简介即套接字，是应用层与 TCP / IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP 协议族的编程接口 API Socket 不是一种协议，而是一个编程调用接口（API)，属于传输层（主要解决数据如何在网络中传输） 在 Android 平台，我们只能通过 Socket 才能使用 TCP / IP 协议进行开发 对用户来说，只需要调用 Socket 去组织数据，以符合制定的协议，即可通信。 成对出现，一对套接字： 1Socket = &#123;(IP 地址1: PORT 端口号), （IP 地址 2: PORT 端口号）&#125; 一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路。 5.2 其他知识关于 Socket 的原理、机制过程和使用方式：Android：这是一份很详细的Socket使用攻略 - 简书 6. 其他知识6.1 在浏览器中输入 url 地址 -&gt; 显示主页的过程 打开一个网页整个过程中会使用哪些协议 6.2 IP 地址定义链接在 Internet 中的每一台主机（路由器）的全球唯一的标识符 组成IP 地址 = 32 位 = 网络号 + 主机号；即 IP 地址 = {&lt;网络号&gt;, &lt;主机号&gt;} 其中： 网络号：标志主机（路由器）所链接到的网络，一个网络号在整个因特网范围内必须是唯一的。 主机号：标志该主机（路由器）。一个主机号在它面前的网络号所指明的网络范围内必须是唯一的。 不同类型的 IP 地址，其主机号 &amp; 网络号所占字节数不同；故：一个 IP 地址在整个网络范围内是唯一的。 分类传统的 IP 地址是分类的地址，分为 A, B, C, D, E 五类区别在于网络号 &amp; 主机号所占的字节数不同。 ::在各类 IP 地址中，有一些 IP 地址用于特殊用途，不能用做主机 IP 地址:: 6.3 ICMP 协议定义Internet Control Message Protocol 国际控制报文协议 属于 IP 层协议 ICMP 报文不是高层协议，而是作为 IP 层数据报的数据，加上数据报首部，组成 IP 数据报发出去。 作用更有效的转发 IP 数据包 &amp; 提高交付成功的机会同时允许主机 / 路由器报告差错 &amp; 异常情况 分类ICMP 差错报告报文 &amp; ICMP 询问报文 主要应用PING （分组网间探测）、Traceroute （跟踪一个分组从源点到终点的路径，原理 = 从源主机向目的主机发送一连串的 IP 数据报）主要介绍 Ping 的过程 6.4 Ping 的过程定义Packet InterNet Groper 分组网间探测 是 ICMP 报文的一个重要应用：使用了 ICMP 回送请求 &amp; 回送回答报文 是应用层直接使用网络层 ICMP 的一个例子，无需经过传输层的 TCP, UDP 作用测试两个主机的联通性 原理 向目的主机发送多个 ICMP 回送请求报文 根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间 最终的显示结果：发送到目的主机的 IP 地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小 &amp; 最大 &amp; 平均值 过程假设有两台主机：（目的主机） PC1：IP = 192.168.1.1（源主机） PC2：IP = 192.168.1.2 6.5 路由器与交换机的区别 6.6 Cookie 与 Session 6.7 Cookie 与 Token 基于 Cookie 的身份验证 &amp; 验证流程 基于 Token 的身份验证 &amp; 验证流程 Reference这是一份详细 &amp; 清晰的计算机网络基础 学习指南 - 简书]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于算法的 Swift 学习之路（排序）]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%9F%BA%E4%BA%8E%E7%AE%97%E6%B3%95%E7%9A%84%20Swift%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[排序这里给出了六大排序的 Swift 语言实现，大部分代码是基于算法4th 的 JAVA 实现直接实现的，也有充分利用 Swift 语言特性的更为简洁的实现。代码中涉及到的 Swift 特性，我选择用算法这样一种实际应用情况来为大家阐述，更为易懂和实用。 选择排序123456789101112131415161718func selectionSort&lt;T: Comparable&gt;(_ array: [T]) -&gt; [T] &#123; var a = array let N = a.count var count = 0 for i in 0..&lt;N &#123; var min = i for j in (i + 1)..&lt;N &#123; if a[j] &lt; a[min] &#123; min = j count += 1 &#125; &#125; // Array 库函数，交换两个元素 a.swapAt(i, min) &#125; print("selectionSort cost \(count)") return a&#125; 最简单的排序方式，不断选择最小的元素移到第一个元素，因此是个稳定的算法，这里我们要强调的有两个，第一个就是我们在下面经常用到的 Array.swapAt(_ : Int, _ : Int) ，Swift 直接为我们封装好了交换数组两个元素的方法，简单而高效。接下来要说的就是 Swift 中的泛型，我们在这里为方法定义了一个泛型 T 并且要求这个泛型要实现 Comparable 协议，这于算四里直接使用 JAVA 中的 Comparable 超类差不多，但是泛型就意味着我们需要在调用这个方法的时候明确指出这个泛型的真正类型，这种问题常常并不会出现在函数泛型的使用中，因为我们既然为函数声明了泛型，就一定会为其传入相应的参数，Swift 会通过参数自动推断出该泛型。但是我们要知道，同样的泛型声明方法也是可以在类身上的，我们在 JAVA 中为一个泛型类声明的时候要明显的给出实际类型，但是在 Swift 中，我们除了这样显示给出泛型外，如果我们的构造方法里传入了该类型的参数，那么我们就无需再重复声明泛型，Swift 会帮我们推断出该泛型，同时对于这个对象本身，该泛型已经确定，不能再更改了，否则会出现一个类中两个泛型的困扰。关于 Comparable 协议，任何遵循了该协议的变量都自动拥有该协议中包含的几个方法 &lt; &gt; &lt;= &gt;= 等，也就跟其字面意思相同，这是一个可以比较的变量。同样的协议还有 Equalable ，其包含的方法是 == != ` 插入排序（冒泡排序）1234567891011121314func insertionSort&lt;T&gt;(_ array: [T], _ isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T] &#123; var a = array var count = 0 for x in 1..&lt;a.count &#123; var y = x while y &gt; 0 &amp;&amp; isOrderedBefore(a[y], a[y - 1]) &#123; a.swapAt(y - 1, y) count += 1 y -= 1 &#125; &#125; print("insert cost \(count)") return a&#125; 插入排序，很多高级排序的基础，也是对于小型数组排序最快的排序方法。对于有序数组也有着很高的排序效率 这里涉及的 Swift 特性在于那个特别长的参数，也就是那个函数参数。我们知道在 Swift 中，函数是一等类型，可以作为返回值和参数直接使用。这一次我们的泛型并没有直接实现 Comparable 协议，而是用了一个函数直接将操作符 &gt; &lt; 直接当作参数传入，因此可以通过参数来控制递增排序和递减排序，关于 Swift 中的操作符，实际上也是一个函数，我们也可以通过重载为其增加更多的方法。 希尔排序12345678910111213141516171819202122232425func shellSort&lt;T&gt; (_ array: [T], _ isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T] &#123; var a = array let N = a.count var h = 1 var count = 0 // 递增序列 while h &lt; N / 3 &#123; h = 3 * h + 1 &#125; while h &gt;= 1 &#123; for i in h..&lt;N &#123; var j = i while j &gt;= h &amp;&amp; isOrderedBefore(a[j], a[j-h]) &#123; a.swapAt(j, j-h) count += 1 //print(a) j -= h &#125; &#125; h = h / 3 &#125; print("shell cost \(count)") return a&#125; 插入排序的优化版，通过递增序列使其性能大大提升。 归并排序这也是个稳定的排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123class Merge&lt;T: Comparable&gt; &#123; var aux = [T]() var data = [T]() init(_ array: [T]) &#123; data = array self.mergeSort(&amp;data, lo: 0, hi: data.count - 1) &#125; // 使用 inout 来操作实际参数 func merge(_ array: inout [T], _ lo: Int, _ mid: Int, _ hi: Int)&#123; var i = lo var j = mid + 1 aux = array for k in lo...hi &#123; if i &gt; mid &#123; array[k] = aux[j] j += 1 &#125; else if j &gt; hi &#123; array[k] = aux[i] i += 1 &#125; else if aux[j] &lt; aux[i] &#123; array[k] = aux[j] j += 1 &#125; else &#123; array[k] = aux[i] i += 1 &#125; &#125; &#125; // merge high to low func mergeSort(_ array: inout [T], lo: Int, hi: Int)&#123; if hi &lt;= lo &#123; return &#125; let mid = lo + (hi - lo) / 2 mergeSort(&amp;array, lo: lo, hi: mid) mergeSort(&amp;array, lo: mid + 1, hi: hi) merge(&amp;array, lo, mid, hi) &#125; // merge low to high func mergeBU(_ array: [T]) -&gt; [T] &#123; var a = array let N = a.count // 归并子数组大小 var sz = 1 while sz &lt; N &#123; var lo = 0 while lo &lt; N - sz &#123; // 用 N - 1 防止数组越界 merge(&amp;a, lo, lo+sz-1, min(lo+sz+sz-1, N-1)) // 参与归并的数组大小是子数组的两倍 lo += sz + sz &#125; sz = sz + sz &#125; return a &#125; // 不操作原数组的方式 func merge(leftPile: [T], rightPile: [T]) -&gt; [T] &#123; // 1 var leftIndex = 0 var rightIndex = 0 // 2 var orderedPile = [T]() // 为数组申请备用容量，减少长度动态变化的开销 orderedPile.reserveCapacity(leftPile.count + rightPile.count) // 3 // 两个归并的数组有一个用完就会停止判断 while leftIndex &lt; leftPile.count &amp;&amp; rightIndex &lt; rightPile.count &#123; if leftPile[leftIndex] &lt; rightPile[rightIndex] &#123; orderedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; else if leftPile[leftIndex] &gt; rightPile[rightIndex] &#123; orderedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; else &#123; // 如果一样大，各放入归并的数组一次 orderedPile.append(leftPile[leftIndex]) leftIndex += 1 orderedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; &#125; // 4 // 右侧数组用完 while leftIndex &lt; leftPile.count &#123; orderedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; // 左侧数组用完 while rightIndex &lt; rightPile.count &#123; orderedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; return orderedPile &#125; func mergeSort(_ array: [T]) -&gt; [T] &#123; // guard 更关注的是 else guard array.count &gt; 1 else &#123; return array &#125; // 1 let middleIndex = array.count / 2 // 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) // 3 let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) // 4 return merge(leftPile: leftArray, rightPile: rightArray) // 5 &#125;&#125; 涉及到的 Swift 特性： Array.reserveCapacity inout 和 &amp; subsequence 在归并排序中，我们在知道需要的额外数组长度的情况下使用了 reserveCapacity 这个方法来为数组增加备用容量，我们都知道 Swift 中的数组跟 js python 相同，都是动态数组，多数情况下我们是不需要关心数组大小的，但是通过这种事前为数组增加容量的方式可以让我们在需要大量 append 操作的时候减少系统消耗。 inout 和 &amp; ，Swift 与 JAVA 不同，对于对象类参数的处理是直接修改其原对象信息。Swift 仍然继承了 C 的基础，对象型参数会复制一份到函数中，同时，这个变量是个 let 型，也就是说我们并不能直接操作这个变量，对这个变量的操作就更不可能影响到函数外。这是 Swift 为了贯彻其安全的理念的措施。那么对于需要直接更改实际变量的操作呢，我们就要用到 inout 和 &amp; 这一对操作符，有一点像 C 中的指针，带有 inout 的参数才能被直接访问和修改。 subsequence ，在最后的方法中我们直接使用区间运算作为数组的下标来访问同一个数组的前后两部分，但是我们要注意的是，这样得到的实际上并非是个数组，而是个遵守了 subsequence 的类型，而数组，他实现的是 sequence 协议，这两个还不太一样，因此我们在传入参数的时候将其进行了类型转换。 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138class Quick&lt;T: Comparable&gt; &#123; var data: [T] init(_ array: [T]) &#123; self.data = array // 打乱一个数组 shuffle, shuffled // https://developer.apple.com/documentation/swift/array/2994757-shuffled data.shuffle() //sort(&amp;data, lo: 0, hi: data.count - 1) //quick3Sort(&amp;data, lo: 0, hi: data.count - 1) data = quicksort(data) &#125; // 最经典的切分方式，取第一个元素作为基准 func sort(_ array: inout [T], lo: Int, hi: Int) &#123; if hi &lt;= lo &#123; return &#125; let j = partition(&amp;array, lo: lo, hi: hi) sort(&amp;array, lo: lo, hi: j - 1) sort(&amp;array, lo: j + 1, hi: hi) &#125; // 手写 partition 实际上可以使用高级操作符 filter 来直接完成切分 func partition(_ array: inout [T], lo: Int, hi: Int) -&gt; Int &#123; var i = lo var j = hi + 1 let v = array[lo] while true &#123; i += 1 while array[i] &gt; v &#123; if i == hi &#123; break &#125; i += 1 &#125; j -= 1 while v &gt; array[j] &#123; if j == lo &#123; break &#125; j -= 1 &#125; if i &gt;= j &#123; break &#125; array.swapAt(i, j) &#125; array.swapAt(lo, j) return j &#125; // 更简洁的写法 func quicksortHoare(_ a: inout [T], low: Int, high: Int) &#123; if low &lt; high &#123; let p = partitionHoare(&amp;a, low: low, high: high) quicksortHoare(&amp;a, low: low, high: p) quicksortHoare(&amp;a, low: p + 1, high: high) &#125; &#125; func partitionHoare(_ a: inout [T], low: Int, high: Int) -&gt; Int &#123; let pivot = a[low] var i = low - 1 var j = high + 1 while true &#123; repeat &#123; j -= 1 &#125; while a[j] &gt; pivot repeat &#123; i += 1 &#125; while a[i] &lt; pivot if i &lt; j &#123; a.swapAt(i, j) &#125; else &#123; return j &#125; &#125; &#125; // 三向切分 func quick3Sort(_ array: inout [T], lo: Int, hi: Int) &#123; if hi &lt;= lo &#123; return &#125; var lt = lo, i = lo + 1, gt = hi let v = array[lo] while i &lt;= gt &#123; if array[i] &lt; v &#123; array.swapAt(lt, i) lt += 1 i += 1 &#125; else if v &lt; array[i] &#123; array.swapAt(i, gt) gt -= 1 &#125; else &#123; i += 1 &#125; &#125; quick3Sort(&amp;array, lo: lo, hi: lt - 1) quick3Sort(&amp;array, lo: gt + 1, hi: hi) &#125; // 三项切分，利用高级函数，效率并不太高 func quicksort&lt;T: Comparable&gt;(_ a: [T]) -&gt; [T] &#123; guard a.count &gt; 1 else &#123; return a &#125; //let pivot = a[a.count/2] let pivot = a[0] let less = a.filter &#123; $0 &lt; pivot &#125; let equal = a.filter &#123; $0 == pivot &#125; let greater = a.filter &#123; $0 &gt; pivot &#125; return quicksort(less) + equal + quicksort(greater) &#125; // 三向切分，取最后一个元素作为基准 func partitionLomuto&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) -&gt; Int &#123; let pivot = a[high] var i = low for j in low..&lt;high &#123; if a[j] &lt;= pivot &#123; (a[i], a[j]) = (a[j], a[i]) i += 1 &#125; &#125; (a[i], a[high]) = (a[high], a[i]) return i &#125; func quicksortLomuto&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) &#123; if low &lt; high &#123; let p = partitionLomuto(&amp;a, low: low, high: high) quicksortLomuto(&amp;a, low: low, high: p - 1) quicksortLomuto(&amp;a, low: p + 1, high: high) &#125; &#125; &#125; 天下第一的快排 涉及到的 Swift 特性：有几个数组高级操作： shuffle() filter shuffle 和 shuffled ，求求你们不要再🦐几把手写那些鬼随机打乱算法了，人家写的好好的，一个直接操作数组，一个返回打乱后的数组。 filter 这是个 Swift 4.2+ 增加的新方法，用于直接选出数组中符合某一类条件的元素，返回值是个数组，用在快排里简直爽到飞起，但是应该是现在的 oj 都还不支持这个函数，这个方法和 reduce ， map 都可能是面试中的重点。 堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 堆和优先队列class Heap&lt;T: Comparable&gt; &#123; var data = [T]() var N = 0 init(size: Int) &#123; data.reserveCapacity(size + 1) &#125; func insert(new: T) &#123; N += 1 data.append(new) swim(N) &#125; // 大元素上浮 func swim(_ k: Int) &#123; var k = k while k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] &#123; // 大节点不断上浮 data.swapAt(k/2, k) k = k / 2 &#125; &#125; // 小元素下沉 func sink(_ k: Int) &#123; var k = k while 2*k &lt;= N &#123; var j = 2 * k if j &lt; N &amp;&amp; data[j] &lt; data[j+1] &#123; // 左节点是较小的节点,选择右节点作为新的根结点 j += 1 &#125; // 如果当前 k 号节点小于其父节点，下沉 guard data[k] &lt; data[j] else &#123; break &#125; data.swapAt(k, j) k = j &#125; &#125; func delMax() -&gt; T &#123; data.swapAt(1, N) let max = data.remove(at: N) N -= 1 sink(1) return max &#125;&#125;class heapSort &#123; func sort(_ array: inout [Int]) &#123; var N = array.count - 1 for k in stride(from: N/2, through: 1, by: -1) &#123; sink(&amp;array, k, N) &#125; while N &gt; 1 &#123; array.swapAt(1, N) N -= 1 sink(&amp;array, 1, N) &#125; &#125; // 大元素上浮 func swim(_ data: inout [Int], _ k: Int, _ N: Int) &#123; var k = k while k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] &#123; // 大节点不断上浮 data.swapAt(k/2, k) k = k / 2 &#125; &#125; // 小元素下沉 func sink(_ data: inout [Int], _ k: Int, _ N: Int) &#123; var k = k while 2*k &lt;= N &#123; var j = 2 * k if j &lt; N &amp;&amp; data[j] &lt; data[j+1] &#123; // 左节点是较小的节点,选择右节点作为新的根结点 j += 1 &#125; // 如果当前 k 号节点小于其父节点，下沉 guard data[k] &lt; data[j] else &#123; break &#125; data.swapAt(k, j) k = j &#125; &#125;&#125; 堆排序没啥的，基本都说完了。需要注意的就是这里的 for 循环和 python 的相同，不能带什么操作，同时倒序的话，可以用 reserve 或者是 stride 将步长设定为 -1。 Reference总结 Swift 中随机数的使用 - CocoaChina 苹果开发中文站 - 最热的iPhone开发社区 最热的苹果开发社区 最热的iPad开发社区]]></content>
      <categories>
        <category>iOS &amp; Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何速成前端三件套 （HTML）]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%A6%82%E4%BD%95%E9%80%9F%E6%88%90%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%20%EF%BC%88HTML%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HTML那些你不知道的标签&lt;body bgcolor=&quot;yellow&quot;&gt; 背景颜色用 bgcolor &lt;a href=“mailto:xxx@yyy”&gt; 发邮件用 mailto &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt; 新窗口用 _blank &lt;td align=&quot;left&quot;&gt; 单元格对其用 align &lt;select&gt; &lt;textarea&gt; 这个不用 input &lt;body background=&quot;background.gif&quot;&gt; 背景图片用 background &lt;hr /&gt; 水平分割线用 hr 浏览器会自动地在段落的前后添加空行。（&lt;p&gt;是块级元素） 应该避免使用下面这些标签和属性：&lt;center&gt; 定义居中的内容。&lt;font&gt; 和 &lt;basefont&gt; 定义 HTML 字体。&lt;s&gt; 和 &lt;strike&gt; 定义删除线文本&lt;u&gt; 定义下划线文本align 定义文本的对齐方式bgcolor 定义背景颜色color 定义文本颜色 style=“text-align:center” 这样居中最帅 &lt;sub&gt; &amp; &lt; sup&gt; 文字下标和上标 &lt;bdo dir=&quot;rtl&quot;&gt; Here is some Hebrew text &lt;/bdo&gt; 倒序输出文本 12345678&lt;blockquote&gt;这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。&lt;/blockquote&gt;这是短的引用：&lt;q&gt;这是短的引用。&lt;/q&gt; &lt;abbr&gt; 有下划线， &lt;dfn&gt; 是斜体 ::&lt;img&gt; 的 title 是鼠标悬浮显示的文字 , alt 是图片出不来的时候显示的文字:: 1234这是邮件链接：&lt;a href="mailto:someone@microsoft.com?subject=Hello%20again"&gt;发送邮件&lt;/a&gt;&lt;/p&gt;&lt;a href="mailto:someone@microsoft.com?cc=someoneelse@microsoft.com&amp;bcc=andsomeoneelse2@microsoft.com&amp;subject=Summer%20Party&amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!"&gt;发送邮件！&lt;/a&gt; 使用 %20 来代替单词之间的空格 &lt;tr&gt; 来换行 &lt;td&gt; 来定义一个单元格 在 &lt;th&gt; 中使用 colspan 或 rowspan 来跨越列或行 如何应付老式的浏览器如果浏览器压根没法识别&lt;script&gt; 标签，那么 &lt;script&gt;标签所包含的内容将以文本方式显示在页面上。为了避免这种情况发生，你应该将脚本隐藏在注释标签当中。那些老的浏览器（无法识别 &lt;script&gt;标签的浏览器）将忽略这些注释，所以不会将标签的内容显示到页面上。而那些新的浏览器将读懂这些脚本并执行它们，即使代码被嵌套在注释标签内。 12345&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--document.write(&quot;Hello World!&quot;)//--&gt;&lt;/script&gt; URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。URL 不能包含空格。URL 编码通常使用 + 来替换空格。 提示：仅仅有 16 种颜色名被 W3C 的 HTML4.0 标准所支持。它们是：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow。 HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 &lt;!DOCTYPE&gt; 的用处。&lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。 &lt;!DOCTYPE html&gt; 是 HTML5 的声明 在 &lt;input&gt; 中使用 readonly 来规定输入字段为只读 等同于 readonly=&quot;readonly&quot; disabled属性规定输入字段是禁用的。被禁用的元素是不可用和不可点击的。被禁用的元素不会被提交。 语义元素清楚地向浏览器和开发者描述其意义。非语义元素的例子：&lt;div&gt; 和 &lt;span&gt; - 无法提供关于其内容的信息。语义元素的例子：&lt;form&gt;、&lt;table&gt; 以及 &lt;img&gt; - 清晰地定义其内容。 那些你必须要知道的东西 GET 和 POST 的区别 大多数 web 服务器（Apache、Unix）对文件名的大小写敏感：不能以 london.jpg 访问 London.jpg。其他 web 服务器（微软，IIS）对大小写不敏感：能够以 london.jpg 或 London.jpg 访问 London.jpg。如果使用混合大小写，那么您必须保持高度的一致性。如果您从对大小写不敏感的服务器转到一台对大小写敏感的服务器上，这些小错误将破坏您的网站。为了避免这些问题，请始终使用小写文件名（如果可以的话）。 HTML5HTML5 新元素 HTML5 增加了如下表单元素： datalist keygen output Internet Explorer 的问题上述方案可用于所有新的 HTML5 元素，但是：注意：Internet Explorer 8 以及更早的版本，不允许对未知元素添加样式。幸运的是，Sjoerd Visscher 创造了 “HTML5 Enabling JavaScript”,”the shiv”： 123&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 这段注释会被 IE 9 以下的浏览器理解，并通过这个脚本文件理解 HTML5 里面新增的标记。 Canvas and SVG SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas 通过 JavaScript 来绘制 2D 图形。Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 Canvas依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试准备]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[基础语言和核心原理 html5 + css3 javascript DOM AJAX MVVM 框架 React Vue.js ReactNative]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 面试准备]]></title>
    <url>%2F2019%2F03%2F16%2FiOS%20%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[基础 可选项和可选链 字符串 闭包 (循环引用) weak GCD runtime UIControler 语言和核心原理 Socket TCP / IP xcode 和各种工具 Carthage cocoapods Swift package manger ReactNative cocoa 框架 项目 pixel app echo app Algorithm ReferenceBeijingIamback - 简书]]></content>
      <categories>
        <category>Internship</category>
      </categories>
      <tags>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于算法的 Swift 学习之路（cocoapod 和 Carthage）]]></title>
    <url>%2F2019%2F03%2F14%2Farc-01%2F</url>
    <content type="text"><![CDATA[为啥要用包管理工具我们在开发过程中会用到（依赖于）其他第三方库，这些库或框架还有可能依赖于其他库或者框架，手动管理这些库或者框架非常麻烦，首先我们需要下载这些库或者框架，然后还要考虑版本兼容性问题，需要手动导入一些依赖包(ps:想想就够了)，还好有CocoaPods和Carthage工具管理项目依赖关系。 CocoaPodsCocoaPods支持项目中采用Objective-C或swift语言。::CocoaPods会将第三方库的源代码编译为静态库.a文件或者静态框架.framework文件的形式，并将它们添加到项目中，建立依赖关系。:: 更换 Ruby 源123456gem sources -l (查看当前ruby的源)gem sources --add https://gems.ruby-china.org/ gem sources --remove https://rubygems.org/ gem sources -lsudo gem install cocoapodspod set 基本使用pod init 来新建 podfile 编辑项目路径下的 Podfile ，可以通过官网检索依赖包或者使用 pod search 命令。cocoapods 是中心化的包管理工具，因此有些没有收录在 cocoapods 中的依赖将不能从中心库直接引入（如 GitHub 上的部分开源项目），对于这种依赖，我们可以通过手动标注原链接的方式引入： pod ‘PNChartSwift’,:git =&gt; &#39;git url&#39; 注意事项123~&gt;3.0 表示大于等于3.0版本，小于下一个主版本，即4.0版本&gt;=3.0 表示大于等于3.0版本==3.0 表示等于3.0版本 Podfile本质上是用来描述Xcode工程中的targets用的。如果我们不显式指定Podfile对应的target，CocoaPods会创建一个名称为default的隐式target，会和我们工程中的第一个target相对应。换句话说，如果在Podfile中没有指定target，那么只有工程里的第一个target能够使用Podfile中描述的Pods依赖库。 如果想在一个Podfile中同时描述project中的多个target，根据需求的不同，可以有不同的实现方式。现在的project中包含的target有：CocoapodsTest、CocoapodsTestTests、CocoapodsTestUITests。 如果引入依赖的时候不显示标示依赖库版本，表示每次都获取最新版本 移除或修改库后，执行pod update 来让更改生效 Podfile.lock 文件执行完pod install之后，会生成一个Podfile.lock文件，该文件用于保存已经安装的Pods依赖库的版本。 Podfile.lock文件最大得用处在于多人开发。对于没有在Podfile中指定Pods依赖库版本的写法，如下：pod ‘Reachability’该句话用于获取当前Reachability这个Pods依赖库的最新版本。当团队中的某个人执行完pod install命令后，生成的Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含 Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的Reachability，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案： 更改Podfile，使其指向最新版本的Reachability依赖库； 执行pod update命令；鉴于Podfile.lock文件对团队协作如此重要，我们建议将它添加到版本管理中。 CarthageCocoaPods已经是一个非常棒的工具了，我们还有另外一个选择——Carthage,它是一个轻量级的项目依赖管理工具。Carthage主张“::去中心化::”和“::非侵入性::”。CocoaPods搭建了一个中心库，第三方库被收入到该中心库，所以没有收录的第三方库是不能使用CocoaPods管理的，这就是所谓的”中心化“思想。而Carthage没有这样的中心库，::第三方库基本上都是从GitHub或者私有git库中下载的，这就是“去中心化”::。另外，CocoaPods下载第三方库后，会将其编译成静态链接库或者动态框架文件，这种做法会修改Xcode项目属性配置依赖关系，这就是所谓的”侵入性“。而Carthage下载成功后，会将第三方库编译为::动态框架::，由开发人员自己配置依赖关系，::Carthage不会修改Xcode项目属性::，这就是所谓的”非侵入性“。 基本使用 创建Xcode工程并切换到该工程路径 创建一个Cartfile，将你想要使用的框架列在里面github “AFNetworking/AFNetworking” ~&gt; 3.0github “rs/SDWebImage”github “github url” 运行carthage update，将获取依赖文件到一个Carthage.checkout文件夹，然后编译每个依赖 在你的应用程序target的General设置标签中的Embedded Binaries区域，将框架从Carthage.build文件夹拖拽进去。 注意事项Carthage编译你的依赖，并提供框架的二进制文件，但你仍然保留对项目的结构和设置的完整控制。Carthage不会自动的修改你的项目文件或编译设置。Carthage只正式支持动态框架，动态框架能够在任何版本的OS X上使用，但只能在iOS 8及以上版本使用。 CocoaPods 和 Carthage 的区别 Carthage只支持iOS 8及以上版本使用。 首先，CocoaPods默认会自动创建并更新你的应用程序和所有依赖的Xcode workspace。Carthage使用xcodebuild来编译框架的二进制文件，但如何集成它们将交由用户自己判断。CocoaPods的方法更易于使用，但Carthage更灵活并且是非侵入性的。 CocoaPods的目标在它的README文件描述如下：…为提高第三方开源库的可见性和参与度，创建一个更中心化的生态系统。与之对照，Carthage创建的是去中心化的依赖管理器。它没有总项目的列表，这能够减少维护工作并且避免任何中心化带来的问题（如中央服务器宕机）。不过，这样也有一些缺点，就是项目的发现将更困难，用户将依赖于Github的趋势页面或者类似的代码库来寻找项目。 CocoaPods项目同时还必须包含一个podspec文件，里面是项目的一些元数据，以及确定项目的编译方式。Carthage使用xcodebuild来编译依赖，而不是将他们集成进一个workspace，因此无需类似的设定文件。不过依赖需要包含自己的Xcode工程文件来描述如何编译。 最后，我们创建Carthage的原因是想要一种尽可能简单的工具——一个只关心本职工作的依赖管理器，而不是取代部分Xcode的功能，或者需要让框架作者做一些额外的工作。CocoaPods提供的一些特性很棒，但由于附加的复杂性，它们将不会被包含在Carthage当中。 Reference https://www.jianshu.com/p/6c4b1b4a69c5iOS cocoapods 使用以及版本更新 - chrisbin - 博客园CocoaPods和Carthage浅析(新) - 简书]]></content>
      <categories>
        <category>iOS &amp; Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试准备]]></title>
    <url>%2F2019%2F03%2F11%2F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[internship 面试方向 IOS 开发 后端开发 前端开发 爬虫和数据分析 投递范围 BAT Jike ByteDance bilibili MicroSoft Google 各大独角兽🦄️ 时间点腾讯暑期实习生招聘FAQ — 校招动态 | Tencent 校园招聘京东招聘——招聘流程 基本准备 简历 英语六级 啃书 编程珠玑（英文） 重构（英文） TCP / IP 卷一 （英文） 计算机组织与结构（英文） 算法 技能树语言级别 C 高级 JAVA 高级 Python 高级 Swift 高级 JavaScript 高级 基础级别 算法和刷题 操作系统 编译原理 面向对象 计算机网络 数据结构 计算机组成 数据库原理 应用级别 关系型数据库 非关系型数据库 SQLite Linux 编程 Cocoa 架构 前端框架一到两个 后端维护及框架一到两个 爬虫框架一到两个 Docker 高级 Linux http 和 TCP/IP 协议 产品及项目级别 一个完整的 Swift 项目 小程序迭代 博客搭建 ::完成度✅ 达到 80% 以上就买 AirPods 🎧::]]></content>
      <categories>
        <category>Internship</category>
      </categories>
      <tags>
        <tag>TODO</tag>
      </tags>
  </entry>
</search>
