<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何拿下前端面试（网络篇）]]></title>
    <url>%2F2019%2F03%2F23%2Farc-08%2F</url>
    <content type="text"><![CDATA[应用层（HTTP / HTTPS） 状态码1XX信息性状态码，表示接收的请求正在处理。 2XX成功状态码，表示请求正常处理完毕 200 OK请求正常处理，会根据不同的请求方法返回不同的响应信息。 204 No Content请求成功处理，但在返回的响应报文中不含实体的主体部分。也不允许返回任何实体的主体。一般用于客户端的信息发送，不需要接收任何新信息的时候。 206 Partial Content表示范围请求成功处理，响应报文中包含由 Content-Range 指定范围的实体内容。 3XX重定向状态码，表示需要进行附加操作以完成请求 301 Moved Permanently永久性重定向。表示该请求的资源已经被分配到了其他的 URL 上。 302 Found临时重定向 303 See Other表示由于请求对应的资源存在另一个 URL，应使用 GET 方法定向获取请求的资源。 304 Not Modified如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。简单的表达就是：客户端已经执行了GET，但文件未变化。 307 Temporary Redirect临时重定向，与 302 有点区别。 4XX客户端错误状态码，服务器无法处理请求 400 Bad Request请求报文中存在语法错误。 401 Unauthorized表示用户未授权，可用于用户状态验证。 403 Forbidden表示请求被服务器拒绝了，没有访问权限。 404 Not Found服务器上没有请求的资源。 5XX服务器错误状态码，服务器处理请求出错 500 Internal Server Error后台服务器 bug 啦 503 Service Unavailable服务器超负载或者是停机维护。 GET 和 POST 的区别常规意义上的区别 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 容易错误的理解GET使用URL或Cookie传参，而POST将数据放在BODY中 GET和POST是什么？HTTP协议中的两种发送请求的方法。HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 GET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。 HTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。 GET方式提交的数据有长度限制，则POST的数据则可以非常大 HTTP协议对GET和POST都没有对长度的限制。HTTP协议明确地指出了，HTTP头和Body都没有长度的要求。首先是”GET方式提交的数据有长度限制”，如果我们使用GET通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 注意这个限制是整个URL长度，而不仅仅是你的参数值数据长度。POST也是一样，POST是没有大小限制的，HTTP协议规范也没有对POST数据进行大小限制，起限制作用的是服务器的处理程序的处理能力。当然，我们常说GET的URL会有长度上的限制这个说法是怎么回事呢？虽然这个不是GET和POST的本质区别，但是我们也可以说说导致URL长度限制的两方面的原因： 浏览器。早期的浏览器会对URL长度做限制。而现在的具体限制是怎么样的，我自己没有亲测过，就不复制网上的说法啦。 服务器。URL长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个M大小的URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，告诉服务器Content-Length是一个很大的数，然后只给服务器发一点儿数据，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。 POST比GET安全，因为数据在地址栏上不可见 这个说法其实也是基于上面的1，2两点的基础上来说的，我觉得没什么问题，但是需要明白为什么使用GET在地址栏上就不安全了，以及还有没有其他原因说明“POST比GET安全”。通过GET提交数据，用户名和密码将明文出现在URL上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。 满分回答是啥样GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别，上面的只是在使用上的区别。 什么是幂等性？幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。 正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。POST 操作具有副作用，也就是说会更改服务器上的状态。另外 POST 操作一般不是幂等的，每次 POST 操作都应该创建一个新的资源。 cookie、localstroage、sessionstroage的区别Cookie适合存储一些session信息： cookie限制大小，约4k左右，不适合存储业务数据，尤其是数据量较大的值 存在有效期，到期自动销毁 cookie会每次随http请求一起发送，浪费宽 cookie设置了domain可以在子域共享跨域 可以使用爬虫抓取localstroage适合存储应用共享的地址信息等： 存储数据量大，5M或者更大 有效期为永久 不会随http请求一起发送 不能跨域，但是可以使用postMessage和iframe消除这个影响,例如： cross-storage 在浏览器的隐私模式下不能读取 不能被爬虫读取sessionstroage适合存储浏览状态等： 存储数据量大，5M或者更大 有效期为到浏览器关闭 不会随http请求一起发送 不能被爬虫读取 SessionHTTP 是个无状态的链接，为了记录 HTTP 状态，催生了 Cookie 和 Session 。 Cookie 存在客户端，Session 存在服务器。依赖 Cookie 在响应头中 Set-Cookie: JSESSIONID = xxx 常用的三种实现方式 依赖 Cookie 实现 直接在 URL 后边重写 设置一个隐藏的表单域 过多的浏览器请求，会在服务器端创建很多的Session信息，会对浏览器造成一定的内存压力，而且不易于维护。 token基于token的验证是无状态的。服务器不记录哪些用户已登陆或者已经发布了哪些JWT。对服务器的每个请求都需要带上验证请求的token。该标记既可以加在header中，可以在POST请求的主体中发送，也可以作为查询参数发送。 存储方式 存在 Cookie 存在 localStorage 工作流程： 用户输入登陆凭据； 服务器验证凭据是否正确，然后返回一个经过签名的token； 客户端负责存储token，可以存在local storage，或者cookie中； 对服务器的请求带上这个token； 服务器对JWT进行解码，如果token有效，则处理该请求； 一旦用户登出，客户端销毁token。 优势 基于token的验证是无状态的，这也许是它相对cookie来说最大的优点。后端服务不需要记录token。每个令牌都是独立的，包括检查其有效性所需的所有数据，并通过声明传达用户信息。服务器唯一的工作就是在成功的登陆请求上签署token，并验证传入的token是否有效。 好的API可以同时支持浏览器，iOS和Android等移动平台。然而，在移动平台上，cookie是不被支持的。 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多。 格式 JWT 包括三个部分：头部、载荷、签名，通过. 连接这三部分。 头部通常包括两部分：token类型（JWT），和使用到的算法，如HMAC、SHA256或RSA，下面是一个例子，说明这是一个JWT，使用的签名算法是HS256。 头部会通过Base64Url编码形成JWT的第一部分 第二部分是载荷，要传递出去的声明，其中包含了实体（通常是用户）和附加元数据。有三种类型的声明： 保留声明：这是一组预定义的声明，非强制性，用来帮助接收方（服务器）更好地理解这个JWT。其中包括：iss（issuer，该JWT的签发者），exp（expiration time，过期时间），sub（subject，该JWT所面向的用户），aud（audience，JWT的接收者），和另外一些声明 公共声明：这些可以用使用JWT的人随意定义。但是为了避免冲突，应在在IANA JSON WEB令牌注册表中定义它们，或者将其定义为包含防冲突命名空间的URI。 私有声明：这些是为了在同意使用它们的各方之间共享信息而创建的自定义声明。 传输层（TCP / IP）￼ 三次🤝 四次🙋TCP 与 UDP 的区别网络层IP 协议数据链路层物理层安全CORSCross-Origin Resource Sharing跨来源资源共享，是一份浏览器技术规范，提供了 WEB 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。 简单请求并不会触发 CORS 预检关于 CORS 的详细介绍参见 MDN 和阮一峰的博客。 CORS是W3c工作草案，它定义了在跨域访问资源时浏览器和服务器之间如何通信。CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否。同源策略：是浏览器最核心也最基本的安全功能；同源指的是：同协议，同域名和同端口。精髓：认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源；JSON &amp; JSONP:JSON 是一种基于文本的数据交换方式，或者叫做数据描述格式。JSONP是资料格式JSON的一种“使用模式”，可以让网页从别的网域要资料，由于同源策略，一般来说位于server1.example.com的网页无法与不是 server1.example.com的服务器沟通，而HTML的script元素是一个例外。利用script元素的这个开放策略，网页可以得到从其他来源动态产生的JSON资料，而这种使用模式就是所谓的JSONP 解决方案主要解决思路：使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否.Access-Control-Allow-Origin:指定授权访问的域Access-Control-Allow-Methods：授权请求的方法（GET, POST, PUT, DELETE，OPTIONS等) 后端解决 增加一个过滤器来处理预检请求 返回包含哪些与 CORS 有关的响应头 或者是通过 Nginx 来支持跨域 前端解决 vue 和 webpack 都可以通过调用 http-proxy-middleware 这个库来实现客户端代理，从而解决跨域问题。 XSS 攻击XSS，即为（Cross Site Scripting），中文名为跨站脚本,跨站脚本的重点不在“跨站”上，而在于“脚本”上。大多数XSS攻击的主要方式是嵌入一段远程或者第三方域上的JS代码，实际上是在目标网站的作用域下执行了这段第三方域上的js代码。 反射型XSS（非持久型XSS）特点：就像镜子反射一样，浏览器发射含XSS的url，服务器将其反射回来 浏览器发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器， 服务器解析并响应，响应结果中包含XSS代码， 最后浏览器解析并执行。 攻击者会将 XSS 脚本通过请求参数的方式发送到服务器，服务器执行后会返回 cookie 信息等隐私信息。一般黑客会注入一段第三方的js代码，然后将获取到的cookie信息存到他们的服务器上，拿到我们的身份认证做一些违法的事情了。 存储型XSS（持久型XSS）特点：黑客将XSS代码发送给服务器，然后通过服务器散播 黑客将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。） 其他人请求页面的时候就会带上XSS代码了。 案例：最典型的就是留言板XSS。 黑客提交了一条包含XSS代码的留言到数据库。 当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。 浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。 DOM 型 XSS特点：DOM XSS代码不需要服务器端的解析响应的直接参与，而是完全通过浏览器端的DOM解析。 浏览器的代码中含有eval，new Function等将字符串内容执行的代码 在执行的字符串中嵌入可以执行XSS代码字符串 案例： 1234567test.addEventListener('click', function () &#123; var node = window.eval(txt.value) window.alert(node)&#125;, false)//txt中的代码如下:&lt;img src='null' onerror='alert(123)' /&gt; 危害和防御 通过document.cookie盗取cookie 使用js或css破坏页面正常的结构与样式 流量劫持（通过访问某段具有window.location.href定位到其他页面） Dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。 利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。 XSS攻击可以看出，不能原样的将用户输入的数据直接存到服务器，需要对数据进行一些处理： 过滤危险的DOM节点。如具有执行脚本能力的script, 具有显示广告和色情图片的img, 具有改变样式的link, style, 具有内嵌页面的iframe, frame等元素节点。 过滤危险的属性节点。如on-, style, src, href等 对cookie设置httpOnly,但是也会导致前台无法操作cookie，不太推荐。 CSRFCSRF（Cross-site request forgery），中文名称：跨站请求伪造，攻击者盗用了你的身份，以你的名义发送恶意请求。 特点： 登录受信任网站A，并在本地生成Cookie。 在不登出受信任网站A的情况下，访问危险网站B。 危险网站会向受信任A的网站发送请求，同时会携带受信任网站A本地生成Cookie(用同一个浏览器访问同一个域的接口) 危害和防御 篡改目标网站上的用户数据； 盗取用户隐私数据； 作为其他攻击向量的辅助攻击手法； 传播CSRF蠕虫。 防御 验证码，因为验证码必须在受信任的网站上发送给浏览器的，并且伪造的网站和受信任的网站非同源，所以没有办法获取受信任网站发送的session，所以验证码是没有办法伪造的。 refer，标识了当前请求的页面的源，伪造网站可以篡改成受信任的网站源，并不保险 token，由于它是通过服务的发送给客户端的令牌，并且存储在浏览器的localstorage中，由于同源策略，并且token还有校验规则，所以token并不能轻易篡改。 HTTPS 怎么预防攻击HTTPS = (HTTP+TLS/SSL) 自己先问问自己点击一个 url 到页面被渲染出来，中间都发生了什么？面试必问，很大概率是第一问，要从五层体系结构开始吹，注意其中的用词，把技术词汇朝自己想好的坑里带，如最短路径，CORS，TCP 和 UDP 的区别，总之就是千万不要出现自己解释不好的词汇，防止给自己挖坑。 HTTP 和 HTTPS 的区别？ TCP 和 UDP 的区别 握手和挥手，说一说 如何解决跨域 ReferenceCookie和Token - WillieLiu的专栏 - CSDN博客 搞定计算机网络面试，看这篇就够了 - 掘金 HTTP｜GET 和 POST 区别？网上多数答案都是错的！ - 简书 99%的人都理解错了HTTP中GET与POST的区别 前端必须懂的计算机网络知识—(跨域、代理、本地存储) - 掘金 CORS 跨域 实现思路及相关解决方案 - sloong - 博客园 Webpack-dev-server的proxy用法 - 简书 阮一峰的 CORS 详解 HTTP访问控制（CORS） - HTTP | MDN CORS(跨域资源共享) - spaceway - 博客园]]></content>
      <categories>
        <category>前端</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何拿下前端面试（基础篇之 MVVM）]]></title>
    <url>%2F2019%2F03%2F23%2Farc-07%2F</url>
    <content type="text"><![CDATA[定义Model-View-ViewModel MVVM 其实就是提供 View 和 Model 的双向绑定，由前端架构而兴起，为了解决大前端中对 DOM 的频繁操作带来的性能问题，也让前端如 H5 界面拥有了更强大的功能，甚至可以独立与服务端完成数据操作。 Vue.js 是部分遵循了 MVVM 架构的（官方说法可不是一个完全遵循 MVVM 的框架），主打的就是数据驱动的架构方法，采用了数据劫持的方法来为我们实现了 ViewModel 中的双向数据绑定，可以自动保持视图和数据的一致性，让开发更加高效，便捷。 MVVM，说到底还是一种分层架构。它的分层如下： Model: 域模型，用于持久化 View: 作为视图模板存在 ViewModel: 作为视图的模型，为视图服务 为什么不用 MVC既然我们想要前端也拥有实现数据操作业务的功能，那么我们为什么不选择更加成熟的 MVC 呢？ 传统的 MVC 在前端开发中会暴露以下几个问题： 开发者在代码中大量调用相同的 DOM API, 处理繁琐 ，操作冗余，使得代码难以维护。 大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致 Model 发生变化，开发者同样需要将变化的数据同步到Model 中，这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。 主要的问题实际上还是直接对原生 DOM 的频繁操作实在是太繁琐而且拉低渲染性能了。 MVVM 实际上就是把 Model 和 View 之间的同步逻辑自动化了，VM 代替了 MVP 中的 Presenter，而且不在需要我们进行手动操作，整个前端架构的逻辑统统交给数据来驱动。 视图引擎视图引擎：我是视图引擎，我为 View 层作为视图模板提供强力支持，开发者，你们不需要操作 DOM ，丢给我来做！ 数据存取器数据存取器：我是数据存取器，我可以通过Object.defineProperty()API 轻松定义，或通过自行封装存取函数的方式曲线完成。我的内部往往封装了发布/订阅模式，以此来完成对数据的监听、数据变更时通知更新。我是数据绑定实现的基础。 组件机制组件机制：我是组件机制。有追求的开发者往往希望按照面向未来的组件标准 －Web Components的方式开发，我是为了满足你的追求而生。MVVM 框架提供组件的定义、继承、生命周期、组件间通信机制，为开发者面向未来开发点亮明灯。 Vue 里头是怎么实现的不同的MVVM框架中，实现双向数据绑定的技术有所不同。目前一些主流的前端框架实现数据绑定的方式大致有以下几种： 数据劫持 (Vue) 发布-订阅模式 (Knockout、Backbone) 脏值检查 (Angular) Vue.js 是采用 Object.defineProperty 的 getter 和 setter，并结合观察者模式来实现数据绑定的。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data选项时，Vue 将遍历它的属性，用Object.defineProperty将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。 从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用Object.defineProperty将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行扫描和解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。 Observer数据监听器，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者，内部采用Object.defineProperty的getter和setter来实现。 Compile指令解析器，它的作用对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。 Watcher订阅者， 作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。 Dep消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。 实际上实现数据双向绑定的代码并不复杂，我们可以参考下面的链接自己试着实现一下 ReferenceVue.js 和 MVVM - SweetoDream - CSDN博客浅析前端开发中的 MVC/MVP/MVVM 模式 - 掘金不好意思！耽误你的十分钟，让MVVM原理还给你 - 掘金什么是MVVM - JrayZhang - SegmentFault 思否]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式详解（JavaScript 描述）]]></title>
    <url>%2F2019%2F03%2F22%2Farc-06%2F</url>
    <content type="text"><![CDATA[元字符\s匹配~任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等~。\w匹配~字母或数字或下划线或汉字~。 一些🌰： 12345\ba\w*\b 匹配以字母a开头的单词——先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。\d+匹配1个或更多连续的数字。这里的+是和*类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次。\b\w&#123;6&#125;\b匹配刚好6个字符的单词。 元字符^（和数字6在同一个键位上的符号）和$都匹配一个位置，这和\b有点类似。^匹配你要用来查找的字符串的开头，$匹配结尾。这两个代码在验证输入的内容时非常有用，比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d{5,12}$。这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}匹配~只能不多不少重复2次~，{5,12}则是~重复的次数不能少于5次，不能多于12次~，否则都不匹配。因为使用了^和$，所以输入的整个字符串都要用来和\d{5,12}来匹配，也就是说整个输入~必须是5到12个数字~，因此如果输入的QQ号能匹配这个正则表达式的话，那就符合要求了。和忽略大小写的选项类似，有些正则表达式处理工具还有一个处理多行的选项。如果选中了这个选项，^和$的意义就变成了~匹配行的开始处和结束处~。 字符转义如果你想查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\来取消这些字符的特殊意义。因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\.例如：deerchao\.net匹配deerchao.net，C:\\Windows匹配C:\Windows。 重复 字符类字符类用于匹配没有预定义元字符的字符集合。使用方括号来表示一个字符类。举几个🌰： 12345[aeiou]就匹配任何一个英文元音字母，[.?!]匹配标点符号(.或?或!)。[0-9]代表的含意与\d就是完全一致的：一位数字；同理[a-z0-9A-Z_]也完全等同于\w（如果只考虑英文的话）。一个更复杂的表达式：\(?0\d&#123;2&#125;[) -]?\d&#123;8&#125;。这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。 分枝条件分枝条件类似于逻辑运算中的或，只要满足一种规则都应匹配。使用 | 来把不同的规则分隔开。举几个🌰： 1230\d&#123;2&#125;-\d&#123;8&#125;|0\d&#123;3&#125;-\d&#123;7&#125;这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。\(0\d&#123;2&#125;\)[- ]?\d&#123;8&#125;|0\d&#123;2&#125;[- ]?\d&#123;8&#125;这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。\d&#123;5&#125;-\d&#123;4&#125;|\d&#123;5&#125;这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。 最后一个例子能说明一个问题：使用分枝条件时，要注意各个条件的顺序。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。 分组使用分组来重复多个字符。分组可以被后向引用，也可以被部分编程语言直接提取使用。使用小括号来指定一个分组。举几个🌰：12(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d&#123;1,3&#125;匹配1到3位的数字，(\d&#123;1,3&#125;\.)&#123;3&#125;匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d&#123;1,3&#125;)。不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)。 这里请彻底理解 2[0-4]\d|25[0-5]|[01]?\d\d? 反义反义元字符用来查找不属于定义的字符类的字符，常常是元字符的大写。 后向引用使用小括号分组一个表达式后，匹配这个表达式的文本，也就是分组捕获的内容，可以在表达式或其他程序中做进一步的处理。默认每个分组拥有一个组号，从左向右，第一个分组组号为 1，以此类推。后向引用可以用于重复搜索前面某个分组匹配的文本，而不用重写那些冗长的规则。举几个🌰： 123\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?&lt;Word&gt;\w+)(或者把尖括号换成&apos;也行：(?&apos;Word&apos;\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k&lt;Word&gt;,所以上一个例子也可以写成这样：\b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b。 零宽断言接下来的四个断言用于查找在某些内容（不包括这些内容）之前或之后的东西。之所以叫做断言，是因为他们给出了匹配位置应该满足的条件。注意，什么是位置匹配，这些字符并不匹配任何字符，他们匹配的是满足响应条件的位置，我们可以把位置看成是任意两个字符之间的空字符。断言是很典型的用来位置匹配的表达式。 ES5 中共有 6 个锚字符^ $ \b \B (?=p) (?!p) 正向零宽断言零宽度正预测先行断言 (?=exp) 它断言自身出现的位置的后边能匹配表达式 exp 。举个🌰： 1\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I&apos;m singing while you&apos;re dancing.时，它会匹配sing和danc。 零宽度正回顾后发断言 (?&lt;=exp) 它断言自身出现的位置的前面能匹配表达式 exp。举个🌰： 1(?&lt;=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。 负向零宽断言前面我们提到过怎么查找不是某个字符或不在某个字符类里的字符的方法(反义)。但是如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词—它里面出现了字母q,但是q后面跟的不是字母u,我们可以尝试这样：\b\w*q[^u]\w*\b匹配~包含后面不是字母u的字母q的单词~。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w\b将会匹配下一个单词，于是`\b\wq[^u]\w\b就能匹配整个Iraq fighting。**负向零宽断言**能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。现在，我们可以这样来解决这个问题：\b\wq(?!u)\w*\b`。 零宽度负预测先行断言 (?!exp) 它断言此位置的后边不能匹配表达式 exp举个🌰： 12\d&#123;3&#125;(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。 零宽度负预测后发断言 (?&lt;!exp) 它断言此位置的前面不能匹配表达式 exp举个🌰： 123(?&lt;![a-z])\d&#123;7&#125;匹配~前面不是小写字母的七位数字~。一个更复杂的例子：(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)匹配不包含属性的简单HTML标签内里的内容。(?&lt;=&lt;(\w+)&gt;)指定了这样的前缀：被尖括号括起来的单词(比如可能是&lt;b&gt;)，然后是.(任意的字符串),最后是一个后缀(?=&lt;\/\1&gt;)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是&lt;b&gt;的话，后缀就是&lt;/b&gt;了。整个表达式匹配的是&lt;b&gt;和&lt;/b&gt;之间的内容(再次提醒，不包括前缀和后缀本身)。 总结其实我们很容易就能发现一个规律。 先行断言的表达式一般放在后面，用来匹配的却是表达式前的内容。 后发断言的表达式一般放在前面，用来匹配的却是表达式后的内容。 注释小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。要包含注释的话，最好是启用“忽略模式里的空白符”选项，（JavaScript 是不支持这个的）这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样： 1234567(?&lt;= # 断言要匹配的文本的前缀&lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)) # 前缀结束.* # 匹配任意文本(?= # 断言要匹配的文本的后缀&lt;\/\1&gt; # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签) # 后缀结束 贪婪与懒惰当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配~最长的以a开始，以b结束的字符串~。如果用它来搜索aabab的话，它会匹配整个字符串~aabab~。这被称为贪婪匹配。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着~匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复~。现在看看懒惰版的例子吧：a.*?b匹配~最短的，以a开始，以b结束的字符串~。如果把它应用于aabab的话，它会匹配~aab（第一到第三个字符）~和~ab（第四到第五个字符）~。 平衡组和递归匹配递归匹配，可以用于匹配嵌套元素中的最小元素，用法实在是太抽象了，用的时候再查吧。 JavaScript 中的正则表达式JavaScript 有个原生对象，regexp，同时 string 的部分方法也支持正则表达式。使用 /exp/ 来包裹表达式来生成一个 regexp 对象。正则表达式标识：g -&gt; 全局匹配，匹配多次i -&gt; 大小写不敏感m -&gt; 多行，此时的 ^ 和 $ 匹配的是行结束符。 JavaScript 中能使用正则表达式的方法： 案例分析匹配 16 进制颜色值要求匹配： 1234#ffbbad#Fc01DF#FFF#ffE 分析：表示一个16进制字符，可以用字符组[0-9a-fA-F]。其中字符可以出现3或6次，需要是用量词和分支结构。使用分支结构时，需要注意顺序。正则如下： 12var regex = /#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g; var string = "#ffbbad #Fc01DF #FFF #ffE"; console.log( string.match(regex) ); // =&gt; ["#ffbbad", "#Fc01DF", "#FFF", "#ffE"] 匹配时间要求匹配 24 小时制的时间 共4位数字，第一位数字可以为[0-2]。当第1位为2时，第2位可以为[0-3]，其他情况时，第2位为[0-9]。第3位数字为[0-5]，第4位为[0-9]正则如下：1var regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/; console.log( regex.test("23:59") ); console.log( regex.test("02:07") ); // =&gt; true // =&gt; true 如果也要求匹配7:9，也就是说时分前面的0可以省略。 1234567var regex = /^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/;console.log( regex.test("23:59") ); console.log( regex.test("02:07") ); console.log( regex.test("7:9") ); // =&gt; true// =&gt; true// =&gt; true 不匹配任何东西的正则/.^/ 因为此正则要求只有一个字符，但该字符后面是开头。 驼峰化1234567function camelize(str) &#123; return str.replace(/[-_\s]+(.)?/g, function(match, c) &#123; return c ? c.toUpperCase() : ''; &#125;);&#125;console.log( camelize('-moz-transform') ); // =&gt; "MozTransform" 其中分组(.)表示首字母。单词的界定是，前面的字符可以是多个连字符、下划线以及空白符。正则后面的?的目的，是为了应对str尾部的字符可能不是单词字符，比如str是’-moz-transform ‘。 Reference正则表达式30分钟入门教程 JS正则表达式完整教程（略长） - 掘金]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 高级（Vue Router 基础）]]></title>
    <url>%2F2019%2F03%2F21%2Farc-05%2F</url>
    <content type="text"><![CDATA[动态路由匹配我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个User组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。 响应路由参数的变化 这就是为什么 PixelStack 不会刷新，早看了这个早就刷新了。😂 提醒一下，当使用路由参数时，例如从/user/foo导航到/user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化)$route对象： 12345678const User = &#123; template: '...', watch: &#123; '$route' (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125; 或者使用 2.2 版本中引入的导航守卫 1234567const User = &#123; template: '...', beforeRouteUpdate (to, from, next) &#123; // react to route changes... // don't forget to call next() &#125;&#125; 捕获所有路由或 404 Not found 路由常规参数只会匹配被/分隔的 URL 片段中的字符。如果想匹配任意路径，我们可以使用通配符 (*)： 当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由{ path: ‘’ }通常用于客户端 404 错误。如果你使用了History 模式，请确保 正确配置你的服务器 。当使用一个通配符时，$route.params内会自动添加一个名为pathMatch参数。它包含了 URL 通过通配符*被匹配的部分： 123456// 给出一个路由 &#123; path: '/user-*' &#125;this.$router.push('/user-admin')this.$route.params.pathMatch // 'admin'// 给出一个路由 &#123; path: '*' &#125;this.$router.push('/non-existing')this.$route.params.pathMatch // '/non-existing' 高级匹配模式vue-router使用 path-to-regexp 作为路径匹配引擎，所以支持很多高级的匹配模式，例如：可选的动态路径参数、匹配零个或多个、一个或多个，甚至是自定义正则匹配。查看它的 文档 学习高阶的路径匹配，还有 这个例子 展示vue-router怎么使用这类匹配。 匹配优先级有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。 嵌套路由要在嵌套的出口中渲染组件，需要在VueRouter的参数中使用children配置： 1234567891011121314151617181920const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'profile', component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'posts', component: UserPosts &#125; ] &#125; ]&#125;) 要注意，以 / 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。你会发现，children配置就是像routes配置一样的路由配置数组，所以呢，你可以嵌套多层路由。此时，基于上面的配置，当你访问/user/foo时，User的出口是不会渲染任何东西，这是因为没有匹配到合适的子路由。如果你想要渲染点什么，可以提供一个 空的 子路由： 1234567891011121314const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中 &#123; path: '', component: UserHome &#125;, // ...其他子路由 ] &#125; ]&#125;) 编程式的导航除了使用 标签来定义导航连接，我们还可以借助 router 的实例方法，通过编写代码来实现。常用的方法有三个 router.push(location, onComplete?, onAbort?) 想要导航到不同的 URL，则使用router.push方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。当你点击时，这个方法会在内部调用，所以说，点击等同于调用router.push(…)。该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如： 1234567891011// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: '123' &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) 注意：如果提供了path，params会被忽略，上述例子中的query并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的name或手写完整的带有参数的path： 12345const userId = '123'router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user 同样的规则也适用于router-link组件的to属性。在 2.2.0+，可选的在router.push或router.replace中提供onComplete和onAbort回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。注意： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个/users/1-&gt;/users/2)，你需要使用 beforeRouteUpdate 来响应这个变化 (比如抓取用户信息)。 router.replace(location, onComplete?, onAbort?) 跟router.push很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。 router.go(n) 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似window.history.go(n)。 123456789101112// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100) 你也许注意到router.push 、router.replace 和router.go跟 window.history.pushState、window.history.replaceState和window.history.go 好像， 实际上它们确实是效仿window.historyAPI 的。因此，如果你已经熟悉Browser History APIs Browser History APIs，那么在 Vue Router 中操作 history 就是超级简单的。还有值得提及的，Vue Router 的导航方法 (push、replace 、go ) 在各类路由模式 (history 、hash和abstract ) 下表现一致。 重定向和别名重定向也是通过routes配置来完成，下面例子是从/a重定向到/b： 12345678910const router = new VueRouter(&#123; routes: [ &#123; path: '/a', redirect: '/b' &#125;, &#123; path: '/a', redirect: &#123; name: 'foo' &#125;&#125;, &#123; path: '/a', redirect: to =&gt; &#123; // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 &#125;&#125; ]&#125;) 注意，导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上，在这个例子中，为 /a 路由添加beforeEach 或 beforeLeave 守卫并不会有任何效果。 路由组件传参在组件中使用$route会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。 我们可以使用 props 将其接耦 如果rops被设置为true ，route.params 将会被设置为组件属性。 12345678910111213141516const User = &#123; props: ['id'], template: '&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, props: true &#125;, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： &#123; path: '/user/:id', components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) HTML 5 History 模式]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP or UDP ?]]></title>
    <url>%2F2019%2F03%2F20%2Farc-04%2F</url>
    <content type="text"><![CDATA[TCP / IP 网络模型计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。 TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。 TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。 链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。 网络层：负责路由以及把分组报文发送给目标网络或主机。 传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。 应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。 在网络体系结构中网络通信的建立必须是在通信双方的对等层进行，不能交错。 在整个数据传输过程中，数据在发送端时经过各层时都要附加上相应层的协议头和协议尾（仅数据链路层需要封装协议尾）部分，也就是要对数据进行协议封装，以标识对应层所用的通信协议。TCP 和 UDP 就是 TCP/IP 中两个具有代表性的传输层协议。 TCPTransmission Control Protocol 当一台计算机想要与另一台计算机通讯时，两台计算机之间的通信需要畅通且可靠，这样才能保证正确收发数据。例如，当你想查看网页或查看电子邮件时，希望完整且按顺序查看网页，而不丢失任何内容。当你下载文件时，希望获得的是完整的文件，而不仅仅是文件的一部分，因为如果数据丢失或乱序，都不是你希望得到的结果，于是就用到了TCP。TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。 连接过程三次握手🤝 第一次握手：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。 第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为第三次握手为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。 四次挥手🙋‍♂️ TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。 第一次挥手：若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。 第二次挥手：B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。 第三次挥手：B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。 第四次挥手：A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 特点 面向连接：面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 仅支持单播传输：每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。 面向字节流：TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。 可靠传输：对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。 提供拥塞控制：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。 TCP提供全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）。 UDPUser Datagram Protocol用户数据报协议 特点 面向无连接 不需要像 TCP 一样通过三次握手建立连接，想发就发，而且也不对数据报文进行任何处理。 具体来说就是： 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了； 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。 有单播，多播，广播的功能 UDP 不止支持一对一的传输，同样支持一对多，多对多，多对一，也就是单播，广播，多播。 UDP 是面向报文的 UDP 仅对报文添加首部后就向下交付给 IP 层，UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界，因此，应用程序必须选择合适大小的报文。 不可靠性 首先不可靠性就体现在无连接上，想发就发，收到什么就传递什么，不对数据进行备份，而且也不在乎对方是否正确的收到了数据。其次，网络环境时好时坏，因为UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络环境不好，也不会对发送速率进行调整。这样实现的弊端就是在网络环境不好的情况下会导致丢包，但是优点也很明显，在某些实时性要求较高的场景（电话会议，视频直播）我们就需要使用 UDP 而不是 TCP。 头部开销小，传输数据报文时很高效 UDP 头部包含了以下几个数据： 两个十六位的端口号，分别为源端口（可选字段）和目标端口； 整个数据报文的长度； 整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误。因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。 对比 TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为。 对数据准确性要求高，速度可以相对较慢的，可以选用TCP。 ReferenceTCP和UDP比较 - 浪里行舟的博客 - CSDN博客]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何速成前端三件套 （CSS）]]></title>
    <url>%2F2019%2F03%2F19%2Farc-03%2F</url>
    <content type="text"><![CDATA[常用属性 层叠次序一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 4 拥有最高的优先权。 浏览器缺省设置 外部样式表 内部样式表（位于 标签内部） 内联样式（在 HTML 元素内部） 因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。 盒模型every element in web design is a rectangular box 盒模型(box model)是CSS中的一个重要概念，它是元素大小的呈现方式。 CSS3中新增了一种盒模型计算方式：box-sizing熟悉。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下： content-box（默认） 布局所占宽度Width：Width = width + padding-left + padding-right + border-left + border-right布局所占高度Height:Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box 布局所占宽度Width：Width = width(包含padding-left + padding-right) + border-top + border-bottom布局所占高度Height:Height = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box 布局所占宽度Width：Width = width(包含padding-left + padding-right + border-left + border-right)布局所占高度Height:Height = height(包含padding-top + padding-bottom + border-top + border-bottom) margin叠加 外边距叠加是一个相当简单的概念。 但是，在实践中对网页进行布局时， 它会造成许多混淆。 简单的说， 当两个或更多个垂直边距相遇时， 它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。但是注意只有普通文档流中块框的垂直外边距才会发生外边距叠加。 行内框、 浮动框或绝对定位框之间的外边距不会叠加。一般来说， 垂直外边距叠加有三种情况： 元素自身叠加 当元素没有内容（即空元素）、内边距、边框时， 它的上下边距就相遇了， 即会产生叠加（垂直方向）。 当为元素添加内容、 内边距、 边框任何一项， 就会取消叠加。 相邻元素叠加 相邻的两个元素， 如果它们的上下边距相遇，即会产生叠加。 包含（父子）元素叠加 包含元素的外边距隔着 父元素的内边距和边框， 当这两项都不存在的时候， 父子元素垂直外边距相邻， 产生叠加。 添加任何一项即会取消叠加。 CSS 普通流（文档流）什么是普通流？简单说就是元素按照其在 HTML 中的位置顺序决定排布的过程。并且这种过程遵循标准的描述。 一般使用margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。margin用于布局分开元素使元素与元素互不相干；padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段“距离”。只要不是float和绝对定位方式布局的，都在普通流里面。 CSS 定位方式display 属性每一个元素都有默认的display属性，使用最多的是 block,inline 和 inline-block，不常用的是 table-cell。根据 display 属性，我们可以将元素分为块级元素(block)和内联级元素(inline)。它们最大区别是:block元素可以设置宽度，独占一行。inline元素宽度由内容决定，与其他元素并列在一行。常见的block属性元素有：div, h1-h6, ul, li, ol, dl, dd, dt。常见的inline属性元素有:span, a, em。 block 宽高可以自行设置，默认宽度由父容器决定，默认高度由内容决定，自己独占一行。 inline 宽度和高度都由内容决定，与其他元素共占一行 inline-block 宽度可以自行设置，类似block，但是与其他元素共占一行，类似inline。长用于设置垂直居中。 table-cell 此属性指让标签元素以表格单元格的形式呈现，单元格有一些比较特殊的属性，可以设置元素的垂直居中等。 position 属性元素在页面中的布局遵守一套文档流的方式，默认的定位属性值为static。它其实是未被设置定位的。元素如果被定位了，那么它的top,left,bottom,right值就会生效，能设置定位的属性是relative,absolute和fixed。需要注意的另一点是被定位的元素层次(z-index)会得到提高。 relative（相对定位） 设置了相对定位之后，通过修改top,left,bottom,right值，元素会在自身文档流所在位置上被移动，其他的元素则不会调整位置来弥补它偏离后剩下的空隙。 absolute（绝对定位） 设置了绝对定位之后，元素脱离文档流，其他的元素会调整位置来弥补它偏离后剩下的空隙。元素偏移是相对于离它最近的设置了定位属性（position值不为static）的元素。且如果元素为块级元素（display属性值为block)，那么它的宽度也会由内容撑开。因为：默认文档流中块级元素如果没有设置宽度属性，会自动填满整行。 fixed(固定定位) 设置了固定定位之后，元素相对的偏移的参考是可视窗口，即使页面滚动，元素仍然会在固定位置。 CSS 相对|绝对(relative/absolute)定位系列 CSS 浮动相关这也是CSS定位机制的一种。首先了解两个概念： 文档流：文档流是文档中可显示对象在排列时所占用的位置。 浮动的定义：使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。浮动的实际用途，可设置文字环绕或使元素宽度由内容填充（类似Inline-block)。使用浮动需要注意的是如果浮动的元素高度比父级容器还高，那么需要设置父级容器的overflow属性为auto,使其自动撑满。 CSS 浮动 CSS 选择器选择器是匹配元素的一种模式，不只是在CSS中，JavaScript对CSS的选择器也是支持的，比如document.document.querySelectorAll。 CSS 解析器HTML 经过解析生成 DOM Tree（这个我们比较熟悉）；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。 解析顺序CSS匹配不是从左到右进行查找，而是从右到左进行查找。如果从左到右的顺序，那么每条选择器都需要遍历整个DOM树，性能很受影响。所谓高效的CSS就是让浏览器在查找style匹配的元素的时候尽量进行少的查找, 所以选择器最好写的简洁一点。 选择器权重权重，也就是选择器的优先级，每条选择器的规则都有其权重，权重大的会覆盖掉权重小的，很多CSS出现问题的场景，都是某处定义了一个更高权重的规则，导致此处规则不生效。根据样式所在位置，对元素的影响也有关系：内联样式（标签内style形式） &gt; style标签 &gt; link标签。另外一点需要注意的是!improtant,凡是属性值后加上了!important，那么它的值不会被其他值替换。 权重的计算 主要的规则就是:id选择器 &gt; 类，属性选择器和伪类选择器 &gt; 元素和伪元素 基本选择器 通配符选择器（＊） id选择器（#ID） 类选择器（.className） 元素选择器(E) 后代选择器（Ｅ Ｆ） 子元素选择器(E&gt;F) 相邻兄弟元素选择器(E + F) 群组选择器（selector1,selector2,…,selectorN） 属性选择器使用CSS3属性选择器，你可以只指定元素的某个属性，或者你还可以同时指定元素的某个属性和其对应的属性值。 E[attr]：只使用属性名，但没有确定任何属性值 E[attr=“value”]：指定属性名，并指定了该属性的属性值 E[attr~=“value”]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的“〜”不能不写 E[attr^=“value”]：指定了属性名，并且有属性值，属性值是以value开头的； E[attr$=“value”]：指定了属性名，并且有属性值，而且属性值是以value结束的； E[attr*=“value”]：指定了属性名，并且有属性值，而且属值中包含了value； E[attr|=“value”]：指定了属性名，并且属性值是value或者以“value-”开头的值（比如说zh-cn）; 伪类选择器伪类选择器的形式就是:xxx， 比如:hover, :link, :nth。 动态伪类这些伪类并不存在于HTML中,而只有当用户和网站交互的时候才能体现出来，动态伪类包含两种，第一种是我们在链接中常看到的锚点伪类，如”:link”,”:visited”;另外一种被称作用户行为伪类，如“:hover”,”:active”和”:focus”。先来看最常见的锚点伪类。 hover: 用于当用户把鼠标移动到元素上面时的效果 active: 用于用户点击元素那一下的效果（正发生在点的那一下，松开鼠标左键此动作也就完成了） focus: 用于元素成为焦点，这个经常用在表单元素上 UI元素状态伪类 主要是针对于HTML中的Form元素操作，IE8 不支持 :checked, :enabled, :disabed 这三种选择器。 CSS3的:nth选择器主要注意的是CSS3添加的nth选择器在IE8下不支持。 fist-child: 选择某个元素的第一个子元素； last-child: 选择某个元素的最后一个子元素； nth-child(): 选择某个元素的一个或多个特定的子元素； 其他： 常用的就是上面三种了，其他自行了解。 CSS 布局 固定尺寸布局可以从固定尺寸先了解，先构思好页面的主要结构，做动画的元素一般需要绝对定位，方便操作移动。 自适应布局响应式的布局的结构其实就是多个固定尺寸的组合，元素的宽度，字体的大小一般会以半分比的形式设置。通过媒体查询进行不同分辨率下的布局。 如何只用CSS做到完全居中 - 文章 - 伯乐在线 Metameta 标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键字），或其他 web 服务。 BEMBEM (Block, Element, Modifier) 是一种基于组件的对 CSS 类名进行约定的 Web 开发方法。他通过定义命名空间来解决权重问题，从而使 CSS 更易于维护。BEM 使用 Block、Element、Modifier 来解释其结构。Block 是一个可跨项目重用的独立组件，且是子组件（Element）的“命名空间”。Modifier 可标示 Block 或 Element 处于某种状态、结构或特定的样式。 -中划线 ：仅作为连字符使用，表示多个单词之间的连接记号 __双下划线：用来连接 Block 和 Element —双中划线：描述 Block 或 Element 的一种状态、结构或样式 1234567891011121314/* block component */.block-name &#123;&#125;/* element */.block-name__element-name &#123;&#125;/* modifier */.block-name__element-name--modifier-name &#123;&#125; &lt;nav class="navbar"&gt; &lt;a href="/" class="navbar__link navbar__link--active"&gt;&lt;/a&gt; &lt;a href="/" class="navbar__link"&gt;&lt;/a&gt;&lt;/nav&gt; 在示例中，navbar 为 Block，navbar__link 是一个不能独立与navbar 存在的 Element，navbar__link--active是标明navbar__link 不同状态的 Modifier。 BEM 实践中也有使用_替代—的情况 类命名需要尽可能的简明清晰、没有二意性，例如error就比red-text更加有语义。 建议 Block 只能有一层 Element 嵌套，且 Element 不能独立 Block 存在。如： 123456789&lt;form class="search-form"&gt; &lt;div class="search-form__content"&gt; &lt;input class="search-form__input"&gt; &lt;!-- 错误：建议使用 `search-form__button` 或 `search-form__content-button` --&gt; &lt;button class="search-form__content__button"&gt;Search&lt;/button&gt; &lt;/div&gt;&lt;/form&gt;&lt;!-- 错误：该 Element 应放在 `search-form` Block 中 --&gt;&lt;i class="search-form__icon"&gt;&lt;/i&gt; 建议同一个 Block 或 Element 上不能使用两个以上的 Modifier 去进行修饰，且 Modifier 需配合 Block 或 Element 使用，不能独立存在。如： 123456&lt;!-- 错误：缺少 `search-form` Block --&gt;&lt;form class="search-form_theme_islands"&gt;&lt;/form&gt;&lt;!-- 错误：使用多个 Modifier --&gt;&lt;form class="search-form search-form_theme_islands search-form_theme_lite"&gt;&lt;/form&gt; 那些你不知道的属性margin padding border 这些如果同时设置四个方向上的值的话，顺序应当是顺时针的。 TBD… Reference前端工程师手册 · GitBook (Legacy)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络体系结构]]></title>
    <url>%2F2019%2F03%2F18%2Farc-02%2F</url>
    <content type="text"><![CDATA[计算机网络体系结构1.1 简介 定义 计算机网络的各层 + 协议的集合 作用 定义该计算机网络的所能完成的所有功能 1.2 结构介绍一般分为三种： OSI 体系结构：概念清楚，理念完整，但是复杂，不实用。 TCP / IP 体系结构：包含一系列构成互联网基础的网络协议，是 Internet 的核心协议，被广泛应用于局域网和广域网。 五层体系结构：融合了 OSI 与 TCP/ IP 的体系结构，目的是学习和讲解计算机原理。 ::低三层为通信子网，负责数据传输。::::高三层为资源子网，相当于计算机系统，完成数据处理。::::传输层承上启下:: TCP / IP 的体系结构详细介绍 OSI 的体系结构详细介绍 TCP 协议Transmission Control Protocol 即传输控制协议。 属于传输层通信协议基于 TCP 的应用层协议有 HTTP, SMTP, FTP, Telenet, POP3 UDP 协议3.1 定义User Datagram Protocol 即用户数据报协议 属于传输层通信协议基于 UDP 的应用层协议有 TFTp, SNMP 与 DNS 3.2 特点无连接的，不可靠的，面向报文，无拥塞控制，具体介绍如下： 3.3 优缺点 优点：速度快 缺点：消息易丢失（特别是网络较差的时候） 3.4 应用场景（对应应用层协议）要求通信速度高 如：域名转换：DNS 协议文件传输：FTP 协议网络管理：SNMP 协议远程文件服务器：NFS 协议 3.5 报文段格式 UDP 报文段共有两个字段：数据字段和首部字段 主要介绍首部（8字节，4个字段） 3.6 TCP 和 UDP 的区别 4. HTTP 协议4.1 简介 5. Socket5.1 简介即套接字，是应用层与 TCP / IP 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP 协议族的编程接口 API Socket 不是一种协议，而是一个编程调用接口（API)，属于传输层（主要解决数据如何在网络中传输） 在 Android 平台，我们只能通过 Socket 才能使用 TCP / IP 协议进行开发 对用户来说，只需要调用 Socket 去组织数据，以符合制定的协议，即可通信。 成对出现，一对套接字： 1Socket = &#123;(IP 地址1: PORT 端口号), （IP 地址 2: PORT 端口号）&#125; 一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路。 5.2 其他知识关于 Socket 的原理、机制过程和使用方式：Android：这是一份很详细的Socket使用攻略 - 简书 6. 其他知识6.1 在浏览器中输入 url 地址 -&gt; 显示主页的过程 打开一个网页整个过程中会使用哪些协议 6.2 IP 地址定义链接在 Internet 中的每一台主机（路由器）的全球唯一的标识符 组成IP 地址 = 32 位 = 网络号 + 主机号；即 IP 地址 = {&lt;网络号&gt;, &lt;主机号&gt;} 其中： 网络号：标志主机（路由器）所链接到的网络，一个网络号在整个因特网范围内必须是唯一的。 主机号：标志该主机（路由器）。一个主机号在它面前的网络号所指明的网络范围内必须是唯一的。 不同类型的 IP 地址，其主机号 &amp; 网络号所占字节数不同；故：一个 IP 地址在整个网络范围内是唯一的。 分类传统的 IP 地址是分类的地址，分为 A, B, C, D, E 五类区别在于网络号 &amp; 主机号所占的字节数不同。 ::在各类 IP 地址中，有一些 IP 地址用于特殊用途，不能用做主机 IP 地址:: 6.3 ICMP 协议定义Internet Control Message Protocol 国际控制报文协议 属于 IP 层协议 ICMP 报文不是高层协议，而是作为 IP 层数据报的数据，加上数据报首部，组成 IP 数据报发出去。 作用更有效的转发 IP 数据包 &amp; 提高交付成功的机会同时允许主机 / 路由器报告差错 &amp; 异常情况 分类ICMP 差错报告报文 &amp; ICMP 询问报文 主要应用PING （分组网间探测）、Traceroute （跟踪一个分组从源点到终点的路径，原理 = 从源主机向目的主机发送一连串的 IP 数据报）主要介绍 Ping 的过程 6.4 Ping 的过程定义Packet InterNet Groper 分组网间探测 是 ICMP 报文的一个重要应用：使用了 ICMP 回送请求 &amp; 回送回答报文 是应用层直接使用网络层 ICMP 的一个例子，无需经过传输层的 TCP, UDP 作用测试两个主机的联通性 原理 向目的主机发送多个 ICMP 回送请求报文 根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间 最终的显示结果：发送到目的主机的 IP 地址、发送 &amp; 收到 &amp; 丢失的分组数、往返时间的最小 &amp; 最大 &amp; 平均值 过程假设有两台主机：（目的主机） PC1：IP = 192.168.1.1（源主机） PC2：IP = 192.168.1.2 6.5 路由器与交换机的区别 6.6 Cookie 与 Session 6.7 Cookie 与 Token 基于 Cookie 的身份验证 &amp; 验证流程 基于 Token 的身份验证 &amp; 验证流程 Reference这是一份详细 &amp; 清晰的计算机网络基础 学习指南 - 简书]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于算法的 Swift 学习之路（排序）]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%9F%BA%E4%BA%8E%E7%AE%97%E6%B3%95%E7%9A%84%20Swift%20%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[排序这里给出了六大排序的 Swift 语言实现，大部分代码是基于算法4th 的 JAVA 实现直接实现的，也有充分利用 Swift 语言特性的更为简洁的实现。代码中涉及到的 Swift 特性，我选择用算法这样一种实际应用情况来为大家阐述，更为易懂和实用。 选择排序123456789101112131415161718func selectionSort&lt;T: Comparable&gt;(_ array: [T]) -&gt; [T] &#123; var a = array let N = a.count var count = 0 for i in 0..&lt;N &#123; var min = i for j in (i + 1)..&lt;N &#123; if a[j] &lt; a[min] &#123; min = j count += 1 &#125; &#125; // Array 库函数，交换两个元素 a.swapAt(i, min) &#125; print("selectionSort cost \(count)") return a&#125; 最简单的排序方式，不断选择最小的元素移到第一个元素，因此是个稳定的算法，这里我们要强调的有两个，第一个就是我们在下面经常用到的 Array.swapAt(_ : Int, _ : Int) ，Swift 直接为我们封装好了交换数组两个元素的方法，简单而高效。接下来要说的就是 Swift 中的泛型，我们在这里为方法定义了一个泛型 T 并且要求这个泛型要实现 Comparable 协议，这于算四里直接使用 JAVA 中的 Comparable 超类差不多，但是泛型就意味着我们需要在调用这个方法的时候明确指出这个泛型的真正类型，这种问题常常并不会出现在函数泛型的使用中，因为我们既然为函数声明了泛型，就一定会为其传入相应的参数，Swift 会通过参数自动推断出该泛型。但是我们要知道，同样的泛型声明方法也是可以在类身上的，我们在 JAVA 中为一个泛型类声明的时候要明显的给出实际类型，但是在 Swift 中，我们除了这样显示给出泛型外，如果我们的构造方法里传入了该类型的参数，那么我们就无需再重复声明泛型，Swift 会帮我们推断出该泛型，同时对于这个对象本身，该泛型已经确定，不能再更改了，否则会出现一个类中两个泛型的困扰。关于 Comparable 协议，任何遵循了该协议的变量都自动拥有该协议中包含的几个方法 &lt; &gt; &lt;= &gt;= 等，也就跟其字面意思相同，这是一个可以比较的变量。同样的协议还有 Equalable ，其包含的方法是 == != ` 插入排序（冒泡排序）1234567891011121314func insertionSort&lt;T&gt;(_ array: [T], _ isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T] &#123; var a = array var count = 0 for x in 1..&lt;a.count &#123; var y = x while y &gt; 0 &amp;&amp; isOrderedBefore(a[y], a[y - 1]) &#123; a.swapAt(y - 1, y) count += 1 y -= 1 &#125; &#125; print("insert cost \(count)") return a&#125; 插入排序，很多高级排序的基础，也是对于小型数组排序最快的排序方法。对于有序数组也有着很高的排序效率 这里涉及的 Swift 特性在于那个特别长的参数，也就是那个函数参数。我们知道在 Swift 中，函数是一等类型，可以作为返回值和参数直接使用。这一次我们的泛型并没有直接实现 Comparable 协议，而是用了一个函数直接将操作符 &gt; &lt; 直接当作参数传入，因此可以通过参数来控制递增排序和递减排序，关于 Swift 中的操作符，实际上也是一个函数，我们也可以通过重载为其增加更多的方法。 希尔排序12345678910111213141516171819202122232425func shellSort&lt;T&gt; (_ array: [T], _ isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T] &#123; var a = array let N = a.count var h = 1 var count = 0 // 递增序列 while h &lt; N / 3 &#123; h = 3 * h + 1 &#125; while h &gt;= 1 &#123; for i in h..&lt;N &#123; var j = i while j &gt;= h &amp;&amp; isOrderedBefore(a[j], a[j-h]) &#123; a.swapAt(j, j-h) count += 1 //print(a) j -= h &#125; &#125; h = h / 3 &#125; print("shell cost \(count)") return a&#125; 插入排序的优化版，通过递增序列使其性能大大提升。 归并排序这也是个稳定的排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123class Merge&lt;T: Comparable&gt; &#123; var aux = [T]() var data = [T]() init(_ array: [T]) &#123; data = array self.mergeSort(&amp;data, lo: 0, hi: data.count - 1) &#125; // 使用 inout 来操作实际参数 func merge(_ array: inout [T], _ lo: Int, _ mid: Int, _ hi: Int)&#123; var i = lo var j = mid + 1 aux = array for k in lo...hi &#123; if i &gt; mid &#123; array[k] = aux[j] j += 1 &#125; else if j &gt; hi &#123; array[k] = aux[i] i += 1 &#125; else if aux[j] &lt; aux[i] &#123; array[k] = aux[j] j += 1 &#125; else &#123; array[k] = aux[i] i += 1 &#125; &#125; &#125; // merge high to low func mergeSort(_ array: inout [T], lo: Int, hi: Int)&#123; if hi &lt;= lo &#123; return &#125; let mid = lo + (hi - lo) / 2 mergeSort(&amp;array, lo: lo, hi: mid) mergeSort(&amp;array, lo: mid + 1, hi: hi) merge(&amp;array, lo, mid, hi) &#125; // merge low to high func mergeBU(_ array: [T]) -&gt; [T] &#123; var a = array let N = a.count // 归并子数组大小 var sz = 1 while sz &lt; N &#123; var lo = 0 while lo &lt; N - sz &#123; // 用 N - 1 防止数组越界 merge(&amp;a, lo, lo+sz-1, min(lo+sz+sz-1, N-1)) // 参与归并的数组大小是子数组的两倍 lo += sz + sz &#125; sz = sz + sz &#125; return a &#125; // 不操作原数组的方式 func merge(leftPile: [T], rightPile: [T]) -&gt; [T] &#123; // 1 var leftIndex = 0 var rightIndex = 0 // 2 var orderedPile = [T]() // 为数组申请备用容量，减少长度动态变化的开销 orderedPile.reserveCapacity(leftPile.count + rightPile.count) // 3 // 两个归并的数组有一个用完就会停止判断 while leftIndex &lt; leftPile.count &amp;&amp; rightIndex &lt; rightPile.count &#123; if leftPile[leftIndex] &lt; rightPile[rightIndex] &#123; orderedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; else if leftPile[leftIndex] &gt; rightPile[rightIndex] &#123; orderedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; else &#123; // 如果一样大，各放入归并的数组一次 orderedPile.append(leftPile[leftIndex]) leftIndex += 1 orderedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; &#125; // 4 // 右侧数组用完 while leftIndex &lt; leftPile.count &#123; orderedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; // 左侧数组用完 while rightIndex &lt; rightPile.count &#123; orderedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; return orderedPile &#125; func mergeSort(_ array: [T]) -&gt; [T] &#123; // guard 更关注的是 else guard array.count &gt; 1 else &#123; return array &#125; // 1 let middleIndex = array.count / 2 // 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) // 3 let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) // 4 return merge(leftPile: leftArray, rightPile: rightArray) // 5 &#125;&#125; 涉及到的 Swift 特性： Array.reserveCapacity inout 和 &amp; subsequence 在归并排序中，我们在知道需要的额外数组长度的情况下使用了 reserveCapacity 这个方法来为数组增加备用容量，我们都知道 Swift 中的数组跟 js python 相同，都是动态数组，多数情况下我们是不需要关心数组大小的，但是通过这种事前为数组增加容量的方式可以让我们在需要大量 append 操作的时候减少系统消耗。 inout 和 &amp; ，Swift 与 JAVA 不同，对于对象类参数的处理是直接修改其原对象信息。Swift 仍然继承了 C 的基础，对象型参数会复制一份到函数中，同时，这个变量是个 let 型，也就是说我们并不能直接操作这个变量，对这个变量的操作就更不可能影响到函数外。这是 Swift 为了贯彻其安全的理念的措施。那么对于需要直接更改实际变量的操作呢，我们就要用到 inout 和 &amp; 这一对操作符，有一点像 C 中的指针，带有 inout 的参数才能被直接访问和修改。 subsequence ，在最后的方法中我们直接使用区间运算作为数组的下标来访问同一个数组的前后两部分，但是我们要注意的是，这样得到的实际上并非是个数组，而是个遵守了 subsequence 的类型，而数组，他实现的是 sequence 协议，这两个还不太一样，因此我们在传入参数的时候将其进行了类型转换。 快速排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138class Quick&lt;T: Comparable&gt; &#123; var data: [T] init(_ array: [T]) &#123; self.data = array // 打乱一个数组 shuffle, shuffled // https://developer.apple.com/documentation/swift/array/2994757-shuffled data.shuffle() //sort(&amp;data, lo: 0, hi: data.count - 1) //quick3Sort(&amp;data, lo: 0, hi: data.count - 1) data = quicksort(data) &#125; // 最经典的切分方式，取第一个元素作为基准 func sort(_ array: inout [T], lo: Int, hi: Int) &#123; if hi &lt;= lo &#123; return &#125; let j = partition(&amp;array, lo: lo, hi: hi) sort(&amp;array, lo: lo, hi: j - 1) sort(&amp;array, lo: j + 1, hi: hi) &#125; // 手写 partition 实际上可以使用高级操作符 filter 来直接完成切分 func partition(_ array: inout [T], lo: Int, hi: Int) -&gt; Int &#123; var i = lo var j = hi + 1 let v = array[lo] while true &#123; i += 1 while array[i] &gt; v &#123; if i == hi &#123; break &#125; i += 1 &#125; j -= 1 while v &gt; array[j] &#123; if j == lo &#123; break &#125; j -= 1 &#125; if i &gt;= j &#123; break &#125; array.swapAt(i, j) &#125; array.swapAt(lo, j) return j &#125; // 更简洁的写法 func quicksortHoare(_ a: inout [T], low: Int, high: Int) &#123; if low &lt; high &#123; let p = partitionHoare(&amp;a, low: low, high: high) quicksortHoare(&amp;a, low: low, high: p) quicksortHoare(&amp;a, low: p + 1, high: high) &#125; &#125; func partitionHoare(_ a: inout [T], low: Int, high: Int) -&gt; Int &#123; let pivot = a[low] var i = low - 1 var j = high + 1 while true &#123; repeat &#123; j -= 1 &#125; while a[j] &gt; pivot repeat &#123; i += 1 &#125; while a[i] &lt; pivot if i &lt; j &#123; a.swapAt(i, j) &#125; else &#123; return j &#125; &#125; &#125; // 三向切分 func quick3Sort(_ array: inout [T], lo: Int, hi: Int) &#123; if hi &lt;= lo &#123; return &#125; var lt = lo, i = lo + 1, gt = hi let v = array[lo] while i &lt;= gt &#123; if array[i] &lt; v &#123; array.swapAt(lt, i) lt += 1 i += 1 &#125; else if v &lt; array[i] &#123; array.swapAt(i, gt) gt -= 1 &#125; else &#123; i += 1 &#125; &#125; quick3Sort(&amp;array, lo: lo, hi: lt - 1) quick3Sort(&amp;array, lo: gt + 1, hi: hi) &#125; // 三项切分，利用高级函数，效率并不太高 func quicksort&lt;T: Comparable&gt;(_ a: [T]) -&gt; [T] &#123; guard a.count &gt; 1 else &#123; return a &#125; //let pivot = a[a.count/2] let pivot = a[0] let less = a.filter &#123; $0 &lt; pivot &#125; let equal = a.filter &#123; $0 == pivot &#125; let greater = a.filter &#123; $0 &gt; pivot &#125; return quicksort(less) + equal + quicksort(greater) &#125; // 三向切分，取最后一个元素作为基准 func partitionLomuto&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) -&gt; Int &#123; let pivot = a[high] var i = low for j in low..&lt;high &#123; if a[j] &lt;= pivot &#123; (a[i], a[j]) = (a[j], a[i]) i += 1 &#125; &#125; (a[i], a[high]) = (a[high], a[i]) return i &#125; func quicksortLomuto&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) &#123; if low &lt; high &#123; let p = partitionLomuto(&amp;a, low: low, high: high) quicksortLomuto(&amp;a, low: low, high: p - 1) quicksortLomuto(&amp;a, low: p + 1, high: high) &#125; &#125; &#125; 天下第一的快排 涉及到的 Swift 特性：有几个数组高级操作： shuffle() filter shuffle 和 shuffled ，求求你们不要再🦐几把手写那些鬼随机打乱算法了，人家写的好好的，一个直接操作数组，一个返回打乱后的数组。 filter 这是个 Swift 4.2+ 增加的新方法，用于直接选出数组中符合某一类条件的元素，返回值是个数组，用在快排里简直爽到飞起，但是应该是现在的 oj 都还不支持这个函数，这个方法和 reduce ， map 都可能是面试中的重点。 堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 堆和优先队列class Heap&lt;T: Comparable&gt; &#123; var data = [T]() var N = 0 init(size: Int) &#123; data.reserveCapacity(size + 1) &#125; func insert(new: T) &#123; N += 1 data.append(new) swim(N) &#125; // 大元素上浮 func swim(_ k: Int) &#123; var k = k while k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] &#123; // 大节点不断上浮 data.swapAt(k/2, k) k = k / 2 &#125; &#125; // 小元素下沉 func sink(_ k: Int) &#123; var k = k while 2*k &lt;= N &#123; var j = 2 * k if j &lt; N &amp;&amp; data[j] &lt; data[j+1] &#123; // 左节点是较小的节点,选择右节点作为新的根结点 j += 1 &#125; // 如果当前 k 号节点小于其父节点，下沉 guard data[k] &lt; data[j] else &#123; break &#125; data.swapAt(k, j) k = j &#125; &#125; func delMax() -&gt; T &#123; data.swapAt(1, N) let max = data.remove(at: N) N -= 1 sink(1) return max &#125;&#125;class heapSort &#123; func sort(_ array: inout [Int]) &#123; var N = array.count - 1 for k in stride(from: N/2, through: 1, by: -1) &#123; sink(&amp;array, k, N) &#125; while N &gt; 1 &#123; array.swapAt(1, N) N -= 1 sink(&amp;array, 1, N) &#125; &#125; // 大元素上浮 func swim(_ data: inout [Int], _ k: Int, _ N: Int) &#123; var k = k while k &gt; 1 &amp;&amp; data[k/2] &lt; data[k] &#123; // 大节点不断上浮 data.swapAt(k/2, k) k = k / 2 &#125; &#125; // 小元素下沉 func sink(_ data: inout [Int], _ k: Int, _ N: Int) &#123; var k = k while 2*k &lt;= N &#123; var j = 2 * k if j &lt; N &amp;&amp; data[j] &lt; data[j+1] &#123; // 左节点是较小的节点,选择右节点作为新的根结点 j += 1 &#125; // 如果当前 k 号节点小于其父节点，下沉 guard data[k] &lt; data[j] else &#123; break &#125; data.swapAt(k, j) k = j &#125; &#125;&#125; 堆排序没啥的，基本都说完了。需要注意的就是这里的 for 循环和 python 的相同，不能带什么操作，同时倒序的话，可以用 reserve 或者是 stride 将步长设定为 -1。 Reference总结 Swift 中随机数的使用 - CocoaChina 苹果开发中文站 - 最热的iPhone开发社区 最热的苹果开发社区 最热的iPad开发社区]]></content>
      <categories>
        <category>iOS &amp; Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何速成前端三件套 （HTML）]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%A6%82%E4%BD%95%E9%80%9F%E6%88%90%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97%20%EF%BC%88HTML%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HTML那些你不知道的标签&lt;body bgcolor=&quot;yellow&quot;&gt; 背景颜色用 bgcolor &lt;a href=“mailto:xxx@yyy”&gt; 发邮件用 mailto &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt; 新窗口用 _blank &lt;td align=&quot;left&quot;&gt; 单元格对其用 align &lt;select&gt; &lt;textarea&gt; 这个不用 input &lt;body background=&quot;background.gif&quot;&gt; 背景图片用 background &lt;hr /&gt; 水平分割线用 hr 浏览器会自动地在段落的前后添加空行。（&lt;p&gt;是块级元素） 应该避免使用下面这些标签和属性：&lt;center&gt; 定义居中的内容。&lt;font&gt; 和 &lt;basefont&gt; 定义 HTML 字体。&lt;s&gt; 和 &lt;strike&gt; 定义删除线文本&lt;u&gt; 定义下划线文本align 定义文本的对齐方式bgcolor 定义背景颜色color 定义文本颜色 style=“text-align:center” 这样居中最帅 &lt;sub&gt; &amp; &lt; sup&gt; 文字下标和上标 &lt;bdo dir=&quot;rtl&quot;&gt; Here is some Hebrew text &lt;/bdo&gt; 倒序输出文本 12345678&lt;blockquote&gt;这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。这是长的引用。&lt;/blockquote&gt;这是短的引用：&lt;q&gt;这是短的引用。&lt;/q&gt; &lt;abbr&gt; 有下划线， &lt;dfn&gt; 是斜体 ::&lt;img&gt; 的 title 是鼠标悬浮显示的文字 , alt 是图片出不来的时候显示的文字:: 1234这是邮件链接：&lt;a href="mailto:someone@microsoft.com?subject=Hello%20again"&gt;发送邮件&lt;/a&gt;&lt;/p&gt;&lt;a href="mailto:someone@microsoft.com?cc=someoneelse@microsoft.com&amp;bcc=andsomeoneelse2@microsoft.com&amp;subject=Summer%20Party&amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!"&gt;发送邮件！&lt;/a&gt; 使用 %20 来代替单词之间的空格 &lt;tr&gt; 来换行 &lt;td&gt; 来定义一个单元格 在 &lt;th&gt; 中使用 colspan 或 rowspan 来跨越列或行 如何应付老式的浏览器如果浏览器压根没法识别&lt;script&gt; 标签，那么 &lt;script&gt;标签所包含的内容将以文本方式显示在页面上。为了避免这种情况发生，你应该将脚本隐藏在注释标签当中。那些老的浏览器（无法识别 &lt;script&gt;标签的浏览器）将忽略这些注释，所以不会将标签的内容显示到页面上。而那些新的浏览器将读懂这些脚本并执行它们，即使代码被嵌套在注释标签内。 12345&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--document.write(&quot;Hello World!&quot;)//--&gt;&lt;/script&gt; URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。URL 不能包含空格。URL 编码通常使用 + 来替换空格。 提示：仅仅有 16 种颜色名被 W3C 的 HTML4.0 标准所支持。它们是：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow。 HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 &lt;!DOCTYPE&gt; 的用处。&lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。 &lt;!DOCTYPE html&gt; 是 HTML5 的声明 在 &lt;input&gt; 中使用 readonly 来规定输入字段为只读 等同于 readonly=&quot;readonly&quot; disabled属性规定输入字段是禁用的。被禁用的元素是不可用和不可点击的。被禁用的元素不会被提交。 语义元素清楚地向浏览器和开发者描述其意义。非语义元素的例子：&lt;div&gt; 和 &lt;span&gt; - 无法提供关于其内容的信息。语义元素的例子：&lt;form&gt;、&lt;table&gt; 以及 &lt;img&gt; - 清晰地定义其内容。 那些你必须要知道的东西 GET 和 POST 的区别 大多数 web 服务器（Apache、Unix）对文件名的大小写敏感：不能以 london.jpg 访问 London.jpg。其他 web 服务器（微软，IIS）对大小写不敏感：能够以 london.jpg 或 London.jpg 访问 London.jpg。如果使用混合大小写，那么您必须保持高度的一致性。如果您从对大小写不敏感的服务器转到一台对大小写敏感的服务器上，这些小错误将破坏您的网站。为了避免这些问题，请始终使用小写文件名（如果可以的话）。 HTML5HTML5 新元素 HTML5 增加了如下表单元素： datalist keygen output Internet Explorer 的问题上述方案可用于所有新的 HTML5 元素，但是：注意：Internet Explorer 8 以及更早的版本，不允许对未知元素添加样式。幸运的是，Sjoerd Visscher 创造了 “HTML5 Enabling JavaScript”,”the shiv”： 123&lt;!--[if lt IE 9]&gt; &lt;script src=&quot;http://html5shiv.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 这段注释会被 IE 9 以下的浏览器理解，并通过这个脚本文件理解 HTML5 里面新增的标记。 Canvas and SVG SVG 是一种使用 XML 描述 2D 图形的语言。SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas 通过 JavaScript 来绘制 2D 图形。Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 Canvas依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试准备]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[基础语言和核心原理 html5 + css3 javascript DOM AJAX MVVM 框架 React Vue.js ReactNative]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>front_end</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 面试准备]]></title>
    <url>%2F2019%2F03%2F16%2FiOS%20%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[基础 可选项和可选链 字符串 闭包 (循环引用) weak GCD runtime UIControler 语言和核心原理 Socket TCP / IP xcode 和各种工具 Carthage cocoapods Swift package manger ReactNative cocoa 框架 项目 pixel app echo app Algorithm ReferenceBeijingIamback - 简书]]></content>
      <categories>
        <category>Internship</category>
      </categories>
      <tags>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于算法的 Swift 学习之路（cocoapod 和 Carthage）]]></title>
    <url>%2F2019%2F03%2F14%2Farc-01%2F</url>
    <content type="text"><![CDATA[为啥要用包管理工具我们在开发过程中会用到（依赖于）其他第三方库，这些库或框架还有可能依赖于其他库或者框架，手动管理这些库或者框架非常麻烦，首先我们需要下载这些库或者框架，然后还要考虑版本兼容性问题，需要手动导入一些依赖包(ps:想想就够了)，还好有CocoaPods和Carthage工具管理项目依赖关系。 CocoaPodsCocoaPods支持项目中采用Objective-C或swift语言。::CocoaPods会将第三方库的源代码编译为静态库.a文件或者静态框架.framework文件的形式，并将它们添加到项目中，建立依赖关系。:: 更换 Ruby 源123456gem sources -l (查看当前ruby的源)gem sources --add https://gems.ruby-china.org/ gem sources --remove https://rubygems.org/ gem sources -lsudo gem install cocoapodspod set 基本使用pod init 来新建 podfile 编辑项目路径下的 Podfile ，可以通过官网检索依赖包或者使用 pod search 命令。cocoapods 是中心化的包管理工具，因此有些没有收录在 cocoapods 中的依赖将不能从中心库直接引入（如 GitHub 上的部分开源项目），对于这种依赖，我们可以通过手动标注原链接的方式引入： pod ‘PNChartSwift’,:git =&gt; &#39;git url&#39; 注意事项123~&gt;3.0 表示大于等于3.0版本，小于下一个主版本，即4.0版本&gt;=3.0 表示大于等于3.0版本==3.0 表示等于3.0版本 Podfile本质上是用来描述Xcode工程中的targets用的。如果我们不显式指定Podfile对应的target，CocoaPods会创建一个名称为default的隐式target，会和我们工程中的第一个target相对应。换句话说，如果在Podfile中没有指定target，那么只有工程里的第一个target能够使用Podfile中描述的Pods依赖库。 如果想在一个Podfile中同时描述project中的多个target，根据需求的不同，可以有不同的实现方式。现在的project中包含的target有：CocoapodsTest、CocoapodsTestTests、CocoapodsTestUITests。 如果引入依赖的时候不显示标示依赖库版本，表示每次都获取最新版本 移除或修改库后，执行pod update 来让更改生效 Podfile.lock 文件执行完pod install之后，会生成一个Podfile.lock文件，该文件用于保存已经安装的Pods依赖库的版本。 Podfile.lock文件最大得用处在于多人开发。对于没有在Podfile中指定Pods依赖库版本的写法，如下：pod ‘Reachability’该句话用于获取当前Reachability这个Pods依赖库的最新版本。当团队中的某个人执行完pod install命令后，生成的Podfile.lock文件就记录下了当时最新Pods依赖库的版本，这时团队中的其它人check下来这份包含 Podfile.lock文件的工程以后，再去执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，后续所有用户执行pod install命令都会获取最新版本的Reachability，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作来说绝对是个灾难！在这种情况下，如果团队想使用当前最新版本的SBJson依赖库，有两种方案： 更改Podfile，使其指向最新版本的Reachability依赖库； 执行pod update命令；鉴于Podfile.lock文件对团队协作如此重要，我们建议将它添加到版本管理中。 CarthageCocoaPods已经是一个非常棒的工具了，我们还有另外一个选择——Carthage,它是一个轻量级的项目依赖管理工具。Carthage主张“::去中心化::”和“::非侵入性::”。CocoaPods搭建了一个中心库，第三方库被收入到该中心库，所以没有收录的第三方库是不能使用CocoaPods管理的，这就是所谓的”中心化“思想。而Carthage没有这样的中心库，::第三方库基本上都是从GitHub或者私有git库中下载的，这就是“去中心化”::。另外，CocoaPods下载第三方库后，会将其编译成静态链接库或者动态框架文件，这种做法会修改Xcode项目属性配置依赖关系，这就是所谓的”侵入性“。而Carthage下载成功后，会将第三方库编译为::动态框架::，由开发人员自己配置依赖关系，::Carthage不会修改Xcode项目属性::，这就是所谓的”非侵入性“。 基本使用 创建Xcode工程并切换到该工程路径 创建一个Cartfile，将你想要使用的框架列在里面github “AFNetworking/AFNetworking” ~&gt; 3.0github “rs/SDWebImage”github “github url” 运行carthage update，将获取依赖文件到一个Carthage.checkout文件夹，然后编译每个依赖 在你的应用程序target的General设置标签中的Embedded Binaries区域，将框架从Carthage.build文件夹拖拽进去。 注意事项Carthage编译你的依赖，并提供框架的二进制文件，但你仍然保留对项目的结构和设置的完整控制。Carthage不会自动的修改你的项目文件或编译设置。Carthage只正式支持动态框架，动态框架能够在任何版本的OS X上使用，但只能在iOS 8及以上版本使用。 CocoaPods 和 Carthage 的区别 Carthage只支持iOS 8及以上版本使用。 首先，CocoaPods默认会自动创建并更新你的应用程序和所有依赖的Xcode workspace。Carthage使用xcodebuild来编译框架的二进制文件，但如何集成它们将交由用户自己判断。CocoaPods的方法更易于使用，但Carthage更灵活并且是非侵入性的。 CocoaPods的目标在它的README文件描述如下：…为提高第三方开源库的可见性和参与度，创建一个更中心化的生态系统。与之对照，Carthage创建的是去中心化的依赖管理器。它没有总项目的列表，这能够减少维护工作并且避免任何中心化带来的问题（如中央服务器宕机）。不过，这样也有一些缺点，就是项目的发现将更困难，用户将依赖于Github的趋势页面或者类似的代码库来寻找项目。 CocoaPods项目同时还必须包含一个podspec文件，里面是项目的一些元数据，以及确定项目的编译方式。Carthage使用xcodebuild来编译依赖，而不是将他们集成进一个workspace，因此无需类似的设定文件。不过依赖需要包含自己的Xcode工程文件来描述如何编译。 最后，我们创建Carthage的原因是想要一种尽可能简单的工具——一个只关心本职工作的依赖管理器，而不是取代部分Xcode的功能，或者需要让框架作者做一些额外的工作。CocoaPods提供的一些特性很棒，但由于附加的复杂性，它们将不会被包含在Carthage当中。 Reference https://www.jianshu.com/p/6c4b1b4a69c5iOS cocoapods 使用以及版本更新 - chrisbin - 博客园CocoaPods和Carthage浅析(新) - 简书]]></content>
      <categories>
        <category>iOS &amp; Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试准备]]></title>
    <url>%2F2019%2F03%2F11%2F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[internship 面试方向 IOS 开发 后端开发 前端开发 爬虫和数据分析 投递范围 BAT Jike ByteDance bilibili MicroSoft Google 各大独角兽🦄️ 时间点腾讯暑期实习生招聘FAQ — 校招动态 | Tencent 校园招聘京东招聘——招聘流程 基本准备 简历 英语六级 啃书 编程珠玑（英文） 重构（英文） TCP / IP 卷一 （英文） 计算机组织与结构（英文） 算法 技能树语言级别 C 高级 JAVA 高级 Python 高级 Swift 高级 JavaScript 高级 基础级别 算法和刷题 操作系统 编译原理 面向对象 计算机网络 数据结构 计算机组成 数据库原理 应用级别 关系型数据库 非关系型数据库 SQLite Linux 编程 Cocoa 架构 前端框架一到两个 后端维护及框架一到两个 爬虫框架一到两个 Docker 高级 Linux http 和 TCP/IP 协议 产品及项目级别 一个完整的 Swift 项目 小程序迭代 博客搭建 ::完成度✅ 达到 80% 以上就买 AirPods 🎧::]]></content>
      <categories>
        <category>Internship</category>
      </categories>
      <tags>
        <tag>TODO</tag>
      </tags>
  </entry>
</search>
